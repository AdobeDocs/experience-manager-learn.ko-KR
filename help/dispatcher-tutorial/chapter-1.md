---
title: 1장 - 자습서 설정 및 다운로드
seo-title: AEM Content Services 시작하기 - 1장 - 자습서 설정
description: AEM 헤드리스 자습서의 1장에서는 자습서에 대한 AEM 인스턴스의 기준선 설정을 설명합니다.
seo-description: AEM 헤드리스 자습서의 1장에서는 자습서에 대한 AEM 인스턴스의 기준선 설정을 설명합니다.
translation-type: tm+mt
source-git-commit: b040bdf97df39c45f175288608e965e5f0214703
workflow-type: tm+mt
source-wordcount: '17502'
ht-degree: 0%

---


# 1장 - 발송자 개념, 패턴 및 안티패턴

## 개요

이 장에서는 Dispatcher의 작업 내역과 구조에 대한 간단한 설명을 제공하며 AEM 개발자가 구성 요소를 디자인하는 방식에 미치는 영향을 설명합니다.

## 개발자가 인프라에 관심을 가져야 하는 이유

Dispatcher는 대부분의 AEM 설치에 필수적인 요소입니다. 팁과 트릭 외에도 Dispatcher 구성 방법을 설명하는 많은 온라인 문서를 볼 수 있습니다.

이러한 정보 조각은 그러나 항상 매우 기술적인 수준에서 시작됩니다. - 사용자가 원하는 것을 이미 알고 있으며 따라서 원하는 것을 얻는 방법에 대한 세부 정보만 제공한다고 가정합니다. 디스패처를 사용하여 할 수 있는 것과 할 수 없는 것에 대해 _무엇이 무엇이고_&#x200B;가 무엇인지에 대해 설명하는 개념 논문을 찾지 못했습니다.

### 항패턴:Dispatcher를 Afterthink로

이러한 기본적인 정보의 부족은 많은 안티 패턴으로 이어집니다. 우리는 많은 AEM 프로젝트에서 보았으며,

1. Dispatcher가 Apache 웹 서버에 설치됨에 따라 프로젝트에서 &quot;Unix Gods&quot;를 구성하여 구성합니다. &quot;인간적 자바 개발자&quot;는 그것을 염려할 필요가 없다.

2. Java 개발자는 코드가 작동하는지 확인해야 합니다. 나중에 디스패처가 마술처럼 빠르게 만들 것입니다. 디스패처는 항상 때늦은 생각이다. 그러나 이는 효과가 없습니다. 개발자는 디스패처를 염두에 두고 자신의 코드를 설계해야 합니다. 그리고 그는 그것을 하기 위해 그것의 기본 개념을 알아야 합니다.

### &quot;먼저 작동하게 하고 빠르게 만들어&quot; 항상 옳지는 않음

프로그래밍 조언 _&quot;First make it work - then make it fast.&quot;_. 완전히 틀린 것은 아니다. 그러나 올바른 컨텍스트가 없으면 잘못 해석되고 올바로 적용되지 않는 경향이 있습니다.

이러한 권고 사항은 개발자가 너무 빨리 코드를 최적화하지 못하도록 해야 하며, 이것은 실행되지 않거나 매우 드물게 실행되므로 최적화가 최적화에 투입되는 노력을 정당화할 수 있는 충분한 영향을 주지 않습니다. 또한 최적화를 통해 더 복잡한 코드가 생성되어 버그가 발생할 수 있습니다. 따라서 개발자의 경우 각 단일 코드 행을 미시적으로 최적화하는 데 많은 시간을 허비하지 마십시오. 적합한 데이터 구조, 알고리즘 및 라이브러리를 선택했는지 확인한 다음 프로파일러의 핫스팟 분석을 통해 최적화를 통해 전반적인 성능을 향상시킬 수 있는 부분을 확인할 수 있습니다.

### 건축상의 결정 및 가공물

하지만 &quot;우선 성공하고 빨리 만들어라&quot; 는 충고는 &quot;건축&quot; 결정에 있어서 완전히 잘못된 것이다. 건축적 결정은 무엇인가? 간단히 말해서, 그것들은 비싸고, 어렵거나, 또는 나중에 바꿀 수 없는 결정들이다. &quot;비싼&quot;는 때때로 &quot;불가능하다&quot;와 같다는 것을 명심해라.  예를 들어 프로젝트의 예산이 부족한 경우 고가의 변경 사항을 구현할 수 없습니다. 사회 기반 시설의 변화는 대부분의 사람들의 마음에 들어오는 그 범주에 있어 가장 먼저 일어나는 변화이다. 하지만 또한 변화하기 매우 불쾌한 다른 종류의 &quot;건축&quot; 유물들도 있다:

1. 응용 프로그램의 &quot;중심&quot;에 있는 코드 조각이며 다른 많은 부분이 사용합니다. 이러한 사항을 변경하려면 모든 종속성을 한 번에 변경하고 다시 테스트해야 합니다.

2. 일부 비동기 및 시간 종속적 시나리오와 관련되어 있는 가공물은 입력의 위치에 따라 다릅니다. 따라서 시스템의 동작은 매우 임의로 다를 수 있습니다. 변경 사항은 예측할 수 없는 효과를 가지며 테스트하기가 어려울 수 있습니다.

3. 시스템의 모든 부분과 일부에서 사용되고 반복해서 다시 사용되는 소프트웨어 패턴입니다. 소프트웨어 패턴이 최적이 아닌 것으로 판명되면 패턴을 사용하는 모든 객체를 다시 코딩해야 합니다.

기억? 이 페이지 상단에는 Dispatcher가 AEM 애플리케이션의 필수 구성 요소라고 명시되어 있습니다. 웹 애플리케이션에 대한 액세스는 매우 무작위적인 방식으로 이루어집니다. 사용자는 예측할 수 없는 시간에 접근하고 있습니다. 마지막으로 모든 컨텐츠가 디스패처에 캐시됩니다(또는 그래야 함). 따라서 집중을 했다면 캐싱은 &quot;건축&quot; 유물로 보여질 수 있으므로 팀 구성원, 개발자, 관리자 모두 이해해야 합니다.

개발자가 실제로 디스패처를 구성해야 한다는 주장은 아닙니다. 또한 Dispatcher에서 자신의 코드를 활용할 수 있도록 개념과 특히 경계를 알아야 합니다.

디스패처는 코드 속도를 마술처럼 향상시키지 않습니다. 개발자는 Dispatcher를 염두에 두고 자신의 구성 요소를 만들어야 합니다. 그래서 어떻게 작동하는지를 알 필요가 있다.

## 발송자 캐싱 - 기본 원칙

### Dispatcher as Caching Http - 부하 균형 조정기

Dispatcher란 무엇이며 첫 번째 단계에서 &quot;Dispatcher&quot;라고 하는 이유는 무엇입니까?

디스패처는

* 캐시를 가장 먼저

* 역방향 프록시

* Apache httpd webserver용 모듈로, Apache의 다용성에 AEM 관련 기능을 추가하고 기타 모든 Apache 모듈(예: SSL 또는 SSI 포함)과 원활하게 작동합니다.

웹 초기에는 수백 명의 방문자가 사이트를 방문할 것으로 예상됩니다. 하나의 Dispatcher를 설정하고, 많은 AEM 게시 서버에 대한 요청의 로드를 &quot;전달&quot;하거나 균형 조정하며, 일반적으로 충분하므로 &quot;디스패처&quot;라는 이름이 적절했습니다. 하지만 요즘은 이런 설정이 더 이상 자주 사용되지 않는다.

이 문서의 후반부에 있는 다양한 방법으로 Dispatcher 및 게시 시스템을 설정할 수 있습니다. 먼저 http 캐싱 기본 사항을 살펴보겠습니다.

![Dispatcher 캐시의 기본 기능](assets/chapter-1/basic-functionality-dispatcher.png)

*Dispatcher 캐시의 기본 기능*

<br> 

디스패처의 기본 사항에 대해서는 여기에서 설명합니다. 디스패처는 HTTP 요청을 받고 만드는 기능을 갖춘 단순 캐싱 역방향 프록시입니다. 일반적인 요청/응답 주기는 다음과 같습니다.

1. 사용자가 페이지를 요청합니다.
2. Dispatcher는 렌더링된 버전의 페이지가 이미 있는지 확인합니다. 이 페이지에 대한 첫 번째 요청이고 Dispatcher가 로컬 캐시된 사본을 찾을 수 없다고 가정합니다.
3. 디스패처가 게시 시스템에서 페이지를 요청합니다
4. 게시 시스템에서 페이지는 JSP 또는 HTL 템플릿으로 렌더링됩니다
5. 페이지가 Dispatcher로 반환됩니다.
6. 디스패처가 페이지를 캐시합니다.
7. Dispatcher는 페이지를 브라우저에 반환합니다.
8. 동일한 페이지가 두 번째로 요청되는 경우 게시 인스턴스에서 다시 렌더링하지 않고도 Dispatcher 캐시에서 직접 해당 페이지를 제공할 수 있습니다. 이렇게 하면 게시 인스턴스에서 사용자 및 CPU 사이클에 대한 대기 시간이 단축됩니다.

마지막 섹션의 &quot;페이지&quot;에 대해 이야기하고 있었습니다. 그러나 동일한 구성표는 이미지, CSS 파일, PDF 다운로드 등과 같은 다른 리소스에 적용됩니다.

#### 데이터가 캐시되는 방식

Dispatcher 모듈은 Apache 서버가 제공하는 호스팅 기능을 활용합니다. HTML 페이지, 다운로드 및 사진과 같은 리소스는 Apache 파일 시스템에 간단한 파일로 저장됩니다. 간단합니다.

파일 이름은 요청된 리소스의 URL에 의해 파생됩니다. `/foo/bar.html` 파일을 요청하면 이 파일은 /`var/cache/docroot/foo/bar.html` 아래에 저장됩니다.

기본적으로 모든 파일이 캐싱되어 디스패처에 정적으로 저장되는 경우 게시 시스템의 플러그인을 가져올 수 있으며 디스패처는 간단한 웹 서버 역할을 합니다. 그러나 이것은 그 원칙을 설명하기 위한 것이다. 실생활도 더 복잡하다. 렌더링 프로세스의 동적 특성으로 인해 리소스 수가 무한할 수 있으므로 모든 것을 캐싱할 수 없으며 캐시는 절대 &quot;완전하지 않음&quot;입니다. 정적 파일 시스템 모델은 디스패처의 기능에 대한 대략적인 그림을 생성하는 데 도움이 됩니다. 그리고 디스패처의 한계를 설명하는 데 도움이 됩니다.

#### AEM URL 구조 및 파일 시스템 매핑

디스패처를 보다 자세히 이해하려면 간단한 샘플 URL의 구조를 다시 방문하도록 하십시오.  아래 예를 살펴보겠습니다.

`http://domain.com/path/to/resource/pagename.selectors.html/path/suffix.ext?parameter=value&amp;otherparameter=value#fragment`

* `http` 프로토콜

* `domain.com` 은 도메인 이름입니다.

* `path/to/resource` 는 리소스가 CRX에 저장되어 Apache 서버의 파일 시스템에 저장되는 경로입니다.

여기에서는 AEM 파일 시스템과 Apache 파일 시스템 간에 약간 다릅니다.

AEM에서는

* `pagename` 은(는) 리소스 레이블입니다.

* `selectors` 리소스 렌더링 방식을 결정하기 위해 Sling에서 사용되는 여러 선택기를 의미합니다. URL에는 임의 개수의 선택기가 있을 수 있습니다. 그것들은 마침표로 분리된다. 선택기 섹션은 &quot;french.mobile.fancy&quot;와 같은 것일 수 있습니다. 선택기에는 문자, 숫자 및 대시만 포함되어야 합니다.

* `html` &quot;선택기&quot;의 마지막 부분으로 확장이라고 합니다. AEM/Sling에서도 렌더링 스크립트가 일부 결정됩니다.

* `path/suffix.ext` 는 URL에 접미사를 붙여넣을 수 있는 경로 같은 표현식입니다.  이 플러그인을 AEM 스크립트에서 사용하여 리소스가 렌더링되는 방식을 추가로 제어할 수 있습니다. 이 부분에 대한 모든 부분이 나중에 나올 것입니다. 현재로서는 추가 매개 변수로 사용할 수 있음을 알고 있어야 합니다. 접미사에 확장이 있어야 합니다.

* `?parameter=value&otherparameter=value` 는 URL의 쿼리 섹션입니다. 임의 매개 변수를 AEM에 전달하는 데 사용됩니다. 매개 변수가 있는 URL은 캐싱할 수 없으므로 매개 변수는 반드시 필요한 경우에 제한됩니다.

* `#fragment`를 제외한 URL의 조각 부분은 AEM에 전달되지 않으며, 이 부분은 브라우저에서만 사용됩니다.JavaScript 프레임워크에서 &quot;라우팅 매개 변수&quot;로 정의하거나 페이지의 특정 부분으로 이동할 수 있습니다.

Apache(*아래 다이어그램 참조*)에서

* `pagename.selectors.html` 는 캐시의 파일 시스템에서 파일 이름으로 사용됩니다.

URL에 접미사 `path/suffix.ext`이 있는 경우,

* `pagename.selectors.html` 폴더로 작성됨

* `path` 폴더의  `pagename.selectors.html` 폴더

* `suffix.ext` 는 폴더에 있는  `path` 파일입니다. 참고:접미사에 확장자가 없으면 파일이 캐시되지 않습니다.

![Dispatcher에서 URL을 가져온 후 파일 시스템 레이아웃](assets/chapter-1/filesystem-layout-urls-from-dispatcher.png)

*Dispatcher에서 URL을 가져온 후 파일 시스템 레이아웃*

<br> 

#### 기본 제한 사항

URL, 리소스와 파일 이름 간의 매핑은 매우 간단합니다.

하지만 몇 가지 덫을 발견했을지도 모르지만

1. URL이 매우 길어질 수 있습니다. 로컬 파일 시스템에 `/docroot`의 &quot;path&quot; 부분을 추가하면 일부 파일 시스템의 제한을 쉽게 초과할 수 있습니다. Windows에서 NTFS로 Dispatcher를 실행하면 문제가 될 수 있습니다. 그러나 Linux에서는 안전합니다.

2. URL에는 특수 문자와 움라우트를 포함할 수 있습니다. 이것은 일반적으로 디스패처에 문제가 되지 않습니다. 그러나 URL은 애플리케이션의 여러 위치에서 해석된다는 점을 염두에 두십시오. 종종 응용 프로그램에서 이상한 동작을 경험했습니다. 드물게 사용되는(사용자 지정) 코드 중 하나가 특수 문자에 대해 철저하게 테스트되지 않았다는 사실을 알고 있었습니다. 할 수 있다면 그들을 피해야 한다. 그렇지 않다면 철저한 테스트를 계획해 보십시오.

3. CRX에서는 리소스에 하위 리소스가 있습니다. 예를 들어 페이지에 여러 개의 하위 페이지가 있습니다. 파일 시스템에 파일이나 폴더가 있으므로 파일 시스템에서 이 파일을 일치시킬 수 없습니다.

#### 확장 기능이 없는 URL은 캐시되지 않습니다.

URL에는 항상 확장이 있어야 합니다. AEM에서 확장 없이 URL을 제공할 수 있습니다. 이러한 URL은 Dispatcher에서 캐시되지 않습니다.

**예**

`http://domain.com/home.html` 을(를)  **취소할 수 있음**

`http://domain.com/home` 을(를)  **사용할 수 없습니다.**

URL에 접미어가 포함되어 있을 때에도 동일한 규칙이 적용됩니다. 접미사를 사용하려면 확장 기능이 있어야 합니다.

**예**

`http://domain.com/home.html/path/suffix.html` 을(를)  **취소할 수 있음**

`http://domain.com/home.html/path/suffix` 을(를)  **사용할 수 없습니다.**

리소스 부품에 확장자가 없지만 접미사에 확장자가 없으면 어떻게 됩니까? 글쎄요, 이 경우 URL은 전혀 접미어가 없습니다. 다음 예를 보십시오.

**예**

`http://domain.com/home/path/suffix.ext`

`/home/path/suffix`은 리소스의 경로이므로 URL에 접미어가 없습니다.

**결론**

항상 패스와 접미어 모두에 확장을 추가합니다. SEO를 아는 사람들은 이것이 검색 결과에 있어서 여러분을 순위를 매기고 있다고 말하기도 합니다. 그러나 페이지가 너무 느리고 순위가 더 내려간다.

#### 접미어 URL 충돌

유효한 URL이 2개 있다고 가정합니다.

`http://domain.com/home.html`

및

`http://domain.com/home.html/suffix.html`

AEM에서는 절대적으로 유효하다. 로컬 개발 컴퓨터에서는 Dispatcher가 없으면 문제가 표시되지 않습니다. 또한 UAT 또는 로드 테스트에서도 문제가 발생하지 않을 수 있습니다. 우리가 직면하고 있는 문제는 너무 미세해서 대부분의 시험을 통과한다.  사용량이 가장 많은 시간에 고객에게 타격을 줄 수 있으며, 해결에는 시간이 제한되며, 서버 액세스나 수정할 리소스가 없을 수 있습니다. 우리는 그곳에 있었습니다...

그래서.. 뭐가 문제죠?

`home.html` 파일 시스템에서 파일 또는 폴더를 사용할 수 있습니다. AEM에서와 동시에 둘 다 아닙니다.

먼저 `home.html`을 요청하면 파일로 만들어집니다.

`home.html/suffix.html`에 대한 후속 요청은 유효한 결과를 반환하지만, 파일 시스템 위치의 `home.html` &quot;블록&quot;일 때 `home.html`을(를) 폴더로 두 번째로 만들 수 없으므로 `home.html/suffix.html`이(가) 캐시되지 않습니다.

![파일 시스템의 파일 차단 위치 때문에 하위 리소스가 캐시되지 않습니다.](assets/chapter-1/file-blocking-position-in-filesystem.png)

*파일 시스템의 파일 차단 위치 때문에 하위 리소스가 캐시되지 않습니다.*

<br> 

반대로 반올림하는 경우 먼저 `home.html/suffix.html`을 요청하는 경우 먼저 `suffix.html`이(가) `/home.html` 폴더 아래에 캐시됩니다. 그러나 나중에 리소스로 `home.html`을 요청할 때 이 폴더는 삭제되고 `home.html` 파일로 대체됩니다.

![상위 항목을 리소스로 가져오는 경우 경로 구조 삭제](assets/chapter-1/deleting-path-structure.png)

*상위 항목을 리소스로 가져오는 경우 경로 구조 삭제*

<br> 

따라서 캐시된 결과의 결과는 들어오는 요청의 순서에 따라 완전히 무작위로 결정됩니다. 더욱 까다로운 것은, 보통 한 명 이상의 디스패처가 있다는 사실이다. 또한 성능, 캐시 히트 및 동작은 Dispatcher마다 다를 수 있습니다. 웹 사이트에서 응답이 없는 이유를 확인하려면 캐싱 순서가 잘못된 Dispatcher를 올바르게 보고 있는지 확인해야 합니다. 만약 당신이 - 운이 좋게도 - 더 호의적인 요청 패턴이 있는 디스패처를 찾고 있다면, 당신은 문제를 찾느라 길을 잃게 될 것이다.

#### URL 충돌 방지

접미어가 있을 때 리소스에 대해 다른 확장명을 사용하는 경우 폴더 이름과 파일 이름이 파일 시스템의 동일한 경로에 대해 &quot;경쟁&quot;하는 &quot;URL 충돌&quot;을 방지할 수 있습니다.

**예**

* `http://domain.com/home.html`

* `http://domain.com/home.dir/suffix.html`

둘 다 완벽하게 취소될 수 있고

![](assets/chapter-1/cacheable.png)

접미사를 요청하거나 접미사를 함께 사용하지 않는 경우 리소스에 대한 전용 확장 &quot;dir&quot;을 선택합니다. 유용하게 활용할 수 있는 드문 경우도 있습니다. 이러한 사례를 올바로 실행하기가 쉽습니다.  다음 장에서는 캐시 무효화 및 플러싱에 대해 설명합니다.

#### 취소할 수 없는 요청

마지막 장에 대한 간단한 요약과 몇 가지 더 많은 예외 사항을 검토해 보겠습니다. 디스패처는 URL이 액세스 가능한 것으로 구성되어 있고 GET 요청인 경우 이를 캐싱할 수 있습니다. 다음 예외 중 하나에 캐시할 수 없습니다.

**액세스 가능한 요청**

* 요청이 Dispatcher 구성에서 액세스 가능하도록 구성되었습니다.
* 요청은 일반 GET 요청입니다.

**액세스 불가능한 요청 또는 응답**

* 구성으로 캐싱이 거부된 요청(경로, 패턴, MIME 유형)
* &quot;발송자:no-cache&quot; 헤더
* &quot;Cache-Control:no-cache|private&quot; 헤더
* &quot;Pragma:no-cache&quot; 헤더
* 쿼리 매개 변수를 사용한 요청
* 확장명이 없는 URL
* 확장자가 없는 접미어의 URL
* 200 이외의 상태 코드를 반환하는 응답
* POST 요청

## 캐시를 무효화하고 플러시합니다.

### 개요

마지막 장에서는 Dispatcher가 요청을 캐시할 수 없을 때 많은 수의 예외가 표시되었습니다. 그러나 고려해야 할 더 많은 것들이 있습니다.Dispatcher _이 요청을 캐시할 수 있기 때문에_&#x200B;이(가)_이어야 한다는 의미는 아닙니다._

요점은 다음과 같습니다.캐싱은 일반적으로 간단합니다. Dispatcher는 응답의 결과를 저장하고 동일한 요청이 수신될 때 다음 번에 응답해야 합니다. 오른쪽? 틀렸습니다!

어려운 부분은 캐시의 _무효화_ 또는 _플러싱_&#x200B;입니다. Dispatcher는 리소스가 변경된 시점을 확인하고 다시 렌더링해야 합니다.

이것은 일견 사소한 일로 여겨지지만... 또한 하나의 리소스와 여러 리소스의 집중화된 구조에 의존하는 페이지 간의 미묘한 차이를 살펴볼 수 있습니다.

### 간단한 리소스 및 플러싱

특별한 &quot;축소판&quot; 선택기로 요청을 받은 경우 AEM 시스템에서 각 이미지에 대한 축소판 변환을 동적으로 생성하도록 설정했습니다.

`/content/dam/path/to/image.thumb.png`

그리고 - 물론, 선택기 없는 URL과 함께 원본 이미지를 제공하는 URL을 제공합니다.

`/content/dam/path/to/image.png`

축소판과 원본 이미지를 모두 다운로드하면

```
/var/cache/dispatcher/docroot/content/dam/path/to/image.thumb.png

/var/cache/dispatcher/docroot/content/dam/path/to/image.png
```

를 참조하십시오.

이제 사용자가 해당 파일의 새 버전을 업로드하고 활성화합니다. 궁극적으로 무효화 요청은 AEM에서 디스패처에 전송되며

```
GET /invalidate
invalidate-path:  /content/dam/path/to/image

<no body>
```

무효화는 매우 쉽다.디스패처의 특수 &quot;/invalidate&quot; URL에 대한 간단한 GET 요청. HTTP-body는 필요하지 않으며 &quot;페이로드&quot;는 &quot;invalidate-path&quot; 헤더일 뿐입니다. 헤더의 무효화 경로는 AEM이 알고 있는 리소스이며 Dispatcher가 캐시한 파일이나 파일은 아닙니다. AEM은 리소스에 대해서만 알고 있습니다. 리소스가 요청되면 런타임 시 확장 기능, 선택기 및 접미어가 사용됩니다. AEM에서는 어떤 선택기가 자원에서 사용되었는지에 대해 부기를 수행하지 않으므로 리소스를 활성화할 때 반드시 알고 있는 것은 리소스 경로입니다.

우리의 경우에는 이것이 충분하다. 리소스가 변경된 경우 해당 리소스의 모든 표현도 변경되었다고 간주할 수 있습니다. 이 예제에서는 이미지가 변경된 경우에도 새 축소판이 렌더링됩니다.

디스패처는 캐시된 모든 표현물과 함께 리소스를 안전하게 삭제할 수 있습니다. 그런 짓을 하면

`$ rm /content/dam/path/to/image.*`

`image.png` 및 `image.thumb.png` 및 해당 패턴과 일치하는 다른 모든 변환 제거

정말 간단합니다... 하나의 리소스를 사용하여 요청에 응답하는 한..

### 참조 및 메쉬드 컨텐츠

#### 전송된 컨텐츠 문제

AEM에 업로드된 이미지 또는 다른 이진 파일과 달리 HTML 페이지는 독거적이지 않습니다. 그들은 양 떼에서 살고 있으며 하이퍼링크와 참조를 통해 서로 매우 연결되어 있습니다. 단순 링크는 해롭지 않지만 컨텐트 참조 사항에 대해 이야기할 때는 까다롭습니다. 페이지에 있는 유비쿼터스 상단 내비게이션 또는 티저는 컨텐츠 참조입니다.

#### 컨텐츠 참조 및 문제가 되는 이유

간단한 예를 살펴보겠습니다. 여행사에는 캐나다 여행을 홍보하는 웹 페이지가 있다. 이 프로모션은 &quot;홈&quot; 페이지 및 &quot;겨울 특별&quot; 페이지의 다른 두 페이지의 티저 섹션에 설명되어 있습니다.

두 페이지 모두에 동일한 Teaser가 표시되므로 작성자에게 표시되어야 할 각 페이지에 대해 Teaser를 여러 번 만들도록 요청해도 불필요한 작업일 수 있습니다. 대신, 대상 페이지 &quot;캐나다&quot;는 티저에 대한 정보를 제공하거나 티저를 모두 렌더링하는 URL을 제공하기 위해 페이지 속성의 섹션을 예약합니다.

`<sling:include resource="/content/home/destinations/canada" addSelectors="teaser" />`

또는

`<sling:include resource="/content/home/destinations/canada/jcr:content/teaser" />`

![](assets/chapter-1/content-references.png)

매력적으로 작동하는 AEM에서만 사용할 수 있지만 게시 인스턴스에서 Dispatcher를 사용하면 이상한 일이 발생합니다.

웹 사이트를 게시했다고 가정해 보십시오. 캐나다 페이지의 제목은 &quot;캐나다&quot;입니다. 방문자가 해당 페이지에 대한 티저 참조가 있는 홈 페이지를 요청하면 &quot;캐나다&quot; 페이지의 구성 요소는 다음과 같은 항목을 렌더링합니다

```
<div class="teaser">
  <h3>Canada</h3>
  <img …>
</div>
```

*홈* 페이지로 이동합니다. 홈 페이지는 Dispatcher에서 Teaser를 비롯한 정적 .html 파일로 저장됩니다.

이제 마케터는 Teaser 헤드라인을 실행 가능하게 해야 한다는 사실을 알게 되었습니다. 따라서, 그는 &quot;캐나다&quot;에서 &quot;캐나다 방문&quot;으로 제목을 바꾸고 이미지를 업데이트하기로 합니다.

편집된 &quot;캐나다&quot; 페이지를 게시하고 이전에 게시된 홈 페이지를 수정하여 변경 내용을 확인합니다. 하지만... 아무것도 변하지 않았어 이전 티저가 여전히 표시됩니다. 그는 &quot;겨울 특별 행사&quot;를 재확인한다. 이 페이지는 이전에 요청되지 않았으므로 Dispatcher에 정적으로 캐시되지 않습니다. 따라서 이 페이지는 게시에서 새로 렌더링되며 이 페이지에는 새로운 &quot;캐나다 방문&quot; 티저가 포함되어 있습니다.

![홈 페이지에 오래된 포함 콘텐츠를 저장하는 디스패처](assets/chapter-1/dispatcher-storing-stale-content.png)

*홈 페이지에 오래된 포함 콘텐츠를 저장하는 디스패처*

<br> 

무슨 일이야? Dispatcher는 렌더링하는 동안 다른 리소스에서 그린 모든 컨텐츠 및 마크업이 포함된 페이지의 정적 버전을 저장합니다.

파일 시스템 기반의 웹 서버인 Dispatcher는 속도가 빠르지만 비교적 간단합니다. 포함된 리소스가 변경되어도 이를 인식하지 못합니다. 포함 페이지가 렌더링될 때 있었던 컨텐츠가 여전히 표시됩니다.

&quot;겨울 특별&quot; 페이지가 아직 렌더링되지 않았기 때문에 Dispatcher에는 정적 버전이 없으므로 요청 시 새로 렌더링되므로 새 Teaser와 함께 표시됩니다.

이러한 리소스가 변경될 때 Dispatcher는 이 리소스를 사용한 모든 페이지를 렌더링하고 플러싱하는 동안 자신이 접하는 모든 리소스를 추적하고 있다고 생각할 수 있습니다. 하지만 디스패처는 페이지를 렌더링하지 않습니다. 렌더링은 게시 시스템에서 수행됩니다. Dispatcher는 렌더링된 .html 파일에 어떤 리소스가 포함되는지 알지 못합니다.

아직도 확신하지 못합니까? *&quot;종속성 추적&quot;*&#x200B;을(를) 구현하는 방법이 있을 수 있습니다. 음, 또는 더 정확히 *was*&#x200B;이 있습니다. AEM의 증조부인 Coranc 3은 페이지를 렌더링하는 데 사용된 _session_&#x200B;에 구현된 종속성 추적기를 가지고 있었습니다.

요청 중에 이 세션을 통해 확보한 각 리소스는 현재 렌더링되고 있는 URL의 종속성으로 추적되었습니다.

그러나 의존 관계를 추적하는 것은 매우 비용이 많이 들었습니다. 사람들은 종속성 추적 기능을 모두 비활성화하고 하나의 html 페이지가 변경된 후 모든 html 페이지를 다시 렌더링하는 데 의존하면 웹 사이트가 더 빨라진다는 것을 알게 되었습니다. 게다가, 그 계획은 완벽하지 않았다 - 그 도중에 많은 함정과 예외가 있었다. 요청 기본 세션을 사용하여 리소스를 가져오지 않고 관리 세션을 사용하여 요청을 렌더링하는 도우미 리소스를 가져오기도 했습니다. 이러한 종속성은 일반적으로 추적되지 않았고, 번거로움을 초래했고, 운영 팀에 전화를 걸어 캐시를 수동으로 플러시하도록 요청했습니다. 그들이 그것을 할 표준 절차를 가졌다면 당신은 행운이었다. 그 동안 더 많은 문제가 있었지만... 추억에 잠기지 말자. 이것은 2005년으로 거슬러 올라간다. 결국 이 기능은 기본적으로 Coanc 4에서 비활성화되었고 후속 CQ5로 다시 변환되지 못하여 AEM이 되었습니다.

### 자동 무효화

#### 전체 플러싱이 종속성 추적보다 더 싼 경우

CQ5 이후 페이지 중 하나만 변경될 경우 전체 사이트를 무효화 또는 그 이하에 전적으로 의존합니다. 이 기능을 &quot;자동 무효화&quot;라고 합니다.

그러나 다시 한 번 말하지만 수백 개의 페이지를 버리고 다시 렌더링하는 것이 적절한 종속성 추적 및 부분 다시 렌더링하는 것보다 저렴하다는 것이 어떻게 가능합니까?

두 가지 주요 이유가 있습니다.

1. 평균 웹 사이트에서는 페이지의 일부 하위 세트만 자주 요청됩니다. 따라서 렌더링된 모든 컨텐츠를 버리더라도 실제로는 수십 개만 즉시 요청됩니다. 페이지가 실제로 요청되는 시간에 따라 긴 페이지 렌더링이 분산될 수 있습니다. 따라서 실제로 렌더링 페이지에 대한 로드는 예상만큼 높지 않습니다. 물론 항상 예외가 있습니다. 나중에 빈 Dispatcher 캐시를 통해 대규모 웹 사이트에서 동일하게 배포된 로드를 처리하는 방법에 대해 논의합니다.

2. 어쨌든 모든 페이지는 주 탐색에 연결되어 있습니다. 그래서 궁극적으로 거의 모든 페이지는 서로 의존합니다. 이것은 가장 똑똑한 종속성 추적기조차도 우리가 이미 알고 있는 것을 발견할 것이라는 것을 의미합니다.페이지 중 하나가 변경되면 다른 모든 페이지를 무효화해야 합니다.

안 믿으세요? 마지막 요점을 설명하겠습니다.

마지막 예제와 동일한 인수를 원격 페이지의 컨텐츠를 참조하는 티저와 사용합니다. 이제는 좀 더 극단적인 예를 사용하고 있습니다.자동으로 렌더링된 기본 탐색. Teaser에서와 마찬가지로, 내비게이션 제목은 연결된 페이지 또는 &quot;원격&quot; 페이지에서 콘텐츠 참조로 그려집니다. 원격 탐색 제목은 현재 렌더링된 페이지에 저장되지 않습니다. 내비게이션은 웹 사이트의 각 페이지와 모든 페이지에서 렌더링됩니다. 따라서 한 페이지의 제목은 주 탐색이 있는 모든 페이지에서 여러 번 사용됩니다. 탐색 제목을 변경하려면 해당 페이지를 참조하는 모든 페이지뿐만 아니라 원격 페이지에서만 이 작업을 수행합니다.

따라서 이 예에서는 대상 페이지의 &quot;NavTitle&quot;을 사용하여 탐색 시 이름을 렌더링함으로써 모든 페이지가 함께 탐색됩니다. &quot;아이슬란드&quot;의 탐색 제목은 &quot;아이슬란드&quot; 페이지에서 그려져 주 탐색 영역이 있는 각 페이지로 렌더링됩니다.

![기본 탐색은 &quot;NavTitles&quot;를 가져오므로 모든 페이지의 컨텐츠를 함께 전송할 수 없습니다.](assets/chapter-1/nav-titles.png)

*기본 탐색은 &quot;NavTitles&quot;를 가져오므로 모든 페이지의 컨텐츠를 함께 전송할 수 없습니다.*

<br> 

아이슬란드 페이지의 NavTitle을 &quot;아이슬란드&quot;에서 &quot;아름다운 아이슬란드&quot;으로 변경하면 다른 모든 페이지의 기본 메뉴에 제목이 즉시 변경됩니다. 따라서 변경 전에 페이지가 렌더링되고 캐시되면 모두 오래된 상태가 되며 무효화되어야 합니다.

#### 자동 무효화 구현 방법:.stat 파일

이제 수천 개의 페이지가 있는 대규모 사이트가 있는 경우, 모든 페이지를 반복하고 물리적으로 삭제하기까지 상당한 시간이 소요됩니다. 이 기간 동안 Dispatcher는 실수로 부실 컨텐츠를 제공할 수 있습니다. 또한 캐시 파일에 액세스하는 동안 충돌이 발생할 수 있으며, 페이지가 삭제되는 동안 페이지가 요청되거나, 즉시 다음 활성화 이후 발생한 두 번째 무효화로 페이지가 다시 삭제될 수도 있습니다. 무엇이 엉망인지 생각해 보아라. 다행히 이런 일은 일어나지 않는다. 디스패처는 이를 피하기 위해 영리한 방법을 사용합니다.수백 수천 개의 파일을 삭제하는 대신 파일이 게시되면 파일 시스템의 루트에 빈 단순 파일을 배치하므로 모든 종속 파일이 유효하지 않은 것으로 간주됩니다. 이 파일을 &quot;statfile&quot;이라고 합니다. statefile은 비어 있습니다. statefile에 대한 중요한 것은 작성 날짜입니다.

시작 날짜가 상태 파일보다 오래된 디스패처의 모든 파일은 마지막 활성화(및 무효화) 전에 렌더링되어 &quot;잘못된&quot; 것으로 간주됩니다. 파일 시스템에 여전히 물리적으로 존재하지만 디스패처는 이를 무시합니다. 그것들은 &quot;진부하다&quot;. 오래된 리소스에 대한 요청이 있을 때마다 Dispatcher는 AEM 시스템에 페이지를 다시 렌더링하도록 요청합니다. 새로 렌더링된 페이지는 파일 시스템에 저장됩니다. 이제 새 생성 날짜와 함께 새로 만들어집니다.

![.stat 파일의 작성 날짜는 오래된 컨텐츠와 새로 고친 컨텐츠를 정의합니다.](assets/chapter-1/creation-date.png)

*.stat 파일의 작성 날짜는 오래된 컨텐츠와 새로 고친 컨텐츠를 정의합니다.*

<br> 

왜 이것이 &quot;.stat&quot;라고 부르는지 물어볼 수 있습니다. 그리고 아마도 &quot;.epired&quot;가 아닐까요? 파일 시스템에 해당 파일이 있으면 Dispatcher가 정적 웹 서버에서와 같이 *정적으로*&#x200B;서비스를 제공할 수 있는 리소스를 판별할 수 있습니다. 이러한 파일을 더 이상 동적으로 렌더링할 필요가 없습니다.

하지만 이 이름의 진정한 본성은 덜 은유적이다. 이 값은 다른 속성 중에서 파일의 수정 시간을 반환하는 Unix 시스템 호출 `stat()`에서 파생됩니다.

#### 단순 및 자동 유효성 검사 혼합

하지만 잠시 만요... 우리가 말했듯이, 하나의 자원이 물리적으로 삭제되어진다고. 이제 보다 최근의 상태 파일이 실제로 디스패처의 눈에 유효하지 않게 렌더링될 것이라고 말합니다. 그렇다면 왜 먼저 물리적 삭제는?

답은 간단하다. 일반적으로 두 가지 전략을 동시에 사용하지만 서로 다른 유형의 리소스에서 사용합니다. 이미지와 같은 이진 자산은 자체 포함됩니다. 따라서 정보를 렌더링해야 한다는 의미에서 다른 리소스와 연결되지 않습니다.

반면에 HTML 페이지는 상호 의존적입니다. 그러면 자동 무효화를 적용할 수 있습니다. Dispatcher의 기본 설정입니다. 무효화된 리소스에 속하는 모든 파일은 물리적으로 삭제됩니다. 또한 &quot;.html&quot;로 끝나는 파일은 자동으로 무효화됩니다.

Dispatcher는 파일 확장명을 기준으로 자동 무효화 체계를 적용할지 여부를 결정합니다.

자동 무효화에 대한 파일 끝을 구성할 수 있습니다. 이론적으로 자동 무효화에 대한 모든 확장을 포함할 수 있습니다. 그러나 이것이 매우 높은 가격이라는 것을 명심하십시오. 부실 리소스가 잘못 전달되는 경우는 없지만, 과잉 무효화로 인해 배달 성능이 크게 저하됩니다.

예를 들어 PNG 및 JPG가 동적으로 렌더링되고 다른 리소스에 따라 렌더링되는 체계를 구현한다고 생각해 보십시오. 고해상도 이미지를 더 작은 웹 호환 해상도로 다시 조정할 수 있습니다. 이 경우 압축 속도도 변경됩니다. 이 예에서 해상도 및 압축 속도는 고정된 상수가 아니지만 이미지를 사용하는 구성 요소에서 구성 가능한 매개 변수를 사용합니다. 이제 이 매개 변수가 변경되면 이미지를 무효화해야 합니다.

문제 없습니다. 방금 알아낸 것은 자동 무효화에 이미지를 추가하고 변경 사항이 있을 때마다 항상 새로 렌더링된 이미지를 갖게 된다는 것입니다.

#### 목욕물과 함께 아기 버리고

맞아, 그리고 그건 큰 문제야. 마지막 단락을 다시 읽습니다. &quot;...변경 사항이 있을 때마다 새로 렌더링된 이미지.&quot; 아시다시피 좋은 웹 사이트는 끊임없이 변화합니다.여기에 새 컨텐츠를 추가하고 거기에서 오타를 수정하고 다른 곳에서 티저를 조정할 수 있습니다. 즉, 모든 이미지는 지속적으로 무효화되고 다시 렌더링해야 합니다. 그렇게 과소평가하지 마세요. 로컬 개발 시스템에서 동적으로 이미지 데이터를 렌더링하고 전송하는 작업은 밀리초 단위로 이루어집니다. 제작 환경에서는 초당 100배 더 자주 수행해야 합니다.

여기에서 명확하게 설명하자면 html 페이지가 변경되거나 그 반대로 변경되면 페이지를 다시 렌더링해야 합니다. 자동 무효화할 파일의 &quot;버킷&quot;은 하나만 있습니다. 전체적으로 플러시됩니다 더 자세한 구조물을 분해할 방법이 없습니다.

자동 무효화가 기본적으로 &quot;.html&quot;로 유지되는 데에는 합당한 이유가 있습니다. 목표는 그 양동이를 가능한 한 작게 유지하는 것이다. 그냥 안전한 곳에 있기 위해서 모든 것을 무효화함으로써 목욕물로 아기를 버리지 마세요.

자체 포함 리소스는 해당 리소스의 경로에서 제공해야 합니다. 그것은 많은 것을 무효화하는 데 도움이 된다. 단순하게 유지하고 &quot;/x/y/z&quot;에서 &quot;resource /a/b/c&quot;와 같은 매핑 체계를 만들지 마십시오. 구성 요소가 기본 Dispatcher의 자동 무효화 설정으로 작동되도록 합니다. 디스패처의 무효화가 너무 심해서 잘못 디자인된 구성 요소를 복구하려고 하지 마십시오.

##### 자동 무효화에 대한 예외:리소스만 무효화

일반적으로 디스패처에 대한 무효화 요청은 복제 에이전트가 게시 시스템에서 실행합니다.

종속성 측면에서 매우 확신을 갖고 있다면 귀사에서 귀사에 대해 잘못된 복제 에이전트를 구축하도록 시도할 수 있습니다.

자세한 내용을 살펴보려면 이 안내서가 좀 더 지나칠 수 있겠지만, 몇 가지 힌트가 필요합니다.

1. 네가 뭘 하는지 정말 알아 무효화를 하는 것은 정말 어렵다. 그것이 자동 무효화가 왜 그렇게 엄격한지 한 가지 이유입니다.오래된 컨텐츠를 제공하지 마십시오.

2. 에이전트가 HTTP-header `CQ-Action-Scope: ResourceOnly`을(를) 전송하는 경우 이 단일 무효화 요청이 자동 무효화를 트리거하지 않습니다. 이 코드( [https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle](https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle)) 부분은 자신의 복제 에이전트에 적합한 시작점이 될 수 있습니다.

3. `ResourceOnly`은 자동 무효화만 방지합니다. 실제로 필요한 종속성 해결 및 무효화를 수행하려면 무효화 요청을 직접 트리거해야 합니다. 실제로 발생할 수 있는 방법에 대한 영감을 얻으려면 패키지 Dispatcher 플러시 규칙([https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html](https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html))을 확인할 수 있습니다.

종속성 해결 체계를 빌드하는 것이 좋습니다. 너무 많은 노력과 적은 이익이 있다 - 그리고 전에 말했듯이, 당신이 틀릴 것은 너무 많다.

대신, 다른 리소스에 대한 종속성이 없고 자동 무효화 없이 무효화할 수 있는 리소스를 찾는 것이 좋습니다. 그러나 해당 문제에 대해 사용자 지정 복제 에이전트를 사용할 필요는 없습니다. 자동 무효화에서 이러한 리소스를 제외하는 사용자 지정 규칙을 Dispatcher 구성에서 만들면 됩니다.

주 탐색 또는 티저가 의존성의 원천이라고 했습니다. 글쎄요 - 내비게이션 및 티저를 비동기적으로 로드하거나 Apache에서 SSI 스크립트와 함께 포함시키는 경우 추적해야 하는 종속성이 없습니다. &quot;동적 포함 처리&quot;에 대해 이야기할 때 이 문서의 후반부에 있는 구성 요소를 비동기적으로 로드하는 방법에 대해 자세히 설명합니다.

팝업 창이나 라이트박스로 로드되는 컨텐츠에 대해서도 마찬가지입니다. 이러한 조각은 탐색(일명 &quot;종속성&quot;)도 거의 없으며 단일 리소스로 무효화할 수 있습니다.

## 발송자를 고려한 구성 요소 만들기

### 실제 사례에서 디스패처 기계 적용

마지막 장에서 디스패처의 기본 역학에 대한 설명, 일반적인 작동 방식, 제한 사항 등에 대해 설명했습니다.

이제 이러한 역학을 프로젝트의 요구 사항에서 찾을 수 있는 구성 요소 유형에 적용하려고 합니다. 또한 조만간 직면하게 될 문제를 증명하기 위해 의도적으로 구성 요소를 선택합니다. 두려움이 아닙니다 - 모든 구성요소는 우리가 제시할 그 정도의 고려사항을 필요로 하지 않습니다. 그러나 그러한 구성 요소를 만들 필요가 있다면, 결과를 잘 알고 그것을 처리하는 방법을 알게 될 것입니다.

### 스풀링 구성 요소(앤티) 패턴

#### 응답형 이미지 구성 요소

연결된 이진 파일이 있는 구성 요소의 공통 패턴(또는 패턴 방지)을 보여 줍니다. &quot;반응형 이미지&quot;용 구성 요소 &quot;응답&quot;을 만듭니다. 이 구성 요소는 표시된 이미지를 표시된 장치에 맞게 조정할 수 있어야 합니다. 데스크톱 및 태블릿에서는 이미지의 전체 해상도를 보여주며, 작은 크기의 휴대폰에서는 자르기 기능을 사용하거나 완전히 다른 모티브를 사용합니다(반응형 환경에서 &quot;아트 디렉션&quot;이라고 함).

자산은 AEM의 DAM 영역에 업로드되며 응답형 이미지 구성 요소에서는 _참조된_&#x200B;만 업로드됩니다.

응답 구성 요소는 마크업의 렌더링과 이진 이미지 데이터 제공을 모두 처리합니다.

여기서 구현하는 방법은 여러 프로젝트에서 우리가 보아온 일반적인 패턴이고 AEM 핵심 구성 요소 중 하나는 해당 패턴을 기반으로 합니다. 따라서, 개발자로서 여러분이 그 패턴을 적응할 가능성이 매우 높습니다. 캡슐화라는 측면에서 탁월한 점은 있지만 Dispatcher를 지원하는 데 많은 노력이 필요합니다. 우리는 나중에 그 문제를 완화시킬 수 있는 몇 가지 방법에 대해 논의할 것이다.

이 문제는 Cookie 3의 초기 날짜로부터 자원의 바이너리 Raw 데이터를 응답으로 스트리밍하기 위해 호출할 수 있는 &quot;스풀&quot;이 있었던 &quot;스풀러 패턴&quot;이라는 점에서 여기서 사용되는 패턴을 &quot;스풀러 패턴&quot;이라고 합니다.

원래 용어 &quot;스풀링&quot;은 프린터와 같은 느린 오프라인 주변 장치를 공유하므로 여기에 제대로 적용되지 않습니다. 그러나 온라인 세계에서는 드물기 때문에 구별 가능성이 없기 때문에 이 용어가 좋습니다. 그리고 각 패턴은 구별 가능한 이름을 가져야 합니다. 그렇죠? 이것이 패턴인지 반패턴인지 결정하는 것은 당신에게 달려 있다.

#### 구현

다음은 응답형 이미지 구성 요소를 구현하는 방법입니다.

그 구성 요소에는 두 개의 부품이 있다.첫 번째 부분은 이미지의 HTML 마크업을 렌더링하며, 두 번째 부분 &quot;스풀&quot;은 참조된 이미지의 이진 데이터입니다. 반응형 디자인을 갖는 최신 웹 사이트이므로 간단한 `<img src"…">` 태그가 아니라 `<picture/>` 태그에 있는 이미지 집합을 렌더링합니다. 각 장치에 대해 2개의 서로 다른 이미지를 DAM에 업로드하고 이미지 구성 요소에서 참조합니다.

구성 요소에는 JSP, HTL 또는 서블릿으로 구현된 3개의 렌더링 스크립트가 있으며 각 스크립트는 전용 선택기로 지정됩니다.

1. `/respi.jsp` - HTML 마크업을 렌더링할 선택기가 없습니다.
2. `/respi.img.java` 데스크톱 버전을 렌더링하려면
3. `/respi.img.mobile.java` 을 클릭하여 모바일 버전을 렌더링합니다.


구성 요소는 홈 페이지의 parsys에 배치됩니다. CRX의 결과 구조가 아래에 표시되어 있습니다.

![CRX에서 반응형 이미지의 리소스 구조](assets/chapter-1/responsive-image-crx.png)

*CRX에서 반응형 이미지의 리소스 구조*

<br> 

구성 요소 마크업은 다음과 같이 렌더링됩니다.

```plain
  #GET /content/home.html

  <html>

  …

  <div class="responsive-image>

  <picture>
    <source src="/content/home/jcr:content/par/respi.img.mobile.jpg" …/>
    <source src="/content/home/jcr:content/par/respi.img.jpg …/>

    …

  </picture>
  </div>
  …
```

그리고... 우리는 잘 캡슐화된 구성 요소를 완성했다.

#### 반응형 이미지 구성 요소 둘러보기

이제 사용자가 Dispatcher를 통해 페이지와 자산을 요청합니다. 이렇게 하면 Dispatcher 파일 시스템에 파일이 아래 그림과 같이 나타납니다.

![캡슐화된 응답형 이미지 구성 요소의 캐시된 구조](assets/chapter-1/cached-structure-encapsulated-image-comonent.png)

*캡슐화된 응답형 이미지 구성 요소의 캐시된 구조*

<br> 

사용자가 두 꽃 이미지의 새 버전을 DAM에 업로드하고 활성화한다고 가정합니다. AEM은 무효화 요청에 따라

`/content/dam/flower.jpg`

및

`/content/dam/flower-mobile.jpg`

을 발송합니다. 그러나 이러한 요구들은 허사롭다. 컨텐츠가 구성 요소의 하위 구조 아래에 있는 파일로 캐시되었습니다. 이러한 파일은 이제 오래된 상태이지만 요청 시 계속 제공됩니다.

![구조가 일치하지 않아 오래된 컨텐츠가 발생합니다.](assets/chapter-1/structure-mismatch.png)

*구조가 일치하지 않아 오래된 컨텐츠가 발생합니다.*

<br> 

이 접근법에 또 다른 주의해야 할 사항이 있다. 여러 페이지에 동일한 flower.jpg를 사용하는 것이 좋습니다. 그런 다음 여러 URL 또는 파일에 동일한 에셋을 캐시합니다.

```
/content/home/products/jcr:content/par/respi.img.jpg

/content/home/offers/jcr:content/par/respi.img.jpg

/content/home/specials/jcr:content/par/respi.img.jpg

…
```

새로운 및 캐시되지 않은 페이지가 요청될 때마다 다른 URL의 AEM에서 자산을 가져옵니다. Dispatcher 캐싱도 없고 브라우저 캐싱도 전달 속도를 높일 수 없습니다.

#### 스풀러 패턴이 빛나는 위치

이 패턴은 간단한 형태로도 유용할 수 있는 한 가지 자연 예외가 있습니다.바이너리가 DAM이 아니라 구성 요소 자체에 저장되는 경우입니다. 그러나 웹 사이트에서 한 번 사용되는 이미지에만 유용하며 DAM에 에셋을 저장하지 않으면 에셋을 관리하는 데 어려움이 있습니다. 특정 에셋에 대한 사용 라이선스가 부족한 경우를 생각해 보십시오. 자산을 사용한 구성 요소를 어떻게 확인할 수 있습니까?

봤지? DAM의 &quot;M&quot;은 디지털 자산 관리에서와 같이 &quot;관리&quot;를 의미합니다. 해당 기능을 무료로 제공하는 것은 원하지 않습니다.

#### 결론

AEM 개발자의 시각에서 그 패턴은 매우 우아해 보였다. 하지만 디스패처가 방정식에 들어간 상태에서, 당신은 잘못된 접근 방식이 충분하지 않을 수도 있다는 것에 동의할 수도 있습니다.

우리는 이것이 패턴인지 반패턴인지 결정하는 것을 당신에게 맡깁니다. 그리고 아마도 여러분은 이미 위에서 설명한 문제들을 어떻게 완화시킬 수 있는지 염두에 두고 좋은 생각들을 가지고 있을 수도 있습니다. 좋아 그러면 다른 프로젝트들이 이 문제를 어떻게 해결했는지 보고 싶어할 것이다.

### 일반적인 발송자 문제 해결

#### 개요

그것이 어떻게 좀 더 캐시 친화적으로 구현될 수 있었는지에 대해 이야기해 봅시다. 몇 가지 옵션이 있습니다. 경우에 따라 최적의 솔루션을 선택할 수 없습니다. 이미 실행 중인 프로젝트에 참여하여 &quot;캐시 문제&quot;를 직접 수정할 수 있는 한정된 예산을 보유하고 있을 뿐만 아니라 완벽하게 리팩토링을 수행할 수 없습니다. 또는 예제 이미지 구성 요소보다 더 복잡한 문제가 발생할 수 있습니다.

다음 섹션에 원칙 및 주의사항이 요약됩니다.

이것은 실생활의 경험에 기초하고 있다. 우리는 이미 야생에서 그런 모든 패턴들을 보았기 때문에 그것은 학문적인 운동이 아닙니다. 이것이 우리가 여러분에게 반패턴을 보여주고 있는 이유입니다. 그래서 여러분은 다른 사람들이 이미 저지른 실수로부터 배울 기회가 있습니다.

#### 캐시 킬러

>[!WARNING]
>
>이것은 반패턴입니다. 사용하지 마십시오. 언제든지

`?ck=398547283745`과 같은 쿼리 매개 변수를 본 적이 있습니까? 이를 캐시 킬러(&quot;ck&quot;)라고 합니다. 쿼리 매개 변수를 추가하면 리소스가 캐시되지 않습니다. 또한 임의 숫자를 매개 변수의 값으로 추가하면(예: &quot;398547283745&quot;) URL이 고유해지고 AEM 시스템과 화면 간의 다른 캐시도 되지 않도록 합니다. 보통 중간 혐의자는 디스패처, CDN 또는 브라우저 캐시 앞에 있는 &quot;Varnish&quot; 캐시입니다. 다시 한 번:그러지 마 리소스를 가능한 한 오래 캐시해야 합니다. 캐시는 네 친구다. 친구 죽이지 마

#### 자동 무효화

>[!WARNING]
>
>이것은 반패턴입니다. 디지털 자산에 사용하지 마십시오. Dispatcher의 기본 구성을 유지하십시오. 이 구성 > 은 &quot;.html&quot; 파일의 자동 무효화입니다.

단기적으로 디스패처의 자동 무효화 구성에 &quot;.jpg&quot; 및 &quot;.png&quot;를 추가할 수 있습니다. 즉, 무효화가 발생할 때마다 모든 &quot;.jpg&quot;, &quot;.png&quot; 및 &quot;.html&quot;을 다시 렌더링해야 합니다.

이러한 패턴은 비즈니스 소유자가 변경 사항이 라이브 사이트에서 빨리 실현되지 않는다고 불평 할 때 매우 쉽게 구현됩니다. 그러나 이것은 더욱 정교한 해결책을 도출해 낼 시간을 줄 수 있을 뿐이다.

성능에 미치는 영향을 정확하게 파악할 수 있습니다. 이렇게 하면 웹 사이트가 크게 느려지고 안정성에 영향을 미칠 수 있습니다. - 뉴스 포털과 같이 빈번하게 변경되는 로드 웹 사이트가 높은 경우

#### URL 지문

URL 지문은 캐시 킬러 같습니다. 하지만 그렇지 않습니다. 리소스 내용을 특정하는 값이 아닌 임의의 숫자입니다. 리소스 컨텐츠의 해시이거나, 리소스를 업로드, 편집 또는 업데이트할 때의 타임스탬프일 수 있습니다.

Unix 타임스탬프는 실제 구현에 충분합니다. 가독성을 높이기 위해 이 튜토리얼에서 보다 읽기 쉬운 형식을 사용하고 있습니다.`2018 31.12 23:59 or fp-2018-31-12-23-59`.

지문은 쿼리 매개 변수가 있는 URL이므로 쿼리 매개 변수로 사용해서는 안 됩니다.   캐시할 수 없습니다. 지문에 선택기 또는 접미어를 사용할 수 있습니다.

파일 `/content/dam/flower.jpg`에 2018년 12월 31일의 `jcr:lastModified` 날짜가 23:59라고 가정합니다. 지문이 있는 URL은 `/content/home/jcr:content/par/respi.fp-2018-31-12-23-59.jpg`입니다.

참조된 리소스(`flower.jpg`) 파일이 변경되지 않는 한 이 URL은 안정적으로 유지됩니다. 그래서 그것은 무기한 캐싱될 수 있고 캐시 킬러가 아닙니다.

이 URL은 응답형 이미지 구성 요소에서 만들고 제공해야 합니다. 기본적으로 제공되는 AEM 기능은 아닙니다.

그것이 기본 개념입니다. 그러나 쉽게 간과될 수 있는 몇 가지 세부 사항들이 있다.

이 예에서는 구성 요소가 23:59에 렌더링되고 캐시되었습니다. 이제 00:00으로 이미지가 변경되었습니다.  구성 요소 _would_&#x200B;은 해당 마크업에 새로운 지문 URL을 생성합니다.

_에_&#x200B;이(가) 있어야 한다고 생각할 수 있지만 그렇지 않습니다.이미지의 이진 항목만 변경되고 포함 페이지가 터치되지 않았으므로 HTML 마크업을 다시 렌더링할 필요가 없습니다. 따라서 Dispatcher는 이전 지문 및 이전 버전의 이미지를 제공하는 페이지를 제공합니다.

![이미지 구성 요소가 참조된 이미지보다 더 최신이고, 새로 생성된 지문이 없습니다.](assets/chapter-1/recent-image-component.png)

*이미지 구성 요소가 참조된 이미지보다 더 최신이고, 새로 생성된 지문이 없습니다.*

<br> 

이제 홈 페이지(또는 해당 사이트의 다른 페이지)를 다시 활성화하면 상태 파일이 업데이트됩니다. 이 경우 Dispatcher는 home.html을 오래된 것으로 간주하여 이미지 구성 요소의 새로운 지문으로 다시 렌더링합니다.

하지만 홈 페이지를 활성화하지 않은 거죠? 그런데 터치하지 않은 페이지를 활성화해야 하는 이유는 무엇입니까? 또한 페이지를 활성화할 수 있는 충분한 권한이 없거나 승인 워크플로우가 시간이 너무 오래 걸리고 있기 때문에 갑자기 알리지 않아도 됩니다. 어떻게 해야 합니까?

#### 지연 관리자의 도구 - 상태 수준 감소

>[!WARNING]
>
>이것은 반패턴입니다. 잠시 시간을 내어 보다 세련된 솔루션을 제안하려면 이 솔루션을 사용해야 합니다.

게으른 관리자는 보통 &quot;_자동 무효화를 jpg로 설정하고 statfile 수준을 0으로 설정합니다. 이렇게 하면 모든 종류의 캐싱 문제에 항상 도움이 됩니다.&quot;_ 기술 포럼에서 이러한 조언을 구할 수 있으며 무효화 문제에 도움이 됩니다.

지금까지 상태 파일 수준에 대해 논의하지 않았습니다. 기본적으로 자동 무효화는 동일한 하위 트리에 있는 파일에만 작동합니다. 그러나 일반적으로 페이지와 자산이 동일한 하위 트리에서 존재하지 않는다는 문제가 있습니다. 페이지는 `/content/mysite` 아래에 있는 반면 자산은 `/content/dam` 아래에 있습니다.

&quot;statfile level&quot;은 하위 트리의 깊이 루트 노드가 있는 위치를 정의합니다. 위의 예에서 수준 위의 예로는 &quot;2&quot;(1=/content, 2=/mysite,dam)가 있습니다.

기본적으로 상태 파일 수준을 0으로 &quot;감소&quot;하는 아이디어는 전체 /content 트리를 하나의 하위 트리로 정의하여 페이지와 자산을 동일한 자동 무효화 도메인에 라이브로 만듭니다. 따라서 최상위 수준(문서 &quot;/&quot;)에서만 큰 나무를 가질 수 있습니다. 하지만 이와 같이 하면 아무 관련 없는 사이트에서도 게시될 때마다 서버의 모든 사이트를 자동으로 무효화합니다. 신뢰할 수 있는 솔루션:전반적인 캐시 히트 비율이 크게 저하될 것이기 때문에 장기적으로 잘못된 생각입니다. 할 수 있는 것은 AEM 서버가 캐시 없이 실행될 수 있는 충분한 화력을 가지고 있다는 것입니다.

보다 나중에 더 깊은 상태 파일 레벨의 전체 이점을 파악할 수 있습니다.

#### 사용자 지정 무효화 에이전트 구현

어쨌든 - 새 URL로 다시 렌더링할 수 있도록 &quot;.jpg&quot; 또는 &quot;.png&quot;가 변경된 경우, Dispatcher에게 이 HTML-Pages를 무효화하도록 해야 합니다.

프로젝트에서 우리가 본 것은, 예를 들어, 해당 사이트의 이미지가 게시될 때마다 사이트에 대한 무효화 요청을 보내는 게시 시스템의 특별 복제 에이전트입니다.

여기서는 이름 지정 규칙을 사용하여 자산의 경로에서 사이트의 경로를 추출할 수 있는 경우에 유용합니다.

일반적으로 다음과 같은 사이트와 자산 경로를 일치시키는 것이 좋습니다.

**예**

```
/content/dam/site-a
/content/dam/site-b

/content/site-a
/content/site-b
```

이렇게 하면 사용자 지정 Dispatcher Flushing 에이전트가 `/content/dam/site-a`에 변경 사항이 있을 때 /content/site-a에 요청을 쉽게 보내고 무효화할 수 있습니다.

실제로 디스패처에 무효화하도록 하는 경로는 상관없습니다. 동일한 사이트(동일한 &quot;하위 트리&quot;에 있는 경우). 실제 리소스 경로를 사용하지 않아도 됩니다. &quot;가상&quot;일 수도 있습니다.

`GET /dispatcher-invalidate
Invalidate-path /content/mysite/dummy`

![](assets/chapter-1/resource-path.png)

1. DAM의 파일이 변경되면 게시 시스템의 리스너가 트리거됩니다

2. 리스너는 Dispatcher에 무효화 요청을 보냅니다. 자동 무효화로 인해 사이트의 홈 페이지 아래에 있거나 사이트의 상태 파일 수준에서 보다 정밀하지 않은 경우 자동 무효화에 보내는 경로는 문제가 되지 않습니다.

3. 상태 파일이 업데이트됩니다.

4. 다음에 홈 페이지가 요청되면 다시 렌더링됩니다. 이미지의 lastModified 속성에서 새 지문/날짜가 추가 선택기로 이동됩니다.

5. 이렇게 하면 새 이미지에 대한 참조가 암시적으로 만들어집니다

6. 이미지가 실제로 요청되면 Dispatcher에 새 변환이 만들어지고 저장됩니다


#### 청소의 필요성

휴. 완료됨. 만세!

음.. 아직..

경로,

`/content/mysite/home/jcr:content/par/respi.img.fp-2018-31-12-23-59.jpg`

는 무효화된 리소스 중 하나와 관련이 없습니다. 기억? &quot;더미&quot; 리소스만 무효화했으며 &quot;홈&quot;이 유효하지 않다고 간주하기 위해 자동 무효화에 의존했습니다. 이미지 자체는 _물리적으로_&#x200B;삭제되지 않았을 수 있습니다. 따라서 캐시는 확장되고 확장되어 확장됩니다. 이미지가 변경되고 활성화되면 Dispatcher의 파일 시스템에 새 파일 이름이 생성됩니다.

캐시된 파일을 물리적으로 삭제하지 않고 계속 유지하는 데 문제가 있는 세 가지 문제가 있습니다.

1. 스토리지 용량을 크게 낭비하고 있습니다. 허가 - 지난 몇 년 동안 저장 공간이 저렴해지고 저렴해졌다. 그러나 이미지 해상도와 파일 크기도 최근 몇 년 동안 증가했으며 수정처럼 선명한 이미지에 필요한 레티나 디스플레이가 출현했다.

2. 하드 드라이브가 저렴해졌지만, &quot;저장&quot;이 더 싸지는 않았을 수도 있다. Adobe는 데이터 센터 제공업체의 NAS에 BMR(Bare Metal HDD) 스토리지가 없고 가상 스토리지를 대여하는 경향이 있다는 점을 파악하고 있습니다. 이러한 종류의 스토리지는 안정성과 확장이 가능하지만 비용이 더 높습니다. 여러분은 오래된 쓰레기를 저장함으로써 그것을 낭비하고 싶지 않을 수도 있다. 이는 운영 스토리지 및 관련된 것일 뿐만 아니라 백업도 고려해야 합니다. 기본 백업 솔루션이 있는 경우 캐시 디렉토리를 제외할 수 없습니다. 마지막으로 가비지 데이터도 백업하게 됩니다.

3. 더 나쁜 것은특정 이미지에 대한 사용 라이선스를 원하는 기간 동안만 구매했을 수 있습니다. 이제 라이선스가 만료된 후에도 이미지를 계속 저장한다면 저작권 침해로 볼 수 있습니다. 웹 페이지에 있는 이미지를 더 이상 사용하지 않을 수도 있습니다. 하지만 Google에서는 여전히 이미지를 찾을 수 있습니다.

그래서 마지막으로, 당신은 이 종류의 쓰레기 처리를 계속 할 수 있도록 1주일 이상 오래된 모든 파일을 청소하는 약간의 정리 작업을 할 것이다.

#### URL 지문을 서비스 거부 공격

그러나 이 해결에는 또 다른 결함이 있습니다.

선택기를 매개 변수로 사용하는 경우가 있습니다.fp-2018-31-12-23-59은 일종의 &quot;cache-killer&quot;로 동적으로 생성됩니다. 하지만 아마 몇몇 지루해 하는 아이(또는 난해한 검색 엔진 크롤러)가 페이지를 요청하기 시작할 것입니다.

```
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-00.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-01.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-02.jpg

…
```

각 요청은 디스패처를 무시하여 게시 인스턴스에 로드를 발생시킵니다. 또한 디스패처에 관련 파일을 만듭니다.

그래서... 단순한 캐시 킬러로 지문을 사용하는 대신 이미지의 jcr:lastModified 날짜를 확인하고 예상일이 아닌 경우 404를 반환해야 합니다. 게시 시스템에서 약간의 시간과 CPU 사이클이 소요되는데... 이것이 바로 처음에 예방하고자 했던 것입니다.

#### 고주파 릴리스의 URL 지문에 대한 주의

DAM에서 가져온 에셋뿐만 아니라 JS 및 CSS 파일 및 관련 리소스에 대해서도 핑핑 스키마를 사용할 수 있습니다.

[버전 ](https://adobe-consulting-services.github.io/acs-aem-commons/features/versioned-clientlibs/index.html) 관리된 클라이언트리비스는 이 방법을 사용하는 모듈입니다.

그러나 여기에서 여러분은 URL 지문을 가지고 있는 또 다른 원시적인 문제를 직면할 수 있습니다.URL을 컨텐츠에 연결합니다. 또한 URL을 변경하지 않으면 컨텐츠를 변경할 수 없습니다(또는. 수정 날짜를 업데이트). 이것이 바로 지문이 처음부터 고안된 것이다. 그러나 새로운 CSS 및 JS 파일과 새로운 URL을 사용하여 새로운 URL을 출시하는 것을 고려해 보십시오. 모든 HTML 페이지에는 여전히 이전 지문 URL에 대한 참조가 있습니다. 따라서 새로운 릴리스가 일관되게 작동하려면 모든 HTML 페이지를 한 번에 무효화해야 새로 지문을 인쇄한 파일에 대한 참조를 사용하여 다시 렌더링할 수 있습니다. 동일한 라이브러리에 의존하는 여러 사이트가 있는 경우 이는 상당한 양의 다시 렌더링될 수 있으며 여기서 `statfiles`을(를) 활용할 수 없습니다. 따라서 롤아웃 후 게시 시스템에서 로드 최고점을 볼 수 있도록 준비하십시오. 캐시 온난화와 함께 녹색 배치를 고려하고 있거나 Dispatcher 앞에서 TTL 기반 캐시를 사용하면 가능성은 무궁무진합니다.

#### 짧은 휴식

와 - 그것은 고려해야 할 많은 세부 사항들입니다, 그렇죠? 그리고 그것은 이해되고, 테스트되고, 쉽게 디버깅하기를 거부합니다. 이 모든 것이 외관상적으로 우아한 솔루션을 위한 것입니다. 인정하건대, 이것은 우아하지만 AEM 전용 관점에서만 가능하다. 디스패처와 함께 불쾌해져요

그리고 여전히 - 하나의 기본적인 경고를 해결하지 않으며, 이미지를 여러 페이지에서 여러 번 사용해도 해당 페이지 아래에 캐시됩니다. 시너지 효과는 별로 없다.

일반적으로 URL 지문은 툴킷에 포함하기에 좋은 도구이지만, 몇 가지 기존 문제를 해결하는 동시에 새로운 문제를 일으킬 수 있으므로 주의해서 적용해야 합니다.

그래서... 그건 긴 장. 그러나 우리는 이 패턴을 너무 자주 보았고, 우리는 당신에게 모든 장단점을 가지고 전체 상황을 보여줄 필요가 있다고 느꼈다. URL 지문은 스풀러 패턴에서 몇 가지 기본적인 문제를 해결하지만 구현하려는 노력이 매우 높으므로 다른 솔루션도 고려해야 합니다. Adobe는 URL을 제공된 리소스 경로를 기준으로 할 수 있고 중간 구성 요소가 없는지 항상 확인하는 것이 좋습니다. 우리는 다음 장에서 이것을 할 것이다.

##### 런타임 종속성 해결

런타임 종속성 해결은 하나의 프로젝트에서 생각해 온 개념입니다. 하지만 그것을 통해 생각하는 것은 꽤 복잡했고 우리는 그것을 시행하지 않기로 결정했다.

기본 아이디어는 다음과 같습니다.

Dispatcher는 리소스의 종속성에 대해 알지 못합니다. 단순한 의미 체계를 갖춘 하나의 파일일 뿐입니다.

AEM은 의존성에 대해서도 거의 알지 못한다. 그것은 적절한 의미론 또는 &quot;종속성 추적기&quot;가 없다.

AEM은 일부 참조를 알고 있습니다. 참조되는 페이지 또는 자산을 삭제하거나 이동할 때 이 지식을 사용하여 사용자에게 경고합니다. 자산을 삭제할 때 내부 검색을 쿼리하여 이렇게 됩니다. 컨텐츠 참조에는 매우 특별한 양식이 있습니다. &quot;/content&quot;로 시작하는 경로 표현식입니다. 따라서 전체 텍스트 색인을 쉽게 할 수 있으며 필요한 경우 쿼리할 수 있습니다.

이 경우 게시 시스템에 사용자 지정된 복제 에이전트가 있어야 하며 이 에이전트가 경로가 변경되면 특정 경로를 검색합니다.

이제

`/content/dam/flower.jpg`

게시 시 변경되었습니다. 에이전트가 &quot;/content/dam/flower.jpg&quot;에 대한 검색을 시작하고 해당 이미지를 참조하는 모든 페이지를 찾습니다.

그런 다음 디스패처에 여러 가지 무효화 요청을 발행할 수 있습니다. 자산이 포함된 각 페이지에 대해 하나씩.

이론적으로, 그것은 효과가 있을 것이다. 하지만 첫 번째 수준의 종속성에 대해서만 가능합니다. 페이지에 사용되는 경험 조각에서 이미지를 사용할 경우 다중 수준 종속성에 해당 체계를 적용하지 않으려는 경우가 있습니다. 사실, 우리는 접근 방식이 너무 복잡하며 런타임 문제가 있을 수 있다고 믿는다. 그리고 일반적으로 가장 좋은 조언은 이벤트 핸들러에서 값비싼 계산을 하지 않는 것이다. 그리고 특히 수색은 꽤 비용이 많이 들 수 있다.

##### 결론

구현에서 스풀러 패턴을 사용하고 사용하지 않을 시기를 결정할 수 있을 만큼 스풀러 패턴에 대해 충분히 논의했으면 합니다.

## 발송자 문제 방지

### 리소스 기반 URL

의존성 문제를 해결하기 위한 훨씬 더 세련된 방법은 종속성이 전혀 없는 것이다. 마지막 예에서처럼 한 리소스를 사용하여 다른 리소스를 간단하게 프록시할 때 발생하는 인위적인 종속성을 방지합니다. 리소스를 가능한 한 자주 &quot;독방&quot; 개체라고 보세요.

Adobe의 사례는 다음과 같이 쉽게 해결됩니다.

![구성 요소가 아니라 이미지에 바인딩된 서블릿으로 이미지를 스풀링합니다.](assets/chapter-1/spooling-image.png)

*구성 요소가 아니라 이미지에 바인딩된 서블릿으로 이미지를 스풀링합니다.*

<br> 

데이터를 렌더링하기 위해 자산 원래 리소스 경로를 사용합니다. 원본 이미지를 그대로 렌더링해야 하는 경우 자산에 AEM 기본 렌더러를 사용할 수 있습니다.

특정 구성 요소에 대해 특정 처리를 수행해야 하는 경우 해당 경로 및 선택기에 전용 서블릿을 등록하여 구성 요소를 대신하여 변환을 수행합니다. 우리는 여기서 &quot;.responsive&quot;로 모범적으로 그것을 했습니다. 선택기. 글로벌 URL 공간(예: `/content/dam`)에 사용되는 선택기 이름을 추적하고 이름 충돌을 방지할 수 있는 좋은 명명 규칙을 사용하는 것이 좋습니다.

그런데, 코드 일관성 문제가 전혀 없습니다. 서브렛은 구성 요소 슬링 모델과 동일한 Java 패키지에서 정의할 수 있습니다.

또한 글로벌 환경에서 다음과 같은 추가 선택기를 사용할 수도 있습니다.

`/content/dam/flower.respi.thumbnail.jpg`

진정해, 그렇지? 그러면 왜 스풀러처럼 복잡한 패턴을 생각하는가?

외부 구성 요소가 내부 리소스의 렌더링에 약간의 값이나 정보를 추가했기 때문에 내부 컨텐츠 참조를 피하는 문제를 해결할 수 있었습니다. 이는 외부 구성 요소가 외부 리소스의 표현을 제어하는 정적 선택기 집합으로 쉽게 인코딩될 수 있었기 때문입니다.

그러나 리소스 기반 URL로 쉽게 해결할 수 없는 경우가 한 가지 있습니다. 이러한 유형의 경우 &quot;Parameter Inferening Components&quot;라고 하며 다음 장에 이 구성 요소에 대해 설명합니다.

### 매개 변수 삽입 구성 요소

#### 개요

마지막 장에 있는 스풀러는 리소스 주위의 얇은 래퍼였습니다. 그것은 문제를 해결하는 데 도움을 주는 것보다 더 많은 문제를 일으켰다.

간단한 선택기를 사용하여 이러한 배치를 쉽게 대체하고 이러한 요청을 처리하기 위해 각 서블릿을 추가할 수 있습니다.

그러나 &quot;응답&quot; 구성 요소가 단순히 프록시 이상이면 어떻게 할 것인가. 구성 요소가 구성 요소의 렌더링에 진정으로 기여하는 경우 어떻게 합니까?

&quot;응답&quot; 구성 요소의 작은 확장을 소개하겠습니다. 매우 혁신적인 기능입니다. 다시 한번, 우리는 새로운 도전들을 해결하고 그들이 무엇이 부족한지 보여주는 몇몇의 솔직한 해결책을 먼저 소개할 것입니다.

#### Response2 구성 요소

response2 구성 요소는 응답형 이미지를 표시하는 구성 요소로서 응답 구성 요소입니다. 하지만 약간의 추가 기능이 있습니다

![CRX 구조:배달에 품질 속성을 추가하는 repi2 구성 요소](assets/chapter-1/respi2.png)

*CRX 구조:배달에 품질 속성을 추가하는 repi2 구성 요소*

<br> 

이미지는 jpeg이며 jpeg는 압축할 수 있습니다. jpeg 이미지를 압축할 때 파일 크기에 대한 품질과 바꾸게 됩니다. 압축은 &quot;1&quot;에서 &quot;100&quot;까지의 숫자 &quot;quality&quot; 매개 변수로 정의됩니다. &quot;1&quot;은 &quot;작지만 품질이 좋지 않다&quot;를 의미하며, &quot;100&quot;은 &quot;우수한 품질은 있지만 대용량 파일&quot;을 의미합니다. 그렇다면 어떤 것이 완벽한 가치가 있을까요?

모든 IT와 마찬가지로 대답은 다음과 같습니다.&quot;상황에 따라 다릅니다.&quot;

여기 모티브에 따라 다릅니다 텍스트, 건물의 사진, 일러스트레이션, 스케치 또는 제품 상자 사진(윤곽선이 선명하고 텍스트가 여기에 쓰여져 있음)과 같은 모티브가 풍부한 모티브가 있는 모티브는 보통 해당 카테고리로 분류됩니다. 풍경이나 초상화와 같은 부드러운 색상 및 대비 전환이 적용된 모티브는 품질을 그대로 유지하면서 약간 더 압축된 상태로 만들 수 있습니다. 자연 사진은 보통 그 범주에 속한다.

또한 - 이미지가 사용되는 위치에 따라 다른 매개 변수를 사용할 수도 있습니다. Teaser의 작은 축소판은 화면 전체 메인 배너에 사용된 것과 동일한 이미지보다 더 나은 압축을 견딜 수 있습니다. 즉, 품질 매개 변수는 이미지가 아니라 이미지 및 컨텍스트에 맞게 기본적으로 지정됩니다. 저자의 취향에 따라

간단히 말해:모든 사진에 완벽한 설정이 없습니다. 모든 것에 딱 맞는 것은 없다. 저자가 결정하는 것이 최선이다. 그는 &quot;quality&quot; 매개 변수를 품질에 만족할 때까지 구성 요소에서 속성으로 수정하고 대역폭을 희생하지 않도록 더 이상 이동하지 않습니다.

이제 DAM과 구성 요소에 품질 속성을 제공하는 이진 파일이 있습니다. URL은 어떻게 표시되어야 합니까? 스풀링하는 구성 요소는 무엇입니까?

#### 순진하게 접근 1:속성을 쿼리 매개 변수로 전달

>[!WARNING]
>
>이것은 반패턴입니다. 사용하지 마십시오.

마지막 장에서는 구성 요소에서 렌더링한 이미지 URL이 다음과 같이 표시되었습니다.

`/content/dam/flower.respi.jpg`

없는 것은 품질 값입니다. 구성 요소는 작성자가 입력한 속성을 알고 있습니다... 마크업을 렌더링할 때 다음과 같이 이미지 렌더링 서블릿에 쿼리 매개 변수로 쉽게 전달할 수 있습니다. `flower.respi2.jpg?quality=60`:

```plain
  <div class="respi2">
  <picture>
    <source src="/content/dam/flower.respi2.jpg?quality=60" …/>
    …
  </picture>
  </div>
  …
```

이건 잘못된 생각이에요 기억? 쿼리 매개 변수가 있는 요청은 액세스할 수 없습니다.

#### 간편한 접근 방식 2:추가 정보를 선택기로 전달

>[!WARNING]
>
>이것이 반패턴이 될 수도 있다. 주의해서 사용하십시오.

![구성 요소 속성을 선택기로 전달](assets/chapter-1/passing-component-properties.png)

*구성 요소 속성을 선택기로 전달*

<br> 

마지막 URL의 약간 변형입니다. 이번에는 선택기를 사용하여 결과를 취소할 수 있도록 속성을 서블릿으로 전달합니다.

`/content/dam/flower.respi.q-60.jpg`

이것은 훨씬 더 낫지만, 그런 패턴을 찾는 마지막 장의 지저분한 대본 어린 아이를 기억하는가? 그는 가치들에 대해 계속 반복되는 것을 얼마나 멀리 볼 수 있는지 볼 것입니다.

```plain
  /content/dam/flower.respi.q-60.jpg
  /content/dam/flower.respi.q-61.jpg
  /content/dam/flower.respi.q-62.jpg
  /content/dam/flower.respi.q-63.jpg
  …
```

다시 캐시를 무시하고 게시 시스템에서 로드를 만듭니다. 그래서, 그것은 나쁜 생각일지도 모릅니다. 작은 매개 변수 하위 집합만 필터링하여 이를 완화시킬 수 있습니다. `q-20, q-40, q-60, q-80, q-100`만 허용하려는 경우

#### 선택기를 사용할 때 잘못된 요청 필터링

선택기의 수를 줄이는 것이 좋은 시작이었다. 경험상 유효한 매개 변수의 수는 항상 절대 최소로 제한해야 합니다. 이 방법을 교묘하게 사용하는 경우 기본 AEM 시스템에 대한 깊은 지식이 없는 상태에서 정적 필터 세트를 사용하여 AEM 외부의 웹 애플리케이션 방화벽을 활용하여 시스템을 보호할 수 있습니다.

`Allow: /content/dam/(-\_/a-z0-9)+/(-\_a-z0-9)+
\.respi\.q-(20|40|60|80|100)\.jpg`

웹 응용 프로그램 방화벽이 없는 경우 디스패처 또는 AEM 자체에서 필터링해야 합니다. AEM에서 하시려면

1. 이 필터는 CRX에 너무 많이 액세스하거나 메모리와 시간을 허비하지 않고 매우 효율적으로 구현됩니다.

2. 필터는 &quot;404 - 찾을 수 없음&quot; 오류 메시지에 응답합니다.

마지막 점을 다시 강조합시다. HTTP 대화는 다음과 같습니다.

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 404 – Not found
  << empty response body >>
```

잘못된 매개 변수를 필터링했지만 잘못된 매개 변수를 사용할 때 올바른 폴백 렌더링을 반환한 구현도 확인되었습니다. 예를 들어 20-100의 매개 변수만 허용합니다. 사이에 있는 값은 유효한 값에 매핑됩니다. 그래서

`q-41, q-42, q-43, …`

는 q-40과 동일한 이미지에 항상 응답합니다.

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 200 – OK
  << flower.jpg with quality = 40 >>
```

그 방법은 전혀 도움이 되지 않는다. 이러한 요청은 실제로 유효한 요청입니다.  처리 능력을 사용하고 디스패처의 캐시 디렉토리에서 공간을 차지합니다.

`301 – Moved permanently`을(를) 반환하는 것이 좋습니다.

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 301 – Moved permanently
  Location: /content/dam/flower.respi.q-40.jpg
```

여기 AEM이 브라우저에게 말하고 있습니다. &quot;`q-41`이(가) 없습니다. 그런데, `q-40`&quot;에 대해 물어보세요.

이렇게 하면 대화에 요청 응답 루프가 추가되는데, 이것은 약간의 오버헤드이지만, `q-41`에서 전체 처리를 하는 것보다는 더 저렴합니다. 또한 이미 `q-40` 아래에 캐시된 파일을 활용할 수 있습니다. 하지만 302개의 응답이 디스패처에 캐시되지 않는다는 것을 이해해야 합니다. 우리는 AEM에서 실행되는 논리에 대해 이야기하고 있습니다. 계속해서 그래서 날씬하고 빨리 만드는 게 좋을 거야.

우리는 개인적으로 404가 가장 반응이 좋아요. 그것은 무슨 일이 일어나고 있는지 아주 분명하게 만든다. 로그 파일을 분석할 때 웹 사이트에서 오류를 탐지할 수 있습니다. 301은 404를 항상 분석 및 제거해야 하는 곳에서 의도될 수 있습니다.

## 보안 - 여행

### 요청 필터링

#### 최상의 필터링 위치

마지막 장의 끝에서 알려진 선택기에 대해 들어오는 트래픽을 필터링할 필요가 있다는 점을 설명했습니다. 그러면 다음과 같은 질문이 남습니다.요청을 실제로 필터링하려면 어디로 가야 합니까?

상황에 따라 다릅니다 빠를수록 좋다.

#### 웹 애플리케이션 방화벽

웹 보안용으로 설계된 웹 응용 프로그램 방화벽 기기 또는 &quot;WAF&quot; 가 있는 경우 이러한 기능을 반드시 활용해야 합니다. 그러나 WAF는 컨텐츠 애플리케이션에 대한 지식이 제한된 사람만 수행하고 유효한 요청을 필터링하거나 너무 많은 해로운 요청을 전달할 수 있다는 점을 알게 될 수도 있습니다. WAF를 운영하는 사람들이 서로 다른 교대근무 및 릴리스 일정이 있는 다른 부서에 배정되고, 커뮤니케이션이 다이렉트 팀원들과 같이 긴밀하지 않을 수도 있고, 시간이 지남에 따라 항상 변화를 얻지 못할 수도 있다는 점을 알게 될 것입니다. 즉, 결과적으로 여러분의 개발과 컨텐츠의 속도가 저하될 것입니다.

여러분의 직감에서 말하는 몇 가지 일반적인 규칙이나 심지어 차단 목록에 추가하다 심지어로 끝날 수도 있습니다.

#### 발송자 및 게시 필터링

다음 단계에서는 Apache 코어 및/또는 Dispatcher에서 URL 필터링 규칙을 추가합니다.

여기에서 URL에만 액세스할 수 있습니다. 패턴 기반 필터로 제한됩니다. 컨텐츠 기반 필터링을 설정해야 하거나(예: 올바른 타임스탬프로 파일만 허용), 필터링을 작성자에서 제어하려는 경우 - 사용자 정의 서블릿 필터와 같은 항목을 작성할 수 있습니다.

#### 모니터링 및 디버깅

실제로 각 수준에 몇 가지 보안이 있을 것입니다. 그러나 어떤 수준의 요청이 필터링되었는지 확인할 수 있는 방법이 있는지 확인하십시오. 체인의 어떤 필터가 요청을 차단하는지 확인하려면 게시 시스템, 디스패처 및 WAF의 로그 파일에 직접 액세스할 수 있어야 합니다.

### 선택기 및 선택기 확산

마지막 장에서 &quot;selector-parameters&quot;를 사용하는 접근 방식은 빠르고 간단하며 새 구성 요소의 개발 시간을 단축할 수 있지만 제한이 있습니다.

&quot;quality&quot; 속성을 설정하는 것은 간단한 예일 뿐입니다. 그러나 이 서블릿은 &quot;width&quot;에 대한 매개 변수가 보다 융통성이 있다고 가정해 봅시다.

가능한 선택기 값 수를 줄여 유효한 URL 수를 줄일 수 있습니다. 폭도 다음과 같이 할 수 있습니다.

quality = q-20, q-40, q-60, q-80, q-100

너비 = w-100, w-200, w-400, w-800, w-1000, w-1200

그러나 이제 모든 조합이 유효한 URL입니다.

```
/content/dam/flower.respi.q-40.w-200.jpg
/content/dam/flower.respi.q-60.w-400.jpg
…
```

이제 하나의 리소스에 대해 5x6=30개의 유효한 URL이 이미 있습니다. 각 추가 속성은 복잡성에 추가됩니다. 그리고 합당한 수준의 값으로 줄일 수 없는 재산이 있을 수도 있습니다.

그래서, 이 접근법은 한계가 있습니다.

#### 의도치 않게 API 노출

여기서 무슨 일이 일어나고 있습니까? 자세히 살펴보면, 정적으로 렌더링된 웹 사이트에서 매우 동적인 웹 사이트로 서서히 이동하고 있다는 것을 알 수 있습니다. 그리고 이미지 렌더링 API를 작성자에게만 실제로 사용하도록 만들어진 고객 브라우저에 잘못 표시하고 있습니다.

이미지의 품질과 크기 설정은 작성자가 페이지를 편집하는 방식으로 해야 합니다. 서브렛에 의해 동일한 기능을 노출하는 것은 서비스 거부(DoS) 공격에 대한 기능이나 벡터로 보일 수 있습니다. 사실 그것은 상황에 따라 다릅니다. 웹 사이트는 비즈니스에 얼마나 중요한 역할을 합니까? 서버에 있는 로드는 얼마입니까? 머리방은 얼마나 남았나요? 구현 비용은 얼마나 됩니까? 이러한 요인들을 균형 있게 조정해야 한다. 장단점을 알아야 한다.

## 스풀러 패턴 - 재방문 및 재활

### 스풀러가 API 노출 방지 방법

마지막 장에서 스풀러 패턴을 의심했어 그것을 회복시킬 시간이다.

![](assets/chapter-1/spooler-pattern.png)

스풀러 패턴은 마지막 장에서 설명한 API를 노출하는 문제를 방지합니다. 속성은 구성 요소에 저장되고 캡슐화됩니다. 이러한 속성에 액세스하면 구성 요소의 경로가 됩니다. 마크업과 이진 렌더링 간에 매개 변수를 전송하기 위해 URL을 도구로 사용할 필요는 없습니다.

1. 클라이언트는 구성 요소가 기본 요청 루프 내에서 요청되면 HTML 마크업을 렌더링합니다.

2. 구성 요소 경로는 구성 요소에 대한 마크업에서 역참조 역할을 합니다.

3. 브라우저는 이 역참조를 사용하여 이진 파일을 요청합니다

4. 요청이 구성 요소에 도달하면 이진 데이터의 크기 조정, 압축 및 스풀링을 위해 모든 속성이 손에 있습니다

5. 이미지는 구성 요소를 통해 클라이언트 브라우저로 전송됩니다.

스풀러 패턴은 결국 그렇게 나쁘진 않아, 그래서 그것이 인기 있는 거야. 캐시 무효화에만 있어서 그렇게 번거롭지 않다면..

### 반전된 스풀러 - 두 세계에서 최고인가?

그것은 우리에게 문제를 야기한다. 왜 우리는 양쪽의 장점을 얻을 수 없을까요? 스풀러 패턴의 캡슐화와 리소스 기반 URL의 멋진 캐싱 속성이 적절합니까?

우리는 우리가 실제 실물 프로젝트에서 그것을 보지 못했다는 것을 인정해야 합니다. 그러나 우리가 여러분 자신의 해결책의 시작점으로 여기있는 작은 생각들을 실험해 볼 수 있도록 합시다.

이 패턴을 _반전된 스풀러_&#x200B;라고 합니다. 반전된 스풀러는 모든 멋진 캐시 무효화 속성을 가지려면 이미지 리소스를 기반으로 해야 합니다.

그러나 매개 변수를 노출해서는 안 됩니다. 모든 속성은 구성 요소에 캡슐화되어야 합니다. 하지만 구성 요소 경로를 속성에 불투명한 참조로 표시할 수 있습니다.

그러면 양식의 URL이 표시됩니다.

`/content/dam/flower.respi3.content-mysite-home-jcrcontent-par-respi.jpg`

`/content/dam/flower` 은 이미지의 리소스 경로입니다.

`.respi3` 이미지를 전달하는 올바른 서블릿을 선택하는 선택기입니다.

`.content-mysite-home-jcrcontent-par-respi` 는 추가 선택기입니다. 이미지 변환에 필요한 속성을 저장하는 구성 요소 경로를 인코딩합니다. 선택기는 패스보다 문자 범위가 더 작은 것으로 제한됩니다. 여기서 인코딩 체계는 정말 훌륭합니다. &quot;/&quot;를 &quot;-&quot;로 대체합니다. 경로 자체도 &quot;-&quot;를 포함할 수 있다는 것은 고려하지 않습니다. 좀 더 정교한 인코딩 체계를 실제의 예에서 볼 수 있다. Base64는 괜찮을 것입니다. 하지만 디버깅을 보다 어렵게 만듭니다.

`.jpg` 파일 접미어임

### 결론

스풀러에 대한 논의가 예상보다 더 길고 복잡해졌습니다. 우리는 너에게 변명을 할 의무가 있다. 그러나 우리는 여러분에게 좋은 것과 나쁜 것의 다양한 측면을 보여줄 필요가 있다고 느꼈습니다. 그래서 여러분은 디스패처 땅에서 잘 작동하는 것과 그렇지 않은 것에 대해 직관적으로 발전시킬 수 있습니다.

## 상태 파일 및 상태 파일 레벨

### 기본 사항

#### 소개

전에 _stfile_&#x200B;에 대해 이미 간단히 언급했습니다. 자동 무효화와 관련이 있습니다.

자동 무효화되도록 구성된 Dispatcher의 파일 시스템에 있는 모든 캐시 파일은 마지막으로 수정한 날짜가 `statfile's` 마지막 수정 날짜보다 오래된 경우 유효하지 않은 것으로 간주됩니다.

>[!NOTE]
>
>마지막으로 수정한 날짜는 캐시된 파일이 클라이언트의 브라우저에서 파일을 요청하고 파일 시스템에서 생성된 날짜입니다. 리소스의 `jcr:lastModified` 날짜가 아닙니다.

상태 파일(`.stat`)의 마지막 수정 날짜는 디스패처에서 AEM의 무효화 요청을 받은 날짜입니다.

Dispatcher가 두 개 이상이면 이상한 효과를 만들 수 있습니다. 브라우저에 Dispatcher의 최신 버전이 있을 수 있습니다(둘 이상의 Dispatcher가 있는 경우). 또는 Dispatcher는 다른 Dispatcher에서 발행한 브라우저의 버전이 오래되고 불필요하게 새 사본을 보내는 것으로 생각할 수 있습니다. 이러한 효과는 성능 또는 기능 요구 사항에 크게 영향을 주지 않습니다. 브라우저에 최신 버전이 있을 때 시간이 지남에 따라 시간이 지남에 따라 표시됩니다. 그러나 브라우저 캐싱 비헤이비어를 최적화하고 디버깅하는 경우 약간 혼동될 수 있습니다. 주의하십시오.

#### /statfileslevel을 사용하여 무효화 도메인 설정

자동 무효화를 도입하고 명령문을 열면 *모든* 파일이 변경이 있을 때 유효하지 않은 것으로 간주되며 모든 파일이 상호 종속되어 있다고 합니다.

그건 정확하지 않아요 일반적으로 공통 기본 탐색 루트를 공유하는 모든 파일은 상호 종속적입니다. 그러나 한 AEM 인스턴스는 많은 웹 사이트(*독립적인* 웹 사이트)를 호스팅할 수 있습니다. 일반적인 탐색이 공유되지 않음 - 사실상 아무것도 공유하지 않음.

A사이트에 변화가 있어서 B사이트를 무효화하는 것은 낭비되지 않을까요? 네, 그렇습니다. 그렇게 될 필요는 없습니다.

Dispatcher에서는 사이트를 서로 구분하는 간단한 방법을 제공합니다.`statfiles-level`.

이 값은 파일 시스템의 레벨(&quot;독립&quot; 하위 트리)을 정의하는 숫자입니다.

상태 파일 수준이 0인 기본 사례를 살펴보겠습니다.

![/statfileslevel &quot;0&quot;:_. _stat_ _is가 doroot에 만들어집니다. 무효화 도메인은 모든 사이트](assets/chapter-1/statfile-level-0.png)를 포함하여 전체 설치 전체에 걸쳐 있습니다.

`/statfileslevel "0":` 파일 `.stat` 이 doroot에 만들어집니다. 무효화 도메인은 모든 사이트를 포함하여 전체 설치 전체에 적용됩니다.

무효화된 파일 중에서 디스패처 문서 루트 맨 위에 있는 `.stat` 파일은 항상 업데이트됩니다. 따라서 `/content/site-b/home`을(를) 무효화하면 이제 문서 루트의 `.stat` 파일보다 더 오래된 `/content/site-a`에 있는 모든 파일도 무효화됩니다. `site-b`을(를) 무효화할 때 필요한 것은 분명히 아닙니다.

이 예제에서는 `statfileslevel`을 `1`으로 설정하는 것이 좋습니다.

이제 게시하고 `/content/site-b/home` 또는 `/content/site-b` 아래의 다른 리소스를 무효화하면 `.stat` 파일이 `/content/site-b/`에 생성됩니다.

`/content/site-a/` 아래의 콘텐츠는 영향을 받지 않습니다. 이 콘텐트는 `/content/site-a/`의 `.stat` 파일과 비교됩니다. 두 개의 개별 무효화 도메인을 만들었습니다.

![상태 파일 레벨 &quot;1&quot;은 서로 다른 무효화 도메인을 만듭니다.](assets/chapter-1/statfiles-level-1.png)

*상태 파일 레벨 &quot;1&quot;은 서로 다른 무효화 도메인을 만듭니다.*

<br> 

대개의 설치는 일반적으로 좀 더 복잡하고 더 깊이 구조화되어 있습니다. 공통된 계획은 사이트 구조를 브랜드, 국가 및 언어별로 구성하는 것이다. 이 경우 상태 파일 수준을 더 높게 설정할 수 있습니다. _1_ 는 브랜드당 무효화 도메인, 국가당  _2_ 개 및  _언어당 3개_ 를 만듭니다.

### 균질부지의 필요성

상태 파일 수준은 설정의 모든 사이트에 동일하게 적용됩니다. 따라서 모든 사이트가 동일한 구조를 따르고 동일한 수준에서 시작해야 합니다.

포트폴리오에 몇 개의 작은 시장에서만 판매되는 일부 브랜드를 보유하고 있으며 다른 브랜드도 전 세계적으로 판매되고 있습니다. 소규모 시장은 세계 시장에 둘 이상의 언어를 말하는 나라들이 있는 동안 단지 하나의 현지어를 가지고 있는 것입니다.

```plain
  /content/tiny-local-brand/finland/home
  /content/tiny-local-brand/finland/products
  /content/tiny-local-brand/finland/about
                              ^
                          /statfileslevel "2"
  …

  /content/tiny-local-brand/norway
  …

  /content/shiny-global-brand/canada/en
  /content/shiny-global-brand/canada/fr
  /content/shiny-global-brand/switzerland/fr
  /content/shiny-global-brand/switzerland/de
  /content/shiny-global-brand/switzerland/it
                                          ^
                                /statfileslevel "3"
  ..
```

이전 항목에는 _2_&#x200B;의 `statfileslevel`이 필요한 반면, 후자는 _3_&#x200B;이 필요합니다.

이상적 상황이 아닙니다. _3_&#x200B;으로 설정하면 자동 무효화는 하위 분기 `/home`, `/products` 및 `/about` 사이의 작은 사이트 내에서 작동하지 않습니다.

_2_&#x200B;로 설정하면 큰 사이트에서 `/canada/en` 및 `/canada/fr` 종속적 사이트를 선언합니다. 이 이름은 그렇지 않을 수 있습니다. 따라서 `/en`의 각 무효화는 `/fr`도 무효화됩니다. 이렇게 하면 캐시 히트 비율이 약간 감소하지만 오래된 캐시된 컨텐츠를 제공하는 것보다는 그래도 더 좋습니다.

물론 가장 좋은 해결책은 모든 사이트의 뿌리를 똑같이 깊게 하는 것이다.

```
/content/tiny-local-brand/finland/fi/home
/content/tiny-local-brand/finland/fi/products
/content/tiny-local-brand/finland/fi/about
…
/content/tiny-local-brand/norway/no/home
                                 ^
                        /statfileslevel "3"
```

### 사이트 간 연결

이제 어느 정도가 적당합니까? 사이트 간 종속성 수에 따라 다릅니다. 페이지 렌더링에 대해 확인하는 포함은 &quot;하드 종속성&quot;으로 간주됩니다. 이 안내서의 시작 부분에 _Teaser_ 구성 요소를 소개했을 때 이러한 _포함_&#x200B;을 시연했습니다.

_하이퍼링크_ 는 더 부드러운 종속성 형태입니다. 하나의 웹 사이트 내에서 하이퍼링크가 만들어집니다... 웹 사이트 간에 링크가 있을 가능성은 거의 없습니다. [단순 하이퍼링크]는 일반적으로 웹 사이트 간 종속성을 만들지 않습니다. 사이트에서 facebook으로 설정한 외부 링크를 생각해 보십시오.facebook에서 변경 사항이 있거나 그 반대로 변경되면 페이지를 렌더링하지 않아도 됩니다. 그렇죠?

연결된 리소스에서 컨텐츠를 읽을 때 종속성이 발생합니다(예: 탐색 제목). 이러한 종속성은 로컬에 입력된 탐색 제목을 사용하고 대상 페이지에서 가져오지 않는 경우(외부 링크에서와 마찬가지로) 피할 수 있습니다.

#### 예기치 않은 종속성

하지만, 귀하의 설정의 일부가 있을 수 있으며, 여기에서 - 독립적으로 - 사이트가 함께 결합될 수 있습니다. 우리의 프로젝트 중 하나에서 우리가 우연히 얻은 실세계의 시나리오를 봅시다.

고객은 마지막 장에 스케치한 것과 같은 사이트 구조를 가지고 있었습니다.

```
/content/brand/country/language
```

예,

```
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de

/content/shiny-brand/france/fr

/content/shiny-brand/germany/de
```

각 나라마다 고유의 영역이 있고

```
www.shiny-brand.ch

www.shiny-brand.fr

www.shiny-brand.de
```

언어 사이트 간에 탐색 가능한 링크와 명확한 포함이 없으므로 상태 파일 수준을 3으로 설정합니다.

모든 사이트는 기본적으로 동일한 컨텐츠를 제공했습니다. 유일한 큰 차이는 언어였다.

Google과 같은 검색 엔진은 서로 다른 URL에 동일한 컨텐츠를 &quot;기만적&quot;으로 간주합니다. 사용자는 동일한 컨텐츠를 제공하는 팜스를 만들어 순위가 더 높거나 더 자주 오르도록 할 수 있습니다. 검색 엔진은 이러한 시도를 인식하고 단순히 컨텐츠를 재활용하는 페이지의 등급을 낮춥니다.

각 페이지의 머리글 섹션에 있는 각 관련 페이지에 `<link rel="alternate">` 태그를 설정하여 둘 이상의 페이지가 있고, 실제로 동일한 컨텐츠가 있는 페이지가 두 개 이상 있고, 시스템을 &quot;게임&quot;하려고 시도하지 않는 경우([&quot;Google에 페이지의 현지화된 버전에 대해 알림&quot;](https://support.google.com/webmasters/answer/189077?hl=en) 참조):

```
# URL: www.shiny-brand.fr/fr/home/produits.html

<head>

  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch" 
        href="http://www.shiny-brand.ch/de/home/produkte.html">
  <link rel="alternate" 
        hreflang="de-de" 
        href="http://www.shiny-brand.de/de/home/produkte.html">

</head>

----

# URL www.shiny-brand.de/de/home/produkte.html

<head>

  <link rel="alternate" 
        hreflang="fr-fr" 
        href="http://www.shiny-brand.fr/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch"
         href="http://www.shiny-brand.ch/de/home/produits.html">

</head>
```

![모든 링크 간 연결](assets/chapter-1/inter-linking-all.png)

*모든 링크 간 연결*

<br> 

일부 SEO 전문가들은 이것이 명성을 다른 언어로 순위가 높은 웹 사이트에서 동일한 웹 사이트로 다른 언어로 전송할 수 있다고 주장한다.

이 구성표는 여러 링크뿐만 아니라 일부 문제를 만들었습니다. _n_ 언어의 _p_&#x200B;에 필요한 링크의 수는 _p x(n<sup>2</sup>-n)_&#x200B;입니다.각 페이지는 (_-n_)을 제외하고 서로 다른 페이지(_n x_)로 링크됩니다. 이 스키마는 각 페이지에 적용됩니다. 20개의 페이지가 있는 4개 언어로 된 작은 사이트가 있는 경우 각각 _240_ 링크에 해당합니다.

먼저 편집자가 이러한 링크를 수동으로 유지 관리할 필요가 없습니다. 이러한 링크는 시스템에서 자동으로 생성됩니다.

둘째, 정확해야 한다. 시스템에서 새로운 &quot;상대&quot;를 감지할 때마다 동일한 컨텐츠가 있는 다른 모든 페이지에서 연결할 수 있습니다(다른 언어로).

저희 프로젝트에서는 새로운 관련 페이지가 자주 등장했습니다. 그러나 그들은 &quot;대체&quot; 링크로 구현되지 않았다. 예를 들어, `de-de/produkte` 페이지가 독일 웹 사이트에 게시되었을 때 다른 사이트에 즉시 표시되지 않았습니다.

그 이유는, 우리가 세운 곳에서 그 사이트들은 독립적이어야 했기 때문이다. 그래서 독일 웹 사이트의 변화가 프랑스 웹사이트에 무효화를 유발하지는 않았다.

당신은 이미 그 문제를 해결하는 방법을 알고 있다. 무효화 도메인을 확대하려면 상태 파일 수준을 2로 줄이기만 하면 됩니다. 물론 이는 캐시 적중 비율(특히 출판물이 있을 때)도 감소하여 폐기가 더 자주 발생합니다.

우리의 경우에는 훨씬 더 복잡했다:

비록 우리가 같은 내용을 가지고 있었지만, 실제 브랜드 이름은 각 국가에서 달랐다.

`shiny-brand` 이 `marque-brillant` 는 프랑스와 독일 `blitzmarke` 에서 호출되었습니다.

```
/content/marque-brillant/france/fr
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de
/content/blitzmarke/germany/de
…
```

이 값은 `statfiles` 수준을 1로 설정하려고 했습니다. 이 경우 무효화 도메인이 너무 클 수 있습니다.

현장을 재조정하면 그 문제가 수정되었을 것이다. 하나의 공통 루트로 모든 브랜드를 병합합니다. 그러나 우리는 그 때 그 능력을 가지고 있지 않았고, 그것은 우리에게 단지 2단계만 주어졌을 것입니다.

우리는 3등급을 고수하기로 결정했고 항상 최신 &quot;대체&quot; 링크가 없는 가격을 지불했다. 이를 줄이기 위해 Dispatcher에서 &quot;reaper&quot; cron-job이 실행되어 적어도 1주가 넘는 파일을 정리할 수 있었습니다. 결국 모든 페이지가 어느 시점에서든 다시 렌더링되었습니다. 그러나 그것은 각각의 프로젝트에서 개별적으로 결정되어야 할 필요가 있습니다.

## 결론

우리는 Dispatcher가 어떻게 일반적으로 작업하는지에 대한 몇 가지 기본 원칙을 다루었고 우리는 당신이 그것을 올바르게 하기 위해 좀 더 많은 구현 노력을 해야 할 그리고 당신이 그것을 옳게 하기 위해 어디에 당신이 그것을 하기를 원할 지에 관한 몇 가지 예를 당신에게 주었습니다.

Dispatcher에 구성된 방식에 대한 세부 사항은 언급하지 않았습니다. Adobe는 사용자가 너무 일찍 콘솔 작업을 시작할 때까지 기본적인 개념과 문제를 먼저 파악하고자 했습니다. 그리고 - 실제 구성 작업은 문서화되어 있습니다. 기본 개념을 이해하면 다양한 스위치가 어떤 용도로 사용되는지 알아야 합니다.

## 발송자 팁 및 트릭

이 책의 첫 부분은 어떤 상황에서든 유용할 수 있는 힌트와 트릭의 무작위로 정리될 것이다. 우리가 전에 했던 것처럼, 우리는 해결책을 제시하고 있지 않지만, 여러분이 아이디어와 개념을 이해할 수 있는 기회를 얻고 실제 구성을 더 자세히 설명하는 집필에 링크할 수 있도록 그 아이디어를 제시합니다.

### 정확한 무효화 시간

AEM 작성자 및 게시를 즉시 설치하는 경우 토폴로지는 약간 이상합니다. 작성자는 컨텐츠를 게시 시스템으로 보내고 동시에 디스패처에게 무효화 요청을 보냅니다. 마찬가지로 게시 시스템과 디스패처가 작성자에서 대기열별로 분리되어 있을 때 타이밍을 다소 유감스럽게 볼 수 있습니다. Dispatcher는 컨텐츠가 게시 시스템에서 업데이트되기 전에 작성자로부터 무효화 요청을 받을 수 있습니다.

클라이언트가 그 동안 해당 컨텐츠를 요청하면 디스패처는 부실 컨텐츠를 요청하고 저장합니다.

더 적절한 설정이 내용을 받은 후 게시 시스템 _에 있는 무효화 요청을 보냅니다._ 문서 &quot;[게시 인스턴스](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)&quot;에서 발송자 캐시를 무효화합니다.

**참조**

[helpx.adobe.com - 게시 인스턴스에서 발송자 캐시를 무효화합니다.](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)

### HTTP 헤더 및 헤더 캐싱

옛날에는 디스패처는 일반 파일을 파일 시스템에 저장하고 있었다. 고객에게 HTTP 헤더를 전달해야 하는 경우, 파일 또는 위치에서 얻은 작은 정보를 기반으로 Apache를 구성하여 합니다. AEM에서 HTTP 헤더를 많이 의존하는 웹 애플리케이션을 구현할 때 특히 불쾌했습니다. AEM 전용 인스턴스에서는 모든 것이 잘 작동하지만 디스패처를 사용할 때는 문제가 없습니다.

일반적으로 리소스 경로와 접미어로 파생할 수 있는 정보를 사용하여 Apache 서버의 리소스에 누락된 헤더를 `mod_headers`으로 다시 적용하기 시작했습니다. 그러나 이것만으로는 충분하지 않았다.

특히 디스패처가 브라우저에서의 첫 번째 _캐시되지 않은_ 응답을 모든 범위의 헤더가 있는 게시 시스템에서 가져온 반면, 후속 응답은 제한된 헤더 세트와 함께 디스패처가 생성했습니다.

Dispatcher 4.1.11 버전부터는 게시 시스템에서 생성된 헤더를 저장할 수 있습니다.

이를 통해 Dispatcher에서 헤더 로직을 중복하지 않고 HTTP 및 AEM의 풍부한 기능을 완벽하게 구현할 수 있습니다.

**참조**

* [helpx.adobe.com - 응답 헤더 캐싱](https://helpx.adobe.com/experience-manager/kb/dispatcher-cache-response-headers.html)

### 개인 캐싱 예외

일반적으로 모든 페이지와 이미지를 캐시할 수 있지만 일부 경우에는 예외로 합니다. 예를 들어, PNG 이미지를 캐시하지만 Captcha를 표시하는 PNG 이미지는 캐시하지 않습니다(각 요청에 따라 변경되어야 한다고 가정함). Dispatcher는 Captcha를 Captcha로 인식하지 못할 수 있지만 AEM은 확실히 마찬가지입니다. 응답과 함께 각 헤더를 전송하여 디스패처가 해당 요청을 캐시하지 않도록 요청할 수 있습니다.

```plain
  response.setHeader("Dispatcher", "no-cache");

  response.setHeader("Cache-Control: no-cache");

  response.setHeader("Cache-Control: private");

  response.setHeader("Pragma: no-cache");
```

캐시-제어 및 실용성은 CDN과 같은 상위 캐싱 레이어로 전파되고 해석되는 공식 HTTP 헤더입니다. `Dispatcher` 헤더는 Dispatcher가 캐시하지 않도록 하는 힌트일 뿐입니다. Dispatcher에게 캐시하지 않도록 하면서 여전히 상위 캐싱 레이어가 캐시하도록 하는 데 사용할 수 있습니다. 사실, 그것이 유용할 수 있는 사례를 찾기는 어렵다. 하지만 우리는 어딘가에 몇 가지가 있다는 것을 확신합니다.

**참조**

* [Dispatcher - 캐시 없음](https://helpx.adobe.com/experience-manager/kb/DispatcherNoCache.html)

### 브라우저 캐싱

가장 빠른 http-response는 브라우저 자체에서 제공하는 응답입니다. 요청과 응답이 높은 부하의 웹 서버로 네트워크를 통해 이동할 필요가 없는 경우.

리소스에 대한 만료 날짜를 설정하여 브라우저에서 서버에 새 버전의 파일을 요청할 시기를 결정하는 데 도움이 될 수 있습니다.

일반적으로 Apache의 `mod_expires`을 사용하거나 좀 더 개별적인 제어가 필요할 경우 AEM에서 가져오는 캐시-제어 및 만료 헤더를 저장하여 정적으로 수행합니다.

브라우저에 캐싱된 문서는 3가지 수준의 최신 문서를 가질 수 있습니다.

1. _새 문서_  보장 - 브라우저는 캐시된 문서를 사용할 수 있습니다.

2. _부실_  가능성이 있음 - 캐시된 문서가 최신 상태인지 브라우저가 먼저 서버에 물어봐야 합니다.

3. _오래된_  버전 - 브라우저가 서버에 새 버전을 요청해야 합니다.

첫 번째 값은 서버에서 설정한 만료 날짜로 보장됩니다. 리소스가 만료되지 않은 경우 서버에 다시 요청할 필요가 없습니다.

문서가 만료일에 도달한 경우에도 새로 만들 수 있습니다. 만료 날짜는 문서가 배달될 때 설정됩니다. 그러나 종종 새로운 컨텐츠를 사용할 수 있는 시기를 미리 알지 못하는 경우가 있으므로 이는 보수적인 예측입니다.

브라우저 캐시에 있는 문서가 새 요청에 배달될 문서와 동일한지 확인하기 위해 브라우저는 문서의 `Last-Modified` 날짜를 사용할 수 있습니다. 브라우저가 서버에 다음 사항을 묻습니다.

&quot;_6월 10일부터 버전이 있습니다.. 업데이트가 필요합니까?_&quot; 서버가

&quot;_304 - 리소스를 다시 전송하지 않고 버전이 아직_&quot; 최신 버전이거나 서버에서

&quot;_200 - HTTP 헤더에 있는 최신 버전_&quot;과 HTTP 본문에 있는 실제 최신 내용이 있습니다.

두 번째 부분이 작동하려면 업데이트를 요청할 참조 지점이 있도록 `Last-Modified` 날짜를 브라우저로 전송해야 합니다.

앞서 설명했듯이 `Last-Modified` 날짜가 디스패처에 의해 생성된 경우, 캐시된 파일과 날짜의 파일이 브라우저에서 파일을 요청할 때 생성되므로 다른 요청에 따라 달라질 수 있습니다. &quot;e-tags&quot;를 사용할 수도 있습니다. 이 숫자는 날짜 대신 실제 컨텐트(예: 해시 코드 생성)를 식별하는 숫자입니다.

&quot;_ACS 커머스 패키지_&#x200B;의 [태그 지원](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)&quot;은 이 방법을 사용합니다. 그러나 다음과 같은 비용이 발생합니다.E-Tag를 헤더로 전송해야 하지만, 해시 코드를 계산하려면 응답을 완전히 읽어야 하므로, 응답을 배달하기 전에 기본 메모리에서 완전히 버퍼링되어야 합니다. 이 기능은 웹 사이트에 캐시되지 않은 리소스가 있을 가능성이 높으며 AEM 시스템에서 사용하는 메모리를 추적해야 하는 경우 지연에 부정적인 영향을 미칠 수 있습니다.

URL 지문을 사용하는 경우 매우 긴 만료 날짜를 설정할 수 있습니다. 브라우저에서 지문과 같은 리소스를 영구적으로 캐시할 수 있습니다. 새 버전은 새 URL로 표시되며 이전 버전은 업데이트할 필요가 없습니다.

스풀러 패턴을 소개할 때 URL 지문을 사용했어요 `/etc/design`(CSS, JS)에서 나오는 정적 파일은 거의 변경되지 않으며 지문으로 사용할 수 있는 좋은 후보자도 됩니다.

일반 파일의 경우 일반적으로 30분마다 HTML을 다시 확인하고 4시간마다 이미지 등 고정 체계를 설정합니다.

브라우저 캐싱은 작성자 시스템에서 매우 유용합니다. 편집 환경을 개선하기 위해 브라우저에서 가능한 한 많이 캐시하려고 합니다. 그러나 가장 비싼 자산인 HTML 페이지는 캐시될 수 없습니다. 작성자에서 자주 변경되어야 합니다.

AEM UI로 구성된 화강암 라이브러리는 상당 시간 동안 캐시될 수 있습니다. 또한 브라우저에서 사이트 정적 파일(글꼴, CSS 및 JavaScript)을 캐시할 수도 있습니다. `/content/dam`의 이미지도 페이지에 있는 텍스트 복사처럼 자주 변경되지 않으므로 보통 약 15분 동안 캐시될 수 있습니다. 이미지는 AEM에서 대화형으로 편집되지 않습니다. AEM에 업로드되기 전에 먼저 편집하고 승인됩니다. 따라서 텍스트 만큼 자주 변경되지 않는다고 가정할 수 있습니다.

UI 파일을 캐싱하면 편집 모드에 있을 때 사이트 라이브러리 파일 및 이미지를 사용하여 페이지를 다시 로드할 때 속도가 크게 향상됩니다.



**참조**

*[developer.mozilla.org - 캐싱](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)

* [apache.org - 수정 만료](https://httpd.apache.org/docs/current/mod/mod_expires.html)

* [ACS 공유물 - 태그 지원](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)

### URL 자르기

리소스는

`/content/brand/country/language/…`

하지만 물론 고객에게 표시하려는 URL은 아닙니다. 미세, 가독성 및 SEO 이유로 도메인 이름에 이미 표시된 부분을 잘라낼 수 있습니다.

도메인이 있는 경우

`www.shiny-brand.fi`

보통 브랜드와 국가를 그 길로 갈 필요가 없다. 대신

`www.shiny-brand.fi/content/shiny-brand/finland/fi/home.html`

당신이 원하는건

`www.shiny-brand.fi/home.html`

AEM은 잘린 형식에 따라 링크를 렌더링하는 방법을 알아야 하기 때문에 AEM에서 해당 매핑을 구현해야 합니다.

그러나 AEM에만 의존하지 마십시오. 이 경우 캐시의 루트 디렉토리에 `/home.html` 같은 경로가 있습니다. 지금, 그것이 마니스트나 독일어 혹은 캐나다 웹사이트의 &quot;홈&quot; 입니까? 그리고 Dispatcher에 `/home.html` 파일이 있는 경우 Dispatcher는 `/content/brand/fi/fi/home`에 대한 무효화 요청이 들어올 때 이 파일을 무효화해야 한다는 것을 어떻게 알 수 있습니까?

각 도메인에 대해 별도의 docroot가 있는 프로젝트를 보았습니다. 디버깅하고 유지 관리하는 것은 악몽이었고 완벽하게 작동하는 것을 전혀 보지 못했습니다.

캐시를 다시 만들어 문제를 해결할 수 있어요 모든 도메인에 대한 단일 docroot가 있고 서버의 모든 파일이 `/content`으로 시작되므로 무효화 요청을 1:1로 처리할 수 있습니다.

자르는 부분도 매우 쉽다.  AEM에서 `/etc/map`의 구성에 따라 잘린 링크를 생성했습니다.

이제 요청 `/home.html`이 디스패처를 강타할 때, 발생하는 첫 번째 일은 내부적으로 경로를 확장하는 다시 작성 규칙을 적용하는 것입니다.

이 규칙은 각 호스트 구성에서 정적으로 설정되었습니다. 간단히 말해서, 규칙들은 이렇게 보였고

```plain
  # vhost www.shiny-brand.fi

  RewriteRule "^(.\*\.html)" "/content/shiny-brand/finland/fi/$1"
```

이제 파일 시스템에는 작성자 및 게시에도 있는 일반 `/content` 기반 경로가 있으며 이는 많은 디버깅에 도움이 됩니다. 정확한 무효화는 말할 것도 없고 더 이상 문제가 되지 않았다.

참고, &quot;표시&quot; URL, 브라우저의 URL 슬롯에 표시되는 URL에만 적용되었습니다. 예를 들어 이미지의 URL은 여전히 순수 &quot;/content&quot; URL이었습니다. 검색 엔진 최적화 측면에서는 &quot;기본&quot; URL을 미화하면 충분합니다.

하나의 일반적인 문서를 갖는 것은 또 다른 좋은 특징도 가지고 있었다. Dispatcher에서 문제가 발생하면, 실행,

`rm -rf /cache/dispatcher/*`

(높은 로드 최고점에서 원하지 않을 수 있는 것)

**참조**

* [apache.org - 수정 다시 작성](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)

* [helpx.adobe.com - 리소스 매핑](https://helpx.adobe.com/experience-manager/6-4/sites/deploying/using/resource-mapping.html)

### 오류 처리

AEM 클래스에서 Sling에서 오류 핸들러를 프로그래밍하는 방법을 알아봅니다. 일반적인 템플릿을 작성하는 것과 다르지 않습니다. JSP 또는 HTL에서 템플릿을 작성할 수 있습니다. 그렇죠?

네, 하지만 이건 AEM입니다. 기억 - 디스패처는 `404 – not found` 또는 `500 – internal server error` 응답을 캐시하지 않습니다.

각(실패) 요청에서 이러한 페이지를 동적으로 렌더링하는 경우 게시 시스템에서 불필요한 높은 로드가 발생합니다.

오류가 발생할 때 전체 오류 페이지를 렌더링하지 않고 매우 단순화되고 작은 페이지만 장식이나 로직 없이 해당 페이지의 정적 버전만 렌더링하는 것이 유용하다고 결론을 내렸습니다.

물론 이것은 고객이 본 것이 아니다. Dispatcher에서 다음과 같이 `ErrorDocuments`을(를) 등록했습니다.

```
ErrorDocument 404 "/content/shiny-brand/fi/fi/edocs/error-404.html"
ErrorDocument 500 "/content/shiny-brand/fi/fi/edocs/error-500.html"
```

이제 AEM 시스템은 Dispatcher에게 어떤 것이 잘못되었다는 것을 통지할 수 있고 Dispatcher는 오류 문서의 반짝이는 아름다운 버전을 제공할 수 있습니다.

여기에서는 두 가지 사항을 주목해야 한다.

첫째, `error-404.html`은 항상 동일한 페이지입니다. 따라서 &quot;_producten_&quot;에 대한 검색 결과가 없습니다&quot;와 같은 개별 메시지가 없습니다. 우리는 그것을 가지고 쉽게 살 수 있었다.

두 번째... 글쎄요, 내부 서버 오류가 발견되거나 심지어 AEM 시스템의 작동 중단이 발생한다면, AEM에게 오류 페이지를 제공하도록 요청할 방법이 없습니다, 그렇죠? `ErrorDocument` 지시문에 정의된 대로 필요한 후속 요청도 실패합니다. `wget`을 통해 정의된 위치에서 오류 페이지를 정기적으로 가져와서 `ErrorDocuments` 지시문에 정의된 정적 파일 위치에 저장하는 cron-job을 실행하여 이 문제를 해결했습니다.

**참조**

* [apache.org - 사용자 지정 오류 문서](https://httpd.apache.org/docs/2.4/custom-error.html)

### 보호된 내용 캐싱

Dispatcher는 기본적으로 리소스를 전달할 때 권한을 확인하지 않습니다. 이러한 캠페인은 공개 웹 사이트의 속도를 높이기 위해 이러한 목적으로 구현됩니다. 로그인으로 일부 리소스를 보호하려면 기본적으로 3개의 옵션이 있습니다.

1. 요청이 캐시를 히트하기 전(즉, 디스패처 앞에 있는 SSO(Single Sign On) 게이트웨이 또는 Apache 서버의 모듈로) 리소스 Protect

2. 민감한 리소스를 캐시되지 않도록 하여 항상 게시 시스템에서 실시간으로 제공합니다.

3. Dispatcher에서 권한 구분 캐싱 사용

또한 세 가지 방법을 모두 혼합하여 적용할 수 있습니다.

**옵션 1**. &quot;SSO&quot; 게이트웨이는 어쨌든 조직에서 실행할 수 있습니다. 액세스 체계가 매우 거칠으면 리소스에 대한 액세스를 허용할지 또는 거부할지 결정하기 위해 AEM의 정보가 필요하지 않을 수 있습니다.

>[!NOTE]
>
>이 패턴에는 _게이트웨이_&#x200B;가 필요합니다. _는 각 요청을 가로채고 실제_&#x200B;인증&#x200B;_을(를) 수행하고 디스패처에 요청을 부여하거나 거부합니다._ SSO 시스템이 _인증자_&#x200B;인 경우 옵션 3을 구현해야 하는 사용자의 ID만 설정합니다. SSO 시스템 핸드북에 &quot;SAML&quot; 또는 &quot;OAauth&quot;와 같은 용어를 읽었을 때, 이 용어는 옵션 3을 구현해야 하는 강력한 지표입니다.


**옵션 2**. 일반적으로 &quot;캐싱하지 않음&quot;은 좋지 않은 생각입니다. 이렇게 하려면 트래픽 양과 제외된 민감한 리소스 수가 적은지 확인하십시오. 또는 게시 시스템에서 일부 메모리 내 캐시가 설치되어 있어야 게시 시스템에서 결과 로드를 처리할 수 있습니다(이 시리즈의 3부).

**옵션 3**. &quot;사용 권한 감지 캐싱&quot;은 흥미로운 방법입니다. Dispatcher가 리소스를 캐싱하고 있지만 전달하기 전에 AEM 시스템에 그럴 수 있는지 묻습니다. 이렇게 하면 Dispatcher에서 Publish로 추가 요청이 만들어지지만, 이미 캐시되어 있는 경우 일반적으로 게시 시스템은 페이지를 다시 렌더링하지 않습니다. 그러나 이 방법을 사용하려면 몇 가지 사용자 지정 구현이 필요합니다. 아티클 [권한 감지 캐싱](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)에서 세부 정보를 찾습니다.

**참조**

* [helpx.adobe.com - 권한 구분 캐싱](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)

### 유예 기간 설정

트리 활성화 또는 컨텐츠를 최신 상태로 유지하기 위한 단순한 필요 없이 짧은 연속 귀가일이 자주 발생하는 경우 캐시를 지속적으로 플러싱하고 방문자가 거의 항상 빈 캐시를 히트하게 될 수 있습니다.

아래 다이어그램은 단일 페이지에 액세스할 때 가능한 타이밍을 보여줍니다.  물론 요청되는 여러 페이지의 수가 더 많아지면 문제는 더 심해진다.

![잦은 활성화로 인해 대부분의 시간에 유효하지 않은 캐시가 생성됨](assets/chapter-1/frequent-activations.png)

*잦은 활성화로 인해 대부분의 시간에 유효하지 않은 캐시가 생성됨*

<br> 

이 &quot;캐시 무효화 스톰&quot;의 문제를 완화하려면 `statfile` 해석의 엄격도가 낮을 수 있습니다.

자동 무효화에 `grace period`을 사용하도록 Dispatcher를 설정할 수 있습니다. 이 경우 내부적으로 `statfiles` 수정 날짜에 약간의 시간이 더 추가됩니다.

예를 들어 `statfile`에 오늘 12:00의 수정 시간이 있고 `gracePeriod`이(가) 2분으로 설정되어 있습니다. 그러면 모든 자동 무효화된 파일은 12:01과 12:02에 유효한 것으로 간주됩니다. 12:02 이후에 다시 렌더링됩니다.

참조 구성은 합당한 이유로 2분의 `gracePeriod`을(를) 제안합니다. &#39;2분? 거의 아무것도 아니에요 컨텐츠가 표시될 때까지 10분 정도 기다릴 수 있습니다..&quot;  따라서 컨텐츠가 10분 후 적어도 나타난다고 가정할 때, 더 긴 기간을 설정하려고 할 수 있습니다. 예를 들어 10분이 지나면

>[!WARNING]
>
>이것은 `gracePeriod`이(가) 작동하는 방식이 아닙니다. 유예 기간은 문서가 무효화될 수 있는 기간이 아닌 _이지만 기간 동안 무효화가 발생하지 않습니다._ 이 프레임 _시간 프레임_&#x200B;에 포함되는 각 후속 무효화에는 무한정 길어질 수 있습니다.

예를 사용하여 `gracePeriod`이(가) 실제로 어떻게 작동하는지 보여 드리겠습니다.

예를 들어 미디어 사이트를 운영하고 있으며 편집 직원이 5분마다 정기적인 컨텐츠 업데이트를 제공합니다. gracePeriod를 5분으로 설정하는 것이 좋습니다.

간단한 예를 12시에 시작합니다.

12:00 - Statfile이 12:00으로 설정됩니다. 캐시된 모든 파일은 12:05까지 유효한 것으로 간주됩니다.

12:01 - 무효화가 발생합니다. 시간이 12:06으로 길어집니다

12:05 - 다른 편집자가 자신의 아티클을 게시하여 다른 유예 기간을 12:10으로 연장합니다.

또한 컨텐츠가 무효화되지 않습니다. *내에 있는 각 무효화는 유예 시간을 효과적으로 연장합니다.* `gracePeriod`은 무효화를 기르기 위해 고안되었지만.. 결국 비를 맞으러 나가야 합니다.. 따라서 `gracePeriod`은 대피소에 영원히 숨지 않도록 크게 짧게 두십시오.

#### 결정적 유예 기간

우리는 당신이 실효 폭풍을 어떻게 견뎌낼 수 있는지 또 다른 아이디어를 소개하고 싶습니다. 그것은 단지 아이디어일 뿐이다. 제작 과정에서 시도해본 적은 없지만, 우리는 이 아이디어를 여러분과 공유할 수 있을 정도로 흥미로운 개념을 발견했습니다.

정규 복제 간격이 `gracePeriod`보다 짧은 경우 `gracePeriod`은(는) 예측 불가능한 길어질 수 있습니다.

대체 아이디어는 다음과 같습니다.고정 시간 간격만 무효화합니다. 그 사이 시간은 항상 오래된 컨텐츠를 제공하는 것을 의미합니다. 무효화는 결국 발생하지만, 많은 무효화가 하나의 &quot;일괄&quot; 무효화에 수집되어 디스패처가 캐시된 컨텐츠를 그 동안 제공하고 출판 시스템에 숨을 쉴 수 있도록 할 수 있습니다.

구현은 다음과 같습니다.

무효화가 발생한 후 실행할 &quot;사용자 정의 무효화 스크립트&quot;(참조 참조)를 사용합니다. 이 스크립트는 `statfile's` 마지막 수정 날짜를 읽고 다음 간격 정지까지 반올림합니다. Unix 셸 명령 `touch --time`에서 시간을 지정하겠습니다.

예를 들어 유예 기간을 30초로 설정하면 디스패처는 상태 파일의 마지막 수정 날짜를 다음 30초로 반올림합니다. 다음 전체 30초 동안 동일한 다음 전체 설정 사이에 발생하는 무효화 요청입니다.

![다음 30초로 무효화를 연기하면 히트가 증가합니다.](assets/chapter-1/postponing-the-invalidation.png)

*다음 30초로 무효화를 연기하면 히트가 증가합니다.*

<br> 

무효화 요청과 다음 30초 슬롯 사이에 발생하는 캐시 히트는 오래된 것으로 간주됩니다.게시에 업데이트가 있지만 Dispatcher는 여전히 이전 컨텐츠를 제공합니다.

이 방법은 후속 요청이 결정적으로 기간을 연장하도록 염려할 필요 없이 더 긴 유예 기간을 정의하는 데 도움이 될 수 있습니다. 우리가 전에 언급했던 것처럼 - 그것은 단지 아이디어이고 우리는 그것을 시험할 기회가 없었습니다.

**참조**

[helpx.adobe.com - Dispatcher 구성](https://helpx.adobe.com/kr/experience-manager/dispatcher/using/dispatcher-configuration.html을 참조하십시오.)

### 자동 다시 가져오기

사이트에 매우 특별한 액세스 패턴이 있습니다. 들어오는 트래픽이 많고 대부분의 트래픽은 페이지의 작은 부분에 집중됩니다. 홈 페이지, 캠페인 랜딩 페이지 및 가장 인기 있는 제품 세부 사항 페이지는 트래픽의 90%를 받습니다. 또는 새 사이트를 운영하는 경우 최신 아티클의 트래픽이 이전 사이트에 비해 더 높습니다.

이제 이러한 페이지는 너무 자주 요청되므로 Dispatcher에서 캐시될 가능성이 매우 높습니다.

임의 무효화 요청이 디스패처에 전송되어 가장 인기 있는 한 페이지를 포함하여 모든 페이지가 무효화됩니다.

그 후 이러한 페이지가 매우 유명하므로 다른 브라우저에서 새로 들어오는 요청이 있습니다. 홈 페이지를 예로 들어보겠습니다.

이제 캐시가 유효하지 않으므로 동시에 들어오는 홈 페이지에 대한 모든 요청은 높은 로드를 생성하는 게시 시스템으로 전달됩니다.

![빈 캐시에서 동일한 리소스에 대한 병렬 요청:요청이 게시로 전달됩니다.](assets/chapter-1/parallel-requests.png)

*빈 캐시에서 동일한 리소스에 대한 병렬 요청:요청이 게시로 전달됩니다.*

자동 다시 반입이 가능하다면 어느 정도까지는 완화할 수 있습니다. 대부분의 무효화된 페이지는 자동 무효화 후에도 여전히 디스패처에 물리적으로 저장됩니다. _은(는)_&#x200B;의 오래된 것으로 간주됩니다. _자동_ 리퍼처치는 부실 컨텐츠를 다시 가져오기 위해 게시 시스템에  _단일_ 요청을 시작하는 동안 몇 초 동안 이러한 부실 페이지를 계속 제공한다는 것을 의미합니다.

![백그라운드에서 다시 가져오는 동안 오래된 컨텐츠 제공](assets/chapter-1/fetching-background.png)

*백그라운드에서 다시 가져오는 동안 오래된 컨텐츠 제공*

<br> 

다시 가져오기를 활성화하려면 Dispatcher에 자동 무효화 후 다시 반입할 리소스를 알려야 합니다. 활성화한 모든 페이지는 인기 있는 페이지를 비롯하여 다른 모든 페이지를 자동으로 무효화합니다.

다시 반입하는 것은 실제로 Dispatcher에게 각(!)의 정보를 표시함을 의미합니다. 가장 인기 있는 것과 가장 인기 있는 것을 다시 가져오라는 무효화 요청입니다.

이것은 무효화 요청 본문에 리소스 URL 목록(경로를 제외한 실제 URL)을 넣으면 됩니다.

```
POST /dispatcher/invalidate.cache HTTP/1.1

CQ-Action: Activate
CQ-Handle: /content/my-brand/home/path/to/some/resource
Content-Type: Text/Plain
Content-Length: 207

/content/my-brand/home.html
/content/my-brand/campaigns/landing-page-1.html
/content/my-brand/campaigns/landing-page-2.html
/content/my-brand/products/product-1.html
/content/my-brand/products/product-2.html
```

디스패처는 이러한 요청을 보면 평소대로 자동 무효화를 트리거하며, 즉시 게시 시스템에서 새 컨텐츠를 다시 가져오라는 요청을 대기열에 넣습니다.

이제 요청 본문을 사용하고 있으므로 HTTP 표준에 따라 컨텐츠 유형과 컨텐츠 길이를 설정해야 합니다.

또한 Dispatcher는 이러한 리소스가 자동 무효화에 의해 무효화되더라도 이를 직접 제공할 수 있음을 인식하도록 내부적으로 URL을 표시합니다.

나열된 모든 URL은 하나씩 요청됩니다. 따라서 게시 시스템에서 너무 높은 부하를 만들 필요가 없습니다. 그러나 해당 목록에 너무 많은 URL을 추가하는 것도 원하지 않습니다. 마지막으로, 부실 컨텐츠를 너무 오랫동안 제공하지 않기 위해 큐를 처리하는 데 한계가 있는 시간으로 처리해야 합니다. 가장 자주 액세스하는 페이지 10개만 포함시키십시오.

Dispatcher의 캐시 디렉토리를 살펴보면 타임스탬프로 표시된 임시 파일이 표시됩니다. 이 파일은 현재 백그라운드에서 로드되고 있는 파일입니다.

**참조**

[helpx.adobe.com - AEM에서 캐시된 페이지 무효화](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

### 게시 시스템 보호

디스패처는 유지 관리 목적으로만 작성된 요청으로부터 게시 시스템을 보호함으로써 약간의 추가 보안을 제공합니다. 예를 들어 `/crx/de` 또는 `/system/console` URL을 대중에게 노출시키지 않으려는 경우

시스템에 WAF(웹 응용 프로그램 방화벽)가 설치되어 있는 경우에는 아무런 영향을 주지 않습니다. 그러나 그것은 당신의 예산에 상당한 수를 더하고, 모든 프로젝트가 그들이 여유가 있고 - 절대 잊지 말아야 할 - WAF를 운영하고 유지할 수 있는 상황에 있는 것은 아니다.

우리가 자주 보는 것은 보다 취약한 리소스에 대한 액세스를 방지하는 Dispatcher 구성에서 Apache 다시 작성 규칙 세트입니다.

그러나 다른 방법을 고려할 수도 있습니다.

Dispatcher 구성에 따라 Dispatcher 모듈은 특정 디렉토리에 바인딩됩니다.

```
<Directory />
  SetHandler dispatcher-handler
  …
</Directory>
```

하지만 나중에 필터링해야 할 때 왜 핸들러를 전체 문서에 바인딩해야 합니까?

핸들러의 바인딩 범위를 첫 번째로 좁힐 수 있습니다. `SetHandler` 핸들러를 디렉토리에 바인딩하기만 하면 핸들러를 URL 또는 URL 패턴에 바인딩할 수 있습니다.

```
<LocationMatch "^(/content|/etc/design|/dispatcher/invalidate.cache)/.\*">
  SetHandler dispatcher-handler
</LocationMatch>

<LocationMatch "^/dispatcher/invalidate.cache">
  SetHandler dispatcher-handler
</LocationMatch>

…
```

이렇게 하면 디스패처의 무효화 URL에 항상 디스패처 핸들러를 바인딩하는 것을 잊지 마십시오. 그렇지 않으면 AEM에서 디스패처에 무효화 요청을 보낼 수 없습니다.

Dispatcher를 필터로 사용하는 또 다른 방법은 `dispatcher.any`에서 필터 지시어를 설정하는 것입니다.

```
/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }
```

Adobe는 한 지시문을 다른 지시문 위에 사용하는 것을 강제하지 않으며, 모든 지시문의 적절한 조합을 권장합니다.

하지만 우리는 URL 공간을 가능한 한 빨리 좁히는 것을 고려하고 가능한 한 가장 간단한 방법으로 그것을 하도록 제안합니다. 이러한 기법은 민감한 웹 사이트에서 WAF를 대체할 수 없다는 점을 염두에 두십시오. 어떤 사람들은 이러한 기술을 &quot;가난한 사람의 방화벽&quot; 이라고 하는데 이유가 있어.

**참조**

[apache.org- sethandler 지시문](https://httpd.apache.org/docs/2.4/mod/core.html#sethandler)

[helpx.adobe.com - 컨텐츠 필터에 대한 액세스 구성](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#ConfiguringAccesstoContentfilter)

### 정규 표현식 및 글로브를 사용한 필터링

초기에는 &quot;글로벌&quot; - 간단한 자리 표시자만 Dispatcher 구성에서 필터를 정의할 수 있었습니다.

다행스럽게도 Dispatcher의 최신 버전에서 변경되었습니다. 이제 POSIX 정규 표현식도 사용할 수 있으며, 요청의 다양한 부분에 액세스하여 필터를 정의할 수 있습니다. Dispatcher로 방금 시작한 사람으로서 당연한 것으로 여겨집니다. 하지만 만약 여러분이 글로브만 가지고 있다면, 이것은 일종의 놀라움이고 쉽게 간과될 수 있습니다. 글로벌 및 regexes의 구문 외에도 너무 유사합니다. 동일한 두 버전을 비교해 보겠습니다.

```
# Version A

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }

# Version B

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url '/content.\*'  }
```

차이가 보이시죠?

버전 B는 작은 따옴표 `'`를 사용하여 _정규 표현식 패턴_&#x200B;을 표시합니다. &quot;모든 문자&quot;는 `.*`을 사용하여 표현됩니다.

_글로빙 패턴인_ 반면 큰따옴표는 큰 따옴표 `"` 를 사용하며 간단한 자리 표시자만 사용할 수  `*`있습니다.

이러한 차이점을 알고 있다면 사소한 차이일 수도 있습니다. 하지만 그렇지 않을 경우 견적을 쉽게 혼합하고 화창한 오후를 사용하여 구성을 디버깅할 수 있습니다. 이제 경고가 표시됩니다.

&quot;구성에서 `'/url'`을(를) 인식합니다...하지만 질문할 수 있는 필터에 있는 `'/glob'`은 무엇입니까?

이 지시문은 메서드 및 경로를 포함하여 전체 요청 문자열을 나타냅니다. 그것은

`"GET /content/foo/bar.html HTTP/1.1"`

패턴과 비교할 문자열입니다. 초보자는 첫 번째 부분, `method`(GET, POST, ...)을 잊는 경향이 있습니다. 그래서, 패턴은

`/0002  { /glob "/content/\*" /type "allow" }`

&quot;/content&quot;가 &quot;GET ..&quot;과 일치하지 않으므로 항상 실패합니다. 를 참조하십시오.

글로브를 사용하시려면

`/0002  { /glob "GET /content/\*" /type "allow" }`

가 정확합니다.

초기 거부 규칙(예:

`/0001  { /glob "\*" /type "deny" }`

괜찮아. 그러나 이후 허용에서는 보다 표현력이 풍부하고 보다 명확하며 요청의 개별 부분을 보다 안전하게 사용할 수 있습니다.

```
/method
/url
/path
/selector
/extension
/suffix
```

다음과 같습니다.

```
/005  {

  /type "allow"
  /method "GET"
  /extension '(css|gif|ico|js|png|swf|jpe?g)' }
```

규칙에 regex 및 글로브 표현식을 혼합할 수 있습니다.

각 정의 앞에 있는 `/005`과 같은 &quot;줄 번호&quot;에 대한 마지막 단어 하나,

그들은 전혀 뜻이 없어! 규칙에 대한 임의의 분포를 선택할 수 있습니다. 숫자를 사용하는 것은 계획을 생각하는데 많은 노력을 필요로 하지 않지만, 그 순서가 중요하다는 것을 명심해라.

다음과 같은 수백 개의 규칙이 있는 경우:

```
/001
/002
/003
…
/100
…
```

/001과 /002 사이에 번호를 삽입하면 어떻게 됩니까? 당신은 그들의 수를 늘립니까? 중간 숫자를 넣으시나요?

```
/001
/001a
/002
/003
…
/100
…
```

또는 /003 및/001을 다시 주문하도록 변경하면 해당 이름과 ID를 변경하거나

```
/003
/002
/001
…
/100
…
```

첫 번째 위치에서 간단한 선택이 긴 기간의 한계에 도달하는 것처럼 보이는 번호 매기기. 식별자를 통해 숫자를 선택하는 것은 어쨌든 잘못된 프로그래밍 스타일이다.

다른 방법을 제안합니다.대부분의 경우 각 개별 필터 규칙에 대한 의미 있는 식별자를 제공하지 않습니다. 하지만 그들은 아마도 더 큰 목적을 가지고 있기 때문에, 그들은 그 목적에 따라 어떤 방법으로 그룹화할 수 있습니다. 예를 들어 &quot;기본 설정&quot;, &quot;응용 프로그램 특정 예외&quot;, &quot;전역 예외&quot; 및 &quot;보안&quot;이 있습니다.

그런 다음 규칙의 이름을 지정하고 그룹화하고 해당 구성의 리더(귀하의 동료)와 파일의 일부 방향을 제공할 수 있습니다.

```plain
  # basic setup:

  /filter {

    # basic setup

    /basic_01  { /glob "\*"             /type "deny"  }
    /basic_02  { /glob "/content/\*"    /type "allow" }
    /basic_03  { /glob "/etc/design/\*" /type "allow" }

    /basic_04  { /extension '(json|xml)'  /type "deny"  }
    …


    # login

    /login_01 { /glob "/api/myapp/login/\*" /type "allow" }
    /login_02 { … }

    # global exceptions

    /global_01 { /method "POST" /url '.\*contact-form.html' }
```


그룹 중 하나에 새 규칙을 추가하거나 새 그룹을 만들 가능성이 높습니다. 이 경우 이름 바꾸기/번호 다시 매기기를 수행할 항목 수는 해당 그룹으로 제한됩니다.

>[!WARNING]
>
>보다 정교한 설정은 필터링 규칙을 여러 파일로 분할하며, 기본 `dispatcher.any` 구성 파일에 포함됩니다. 그러나 새 파일에는 새 네임스페이스가 없습니다. 따라서 한 파일에 &quot;001&quot; 규칙이 있고 다른 파일에 &quot;001&quot;이 있는 경우 오류가 표시됩니다. 더 많은 이유가 의미심장하게 강한 이름들을 생각해내야 한다.

**참조**

[helpx.adobe.com - 전역 속성의 패턴 디자인](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#DesigningPatternsforglobProperties)

### 프로토콜 사양

마지막 팁은 진짜 팁은 아니지만 어쨌든 이 정보를 공유할 가치가 있다고 느꼈습니다.

AEM과 Dispatcher는 대부분의 경우 즉시 사용할 수 있습니다. 따라서 무효화 프로토콜에 대한 종합적인 Dispatcher 프로토콜 사양을 찾아 직접 애플리케이션을 구축할 수 없습니다. 정보는 공개적이지만, 많은 자원에 약간 흩어져 있다.

우리는 여기서 어느 정도 간격을 메우려고 노력한다. 다음은 무효화 요청의 모양입니다.

```
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: <action>
CQ-Handle: <path-pattern>
[CQ-Action-Scope]
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]

<newline>

<refetch-url-1>
<refetch-url-2>

…

<refetch-url-n>
```

`POST /dispatcher/invalidate.cache HTTP/1.1` - 첫 번째 줄은 Dispatcher 컨트롤 끝점의 URL이므로 변경하지 않을 수 있습니다.

`CQ-Action: <action>` 무슨 일이 벌어질까. `<action>` 다음 중 하나입니다.

* `Activate:` 삭제  `/path-pattern.*`
* `Deactive:` 삭제  `/path-pattern.*`
및 삭제  `/path-pattern/*`
* `Delete:`   삭제  `/path-pattern.*`
및 삭제 
`/path-pattern/*`
* `Test:`   &quot;ok&quot;를 반환하되 아무 작업도 수행하지 않습니다.

`CQ-Handle: <path-pattern>` - 무효화할 컨텐츠 리소스 경로입니다. 참고: `<path-pattern>`은 실제로 &quot;패턴&quot;이 아니라 &quot;경로&quot;입니다.

`CQ-Action-Scope: ResourceOnly` - 선택 사항:이 헤더가 설정되어 있으면  `.stat` 파일이 터치되지 않습니다.

```
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]
```

자동 참조 URL 목록을 정의하는 경우 이러한 헤더를 설정합니다. `<bytes in request body>` HTTP 본문에 있는 문자 수입니다.

`<newline>` - 요청 본문이 있는 경우 헤더에서 빈 행으로 분리되어야 합니다.

```
<refetch-url-1>
<refetch-url-2>
…
<refetch-url-n>
```

무효화 후 즉시 다시 가져올 URL을 나열합니다.

## 추가 리소스

Dispatcher 캐싱에 대한 유용한 개요 및 소개:[https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html)

기타 최적화 팁 및 기법:[https://helpx.adobe.com/experience-manager/kb/optimizing-the-dispatcher-cache.html#use-ttls](https://helpx.adobe.com/experience-manager/kb/optimizing-the-dispatcher-cache.html#use-ttls)

모든 지시문이 있는 디스패처 설명서 설명:[https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html)

FAQ:[https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html](https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html)

디스패처 최적화에 대한 웨비나 기록 - 적극 권장:[https://my.adobeconnect.com/p7th2gf8k43?proto=true](https://my.adobeconnect.com/p7th2gf8k43?proto=true)

프레젠테이션 &quot;컨텐트 무효화의 저평가된 힘&quot;, &quot;adaptTo()&quot; 콘퍼런스 2018 [https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html](https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html)

AEM에서 캐시된 페이지 무효화:[https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

## 다음 단계

* [2 - 인프라 패턴](chapter-2.md)
