---
title: '"1장 - 디스패처 개념, 패턴 및 안티패턴"'
description: 이 장에서는 Dispatcher의 역사와 역학에 대해 간략하게 설명하고 AEM 개발자가 어떻게 구성 요소를 설계하는지에 대해 설명합니다.
feature: Dispatcher
topic: 아키텍처
role: Architect
level: Beginner
source-git-commit: d9714b9a291ec3ee5f3dba9723de72bb120d2149
workflow-type: tm+mt
source-wordcount: '17487'
ht-degree: 0%

---


# 1장 - 디스패처 개념, 패턴 및 안티패턴

## 개요

이 장에서는 Dispatcher의 역사와 역학에 대해 간략하게 설명하고 AEM 개발자가 어떻게 구성 요소를 설계하는지에 대해 설명합니다.

## 개발자가 인프라에 관심을 가져야 하는 이유

Dispatcher는 대부분의 AEM 설치에 필수적인 부분입니다. 일부 설치는 그렇지 않습니다. 팁과 요령을 비롯하여 Dispatcher 구성 방법을 설명하는 많은 온라인 문서를 찾을 수 있습니다.

이러한 비트와 정보의 조각은 항상 매우 기술적인 수준에서 시작됩니다. 이 경우 사용자가 원하는 작업을 이미 알고 있기 때문에 원하는 것을 달성하는 방법에 대한 세부 사항만 제공한다고 가정합니다. 디스패처를 사용하여 수행할 수 있고 수행할 수 없는 것에 대해 _무엇이고, 왜 s_&#x200B;를 설명하는 개념적 문서를 찾지 못했습니다.

### 패턴 방지:Dispatcher as a Afterient

기본 정보가 부족하면 많은 수의 패턴 방지 작업이 수행됩니다. 많은 AEM 프로젝트에서 보아왔습니다.

1. Dispatcher가 Apache Web Server에 설치되므로 이를 구성하는 것은 프로젝트에서 &quot;Unix 신의 작업&quot;입니다. &#39;인간적 자바 개발자&#39;는 자신을 신경 쓸 필요가 없다.

2. Java 개발자는 이 코드가 작동하는지 확인해야 합니다. 나중에 디스패처가 자동으로 빠르게 만들 수 있습니다. 디스패처는 항상 뒷사고이다. 그러나 이는 작동하지 않습니다. 개발자는 디스패처를 염두에 두고 자신의 코드를 설계해야 합니다. 그리고 그는 그것을 하기 위해 그것의 기본 개념을 알아야 합니다.

### &quot;먼저 작동하게 하고 빠르게 만듭니다.&quot; 항상 옳은 것은 아닙니다.

프로그래밍 조언 _&quot;먼저 작동하게 한 다음 빨리 만드세요.&quot;를 들었을 수도 있습니다._. 그것은 완전히 틀린 것은 아니다. 그러나 올바른 컨텍스트가 없으면 잘못 해석되고 올바르게 적용되지 않는 경향이 있습니다.

권장 사항을 사용하면 개발자가 코드를 너무 빨리 최적화하지 않도록 해야 합니다. 이 경우 실행되지 않거나 거의 실행되지 않으므로 최적화가 최적화에 투입되는 노력을 정당화할 수 있는 충분한 영향을 주지 않을 수 있습니다. 또한 최적화를 통해 더 복잡한 코드가 생성되어 버그가 발생할 수 있습니다. 따라서 개발자인 경우 각 단일 코드 행을 미세 최적화하는 데 너무 많은 시간을 들이지 마십시오. 올바른 데이터 구조, 알고리즘 및 라이브러리를 선택했는지 확인하고 프로필러의 핫스팟 분석을 통해 전체 성능을 향상시킬 수 있는 위치를 확인할 수 있습니다.

### 아키텍처 결정 및 객체

하지만, &quot;먼저 그것을 작동하게 하고, 빠르게 만들어라&quot; 는 충고는 &quot;건축&quot; 결정에 있어서 완전히 틀렸다. 아키텍처 결정 사항 간단히 말해서, 그들은 나중에 바꿀 수 없거나, 비싸거나, 어렵고 또는 불가능한 결정들이다. &quot;비싼&quot;는 때때로 &quot;불가능한&quot; 것과 같다는 것을 명심해라.  예를 들어 프로젝트에 예산이 부족하면 고가의 변경 사항을 구현할 수 없습니다. 인프라의 변화는 대부분의 사람들의 마음에 오는 그 범주의 가장 첫번째 종류의 변화입니다. 그러나 또한 변화하기 매우 불쾌할 수 있는 또 다른 종류의 &quot;건축&quot; 유물이 있습니다.

1. 애플리케이션의 &quot;중심&quot;에 있는 코드 조각이며, 다른 많은 조각이 사용합니다. 이를 변경하려면 모든 종속성을 변경하고 한 번에 다시 테스트해야 합니다.

2. 일부 비동기적 시간 종속 시나리오와 관련된 아티팩트로서, 입력 위치에 따라 시스템의 동작이 매우 임의로 다를 수 있습니다. 변화는 예측할 수 없는 효과를 가질 수 있고 테스트하기 어려울 수 있습니다.

3. 시스템의 모든 부분과 부분에서 사용 및 재사용되는 소프트웨어 패턴입니다. 소프트웨어 패턴이 하위 최적인 경우 패턴을 사용하는 모든 아티팩트를 다시 코딩해야 합니다.

기억? 이 페이지 상단에서 Dispatcher는 AEM 애플리케이션의 필수 부분입니다. 웹 애플리케이션에 대한 액세스는 매우 무작위적입니다. 즉, 사용자가 예상치 못한 시간에 도달하고 있습니다. 결국 모든 컨텐츠는 Dispatcher에서 캐시됩니다(또는 캐시해야 함). 따라서 집중적인 주의를 기울인다면 캐싱은 &quot;아키텍처&quot; 아티팩트로 보일 수 있으므로 팀, 개발자 및 관리자 모두가 이해할 수 있어야 합니다.

개발자가 실제로 Dispatcher를 구성해야 한다고 말하는 것은 아닙니다. 따라서 Dispatcher에서 코드를 활용할 수 있도록 개념(특히 경계)을 알고 있어야 합니다.

Dispatcher는 코드 속도를 마술처럼 개선하지 않습니다. 개발자는 Dispatcher를 염두에 두고 이 구성 요소를 만들어야 합니다. 따라서 작동 방식을 알 필요가 있습니다.

## Dispatcher 캐싱 - 기본 원칙

### Dispatcher를 캐싱 Http - 로드 밸런서

Dispatcher가 무엇이며 처음에 &quot;Dispatcher&quot;라고 하는 이유는 무엇입니까?

디스패처가

* 우선 및 우선 캐시

* 역방향 프록시

* Apache httpd 웹 서버용 모듈로, Apache의 다용성에 AEM 관련 기능을 추가하고 다른 모든 Apache 모듈(예: SSL 또는 SSI도 나중에 볼 수 있듯이 포함)과 원활하게 작동합니다

웹의 초기에는 수백 명의 방문자가 사이트를 방문할 것으로 예상됩니다. 한 Dispatcher의 설정으로서, &quot;디스패처&quot;를 설정하거나 다수의 AEM 게시 서버에 대한 요청 로드를 균형 조정했으며 일반적으로 충분했습니다. 따라서 &quot;Dispatcher&quot;라는 이름이 사용됩니다. 하지만 요즘은 이 설정이 더 이상 자주 사용되지 않습니다.

이 문서의 후반부에 Dispatcher 및 게시 시스템을 설정하는 다양한 방법을 볼 수 있습니다. 먼저 몇 가지 http 캐싱 기본 사항으로 시작하겠습니다.

![Dispatcher 캐시의 기본 기능](assets/chapter-1/basic-functionality-dispatcher.png)

*Dispatcher 캐시의 기본 기능*

<br> 

디스패처의 기본 사항은 여기에서 설명합니다. 디스패처는 HTTP 요청을 받고 만들 수 있는 간단한 캐싱 역방향 프록시입니다. 일반적인 요청/응답 주기는 다음과 같습니다.

1. 사용자가 페이지를 요청합니다.
2. Dispatcher가 이미 해당 페이지의 렌더링된 버전이 있는지 확인합니다. 이 페이지에 대한 첫 번째 요청이며 Dispatcher가 로컬 캐시된 복사본을 찾을 수 없다고 가정합니다.
3. Dispatcher가 Publish 시스템에서 페이지를 요청합니다
4. 게시 시스템에서 페이지는 JSP 또는 HTL 템플릿에 의해 렌더링됩니다
5. 페이지가 Dispatcher에 반환됩니다
6. Dispatcher가 페이지를 캐시합니다
7. Dispatcher가 페이지를 브라우저에 반환합니다
8. 동일한 페이지가 두 번째로 요청되는 경우 게시 인스턴스에서 다시 렌더링하지 않고 Dispatcher 캐시에서 직접 제공할 수 있습니다. 이렇게 하면 게시 인스턴스에서 사용자 및 CPU 사이클에 대한 대기 시간이 저장됩니다.

마지막 섹션에서 &quot;페이지&quot;에 대해 얘기했습니다. 하지만 동일한 구성표는 이미지, CSS 파일, PDF 다운로드 등과 같은 다른 리소스에도 적용됩니다.

#### 데이터 캐시 방법

Dispatcher 모듈은 호스팅 Apache 서버가 제공하는 기능을 활용합니다. HTML 페이지, 다운로드 및 그림과 같은 리소스는 Apache 파일 시스템에 단순 파일로 저장됩니다. 간단합니다.

파일 이름은 요청된 리소스의 URL에 의해 파생됩니다. `/foo/bar.html` 파일을 요청하면 이 파일은 /`var/cache/docroot/foo/bar.html` 아래에 저장됩니다.

기본적으로 모든 파일이 캐시되어 Dispatcher에 정적으로 저장되는 경우 게시 시스템의 플러그인을 가져올 수 있으며 Dispatcher는 간단한 웹 서버 역할을 합니다. 그러나 이것은 단지 그 원칙을 설명하는 것이다. 실제 생활은 더 복잡하다. 렌더링 프로세스의 동적 특성으로 인해 리소스 수가 무한할 수 있으므로 모든 것을 캐싱할 수 없으며 캐시가 완전히 &quot;전체&quot;가 아닙니다. 정적 파일 시스템 모델은 Dispatcher의 기능에 대한 대략적인 그림을 생성하는 데 도움이 됩니다. 또한 디스패처의 제한 사항을 설명하는 데 도움이 됩니다.

#### AEM URL 구조 및 파일 시스템 매핑

Dispatcher를 더 자세히 이해하려면 간단한 샘플 URL의 구조를 다시 살펴보겠습니다.  아래 예를 살펴보겠습니다.

`http://domain.com/path/to/resource/pagename.selectors.html/path/suffix.ext?parameter=value&amp;otherparameter=value#fragment`

* `http` 는 프로토콜을 나타냅니다

* `domain.com` 은 도메인 이름입니다

* `path/to/resource` 는 리소스가 CRX에 저장되고 그 다음에 Apache 서버의 파일 시스템에 저장되는 경로입니다

여기서는 AEM 파일 시스템과 Apache 파일 시스템 간에 약간 다릅니다.

AEM에서,

* `pagename` 은 리소스 레이블입니다

* `selectors` 은 리소스가 렌더링되는 방식을 결정하기 위해 Sling에서 사용되는 여러 선택기를 의미합니다. URL에는 임의 개수의 선택기가 있을 수 있습니다. 그것들은 마침표로 구분되어 있다. 예를 들어 선택기 섹션은 &quot;프랑스어.mobile.fancy&quot;와 같은 것일 수 있습니다. 선택기는 문자, 숫자 및 대시만 포함해야 합니다.

* `html` 선택기의 마지막 항목이 됨은 확장을 확장이라고 합니다. AEM/Sling에서 렌더링 스크립트도 부분적으로 결정합니다.

* `path/suffix.ext` 는 URL에 접미사를 사용할 수 있는 경로 유사 표현식입니다.  AEM 스크립트에서 리소스를 렌더링하는 방법을 추가로 제어하는 데 사용할 수 있습니다. 이 부분에 대한 전체 섹션을 나중에 하겠습니다. 현재, 이를 추가 매개 변수로 사용할 수 있음을 알고 있어야 합니다. 접미사에 확장자가 있어야 합니다.

* `?parameter=value&otherparameter=value` 는 URL의 쿼리 섹션입니다. 임의 매개 변수를 AEM에 전달하는 데 사용됩니다. 매개 변수가 있는 URL은 캐시할 수 없으므로 매개 변수는 반드시 필요한 경우에만 제한해야 합니다.

* `#fragment`를 지정하는 경우 URL의 조각 부분이 AEM에 전달되지 않으며 브라우저에서만 사용됩니다.JavaScript 프레임워크에서 &quot;라우팅 매개 변수&quot;로 또는 페이지의 특정 부분으로 이동합니다.

Apache(*아래 다이어그램 참조*)에서는

* `pagename.selectors.html` 는 캐시의 파일 시스템에서 파일 이름으로 사용됩니다.

URL에 `path/suffix.ext` 접미사가 있는 경우에는,

* `pagename.selectors.html` 폴더로 만들어집니다

* `path` 폴더의  `pagename.selectors.html` 폴더

* `suffix.ext` 는 폴더의  `path` 파일입니다. 참고:접미사에 확장자가 없는 경우에는 파일이 캐시되지 않습니다.

![Dispatcher에서 URL을 가져온 후 파일 시스템 레이아웃](assets/chapter-1/filesystem-layout-urls-from-dispatcher.png)

*Dispatcher에서 URL을 가져온 후 파일 시스템 레이아웃*

<br> 

#### 기본 제한 사항

URL, 리소스 및 파일 이름 간의 매핑은 매우 간단합니다.

그러나 몇 가지 트랩을 발견했을 수 있습니다.

1. URL이 매우 길어질 수 있습니다. 로컬 파일 시스템에 `/docroot` 의 &quot;path&quot; 부분을 추가하면 일부 파일 시스템의 제한을 쉽게 초과할 수 있습니다. Windows에서 NTFS로 Dispatcher를 실행하는 것은 어려울 수 있습니다. 그러나 Linux에서는 안전합니다.

2. URL에는 특수 문자와 모음 기호를 사용할 수 있습니다. 이는 일반적으로 디스패처의 문제가 아닙니다. 그러나 URL은 애플리케이션의 여러 위치에서 해석됩니다. 종종 애플리케이션의 이상한 동작을 본 적이 있습니다. 거의 사용되지 않는(사용자 지정) 코드 한 조각이 특수 문자에 대해 완전히 테스트되지 않았음을 알 수 있습니다. 할 수 있으면 피하세요. 그리고 당신이 할 수 없다면, 철저한 테스트를 계획하세요.

3. CRX에서 리소스에는 하위 리소스가 있습니다. 예를 들어 페이지에 여러 개의 하위 페이지가 있습니다. 파일 시스템에 파일 시스템이나 폴더가 있으므로 파일 시스템에서 이 파일을 일치시킬 수 없습니다.

#### 확장이 없는 URL은 캐시되지 않습니다.

URL에는 항상 확장이 있어야 합니다. AEM에서 확장 없이 URL을 제공할 수 있지만, 이러한 URL은 Dispatcher에서 캐시되지 않습니다.

**예**

`http://domain.com/home.html` 캐시  **가능**

`http://domain.com/home` 캐시할 수  **없음**

URL에 접미사가 있을 때에도 동일한 규칙이 적용됩니다. 접미사에 캐시하려면 확장이 있어야 합니다.

**예**

`http://domain.com/home.html/path/suffix.html` 캐시  **가능**

`http://domain.com/home.html/path/suffix` 캐시할 수  **없음**

리소스 부분에 확장이 없지만 접미사에 확장이 있는 경우 어떻게 됩니까? 글쎄요, 이 경우 URL은 전혀 접미사가 없습니다. 다음 예를 보십시오.

**예**

`http://domain.com/home/path/suffix.ext`

`/home/path/suffix`은(는) 리소스의 경로이므로 URL에 접미사가 없습니다.

**결론**

항상 경로와 접미사 모두에 확장을 추가하십시오. SEO를 인식하는 사람들은 이것이 검색 결과에 있어서 여러분을 순위를 매기고 있다고 때때로 주장합니다. 그러나 페이지가 뜨지 않으면 속도가 매우 느리고 더 나아가 순위가 내릴 수 있습니다.

#### 접미어 URL 충돌

유효한 URL이 두 개 있다고 가정합니다

`http://domain.com/home.html`

및

`http://domain.com/home.html/suffix.html`

AEM에서는 절대적으로 유효합니다. 로컬 개발 시스템에서 Dispatcher가 없으면 문제가 표시되지 않습니다. UAT 또는 로드 테스트에서도 문제가 발생하지 않을 수 있습니다. 우리가 직면하고 있는 문제는 너무 미묘하여 대부분의 시험을 통과한다.  가장 바쁜 시간에 가장 많은 영향을 받게 되며, 문제를 해결할 수 있는 시간이 제한되며, 서버 액세스 권한이 없거나 수정할 리소스가 없을 수 있습니다. 우린 계속..

그래서.. 뭐가 문제죠?

`home.html` 파일 시스템에서 파일 또는 폴더일 수 있습니다. AEM에서와 동시에 둘 다 아닙니다.

먼저 `home.html`을 요청하면 파일로 생성됩니다.

`home.html/suffix.html`에 대한 후속 요청은 유효한 결과를 반환하지만 파일 `home.html` &quot;blocks&quot; 파일이 파일 시스템의 위치를 나타내는 경우 `home.html`을(를) 폴더로 두 번째로 만들 수 없으므로 `home.html/suffix.html`이 캐시되지 않습니다.

![파일 시스템에서 파일 차단 위치에 따라 하위 리소스를 캐시할 수 없습니다.](assets/chapter-1/file-blocking-position-in-filesystem.png)

*파일 시스템에서 파일 차단 위치에 따라 하위 리소스를 캐시할 수 없습니다.*

<br> 

반대로 수행하는 경우 먼저 `home.html/suffix.html`을 요청한 다음, `suffix.html`이(가) 먼저 `/home.html` 폴더 아래에 캐시됩니다. 그러나 이 폴더는 나중에 리소스로 `home.html`을 요청할 때 `home.html` 파일로 대체되고 삭제됩니다.

![상위 항목을 리소스로 가져올 때 경로 구조 삭제](assets/chapter-1/deleting-path-structure.png)

*상위 항목을 리소스로 가져올 때 경로 구조 삭제*

<br> 

따라서 캐시되는 작업의 결과는 완전히 임의적이며 들어오는 요청의 순서에 따라 달라집니다. 더욱 까다로운 문제를 만드는 것은 일반적으로 디스패처가 두 개 이상 있다는 사실입니다. 성능, 캐시 적중률 및 동작은 한 Dispatcher와 다른 Dispatcher마다 다를 수 있습니다. 웹 사이트가 응답하지 않는 이유를 확인하려면 잘못된 캐싱 순서가 있는 올바른 Dispatcher를 보고 있는지 확인해야 합니다. Dispatcher를 보고 있다면 - 운 좋게도 - 더 유리한 요청 패턴이 있는 경우 문제를 찾는 데 실패하게 됩니다.

#### URL 충돌 방지

접미사가 있을 때 리소스에 다른 확장자를 사용하는 경우 폴더 이름과 파일 이름이 파일 시스템의 동일한 경로에 대해 &quot;경쟁&quot;하는 &quot;URL 충돌&quot;을 방지할 수 있습니다.

**예**

* `http://domain.com/home.html`

* `http://domain.com/home.dir/suffix.html`

둘 다 완전 박리가 가능하지만

![](assets/chapter-1/cacheable.png)

접미사를 요청하거나 접미사를 모두 사용하지 않는 경우 리소스에 대한 전용 확장 &quot;dir&quot;을 선택합니다. 유용하게 사용할 수 있는 경우는 거의 없습니다. 그리고 이러한 사례를 올바르게 구현하기가 쉽습니다.  다음 장에서는 캐시 무효화 및 플러싱에 대해 설명합니다.

#### 실행 취소할 수 없는 요청

마지막 장에 대한 간단한 요약과 몇 가지 예외를 검토해 보겠습니다. Dispatcher는 URL이 캐시 가능한 것으로 구성되어 있고 GET 요청인 경우 캐싱할 수 있습니다. 다음 예외 중 하나로는 캐시할 수 없습니다.

**캐시 가능한 요청**

* 요청은 Dispatcher 구성에서 캐시되도록 구성되어 있습니다
* 요청은 일반적인 GET 요청입니다

**캐시할 수 없는 요청 또는 응답**

* 구성에 의해 캐싱이 거부된 요청(경로, 패턴, MIME 유형)
* &quot;Dispatcher:no-cache&quot; 헤더
* Cache-Control을 반환하는 응답:no-cache|private&quot; 헤더
* &quot;Pragma:no-cache&quot; 헤더
* 쿼리 매개 변수를 사용한 요청
* 확장이 없는 URL
* 확장이 없는 접미사를 사용하는 URL
* 200 이외의 상태 코드를 반환하는 응답
* POST 요청

## 캐시 무효화 및 플러시

### 개요

Dispatcher가 요청을 캐시할 수 없는 경우 마지막 장에 많은 예외가 나열됩니다. 그러나 고려해야 할 사항이 더 있습니다.Dispatcher _이_&#x200B;에 요청을 캐시할 수 있다고 해서 반드시 _에_&#x200B;이(가) 있어야 한다는 뜻은 아닙니다.

요점은 다음과 같습니다.캐싱은 일반적으로 쉽습니다. Dispatcher는 응답의 결과를 저장하고 다음에 매우 동일한 요청이 수신될 때 반환해야 합니다. 오른쪽? 틀렸습니다!

어려운 부분은 캐시의 _무효화_ 또는 _플러싱_&#x200B;입니다. Dispatcher는 리소스가 변경된 시점을 파악하고 다시 렌더링해야 합니다.

이건 사소한 일처럼 보이긴 하지만... 자세히 읽어보면 단일 리소스와 단순 리소스 및 여러 리소스의 고도로 메시징된 구조를 사용하는 페이지 간의 까다로운 차이점을 확인할 수 있습니다.

### 단순 리소스 및 플러시

특별한 &quot;thumb&quot; 선택기를 사용하여 요청할 때 각 이미지에 대한 축소판 렌디션을 동적으로 생성하도록 AEM 시스템을 설정했습니다.

`/content/dam/path/to/image.thumb.png`

그리고 - 물론, 선택기가 없는 URL로 원본 이미지를 제공할 URL을 제공합니다.

`/content/dam/path/to/image.png`

축소판이나 원본 이미지를 모두 다운로드하면

```
/var/cache/dispatcher/docroot/content/dam/path/to/image.thumb.png

/var/cache/dispatcher/docroot/content/dam/path/to/image.png
```

Dispatcher의 파일 시스템에 있습니다.

이제 사용자가 해당 파일의 새 버전을 업로드하고 활성화합니다. 궁극적으로 무효화 요청은 AEM에서 Dispatcher로 전송됩니다.

```
GET /invalidate
invalidate-path:  /content/dam/path/to/image

<no body>
```

무효화는 매우 쉽습니다.Dispatcher에서 특수 &quot;/invalidate&quot; URL에 대한 간단한 GET 요청입니다. HTTP-body가 필요하지 않으며 &quot;payload&quot;는 &quot;invalidate-path&quot; 헤더일 뿐입니다. 또한 헤더의 invalidate-path 는 AEM에서 알고 있는 리소스이며 Dispatcher가 캐시한 파일이나 파일이 아닙니다. AEM은 리소스만 알고 있습니다. 리소스가 요청될 때 확장, 선택기 및 접미사는 런타임에 사용됩니다. AEM에서는 리소스에 사용된 선택기에 대해 부기를 수행하지 않으므로 리소스를 활성화할 때 리소스 경로가 확실히 아는 모든 것입니다.

우리의 경우에는 이것으로 충분하다. 자원이 변경되었다면, 우리는 그 리소스의 모든 표현물도 또한 변경되었다고 생각할 수 있습니다. 이 예제에서는 이미지가 변경되면 새 축소판도 렌더링됩니다.

Dispatcher는 캐시한 모든 변환으로 리소스를 안전하게 삭제할 수 있습니다. 뭔가 할 수 있을 거야

`$ rm /content/dam/path/to/image.*`

`image.png` 및 `image.thumb.png` 및 해당 패턴과 일치하는 다른 모든 변환을 제거합니다.

매우 간단합니다. 하나의 리소스만 사용하여 요청에 응답하는 한..

### 참조 및 메시징된 컨텐츠

#### 저장된 컨텐츠 문제

AEM에 업로드된 이미지 또는 다른 이진 파일과 대조적으로 HTML 페이지는 독성이 아닙니다. 그들은 양 떼에서 살고 있으며, 하이퍼링크와 참조에 의해 서로 매우 연결되어 있습니다. 단순 링크는 해롭지 않지만, 콘텐츠 참조에 대해 이야기할 때 까다롭게 됩니다. 페이지의 유비쿼터스 위쪽 탐색 또는 Teaser는 컨텐츠 참조입니다.

#### 컨텐츠 참조 및 컨텐츠 참조가 문제가 되는 이유

간단한 예를 살펴보겠습니다. 여행사에는 캐나다 여행을 홍보하는 웹페이지가 있다. 이 프로모션은 &quot;홈&quot; 페이지와 &quot;겨울 특별&quot; 페이지의 다른 두 페이지의 티저 섹션에 있습니다.

두 페이지 모두에 동일한 Teaser가 표시되므로 작성자에게 표시되어야 하는 각 페이지에 대해 Teaser를 여러 번 작성하도록 요구하는 것은 필요하지 않습니다. 대신 대상 페이지 &quot;캐나다&quot;는 티저에 대한 정보를 제공하기 위해 페이지 속성의 섹션을 예약합니다. 또는 티저를 모두 렌더링하는 URL을 제공하는 것이 좋습니다.

`<sling:include resource="/content/home/destinations/canada" addSelectors="teaser" />`

또는

`<sling:include resource="/content/home/destinations/canada/jcr:content/teaser" />`

![](assets/chapter-1/content-references.png)

AEM에서는 잘 작동하지만 게시 인스턴스에서 Dispatcher를 사용하는 경우 이상한 일이 발생합니다.

웹사이트를 게시했다고 상상해보세요. 캐나다 페이지의 제목은 &quot;캐나다&quot;입니다. 방문자가 해당 페이지에 대한 티저 참조가 있는 홈 페이지를 요청하면 &quot;캐나다&quot; 페이지의 구성 요소가 다음과 같이 렌더링됩니다

```
<div class="teaser">
  <h3>Canada</h3>
  <img …>
</div>
```

** 를 홈 페이지로 연결하는 중입니다. 홈 페이지는 Dispatcher가 Teaser와 파일 헤드라인을 포함한 정적 .html 파일로 저장합니다.

이제 마케터는 Teaser 헤드라인이 조치를 취할 수 있어야 한다는 것을 알게 되었습니다. 그래서 그는 &quot;캐나다&quot;에서 &quot;캐나다 방문&quot;으로 제목을 바꾸고 이미지를 업데이트하기도 한다.

그는 편집된 &quot;캐나다&quot; 페이지를 게시하고 이전에 게시된 홈 페이지를 수정하여 변경 사항을 확인합니다. 하지만, 아무 것도 변하지 않았다. 여전히 이전 티저가 표시됩니다. 그는 &quot;겨울 특별 행사&quot;를 두 번 확인한다. 이 페이지는 이전에 요청한 적이 없으므로 Dispatcher에서 정적으로 캐시되지 않습니다. 따라서 이 페이지는 게시에서 새로 렌더링되며 이제 이 페이지에 새로운 &quot;캐나다 방문&quot; 티저가 포함됩니다.

![홈 페이지에 오래된 포함된 콘텐츠를 저장하는 Dispatcher](assets/chapter-1/dispatcher-storing-stale-content.png)

*홈 페이지에 오래된 포함된 콘텐츠를 저장하는 Dispatcher*

<br> 

무슨 일이야? Dispatcher는 렌더링 중에 다른 리소스에서 가져온 모든 콘텐츠 및 마크업이 포함된 페이지의 정적 버전을 저장합니다.

단순한 파일 시스템 기반 웹 서버인 Dispatcher는 빠르고 간단합니다. 포함된 리소스가 변경되더라도 이를 인식하지 못합니다. 포함 페이지가 렌더링될 때에도 여전히 남아 있는 콘텐츠를 호출합니다.

&quot;겨울 특수&quot; 페이지가 아직 렌더링되지 않았으므로 Dispatcher에 정적 버전이 없으므로 요청 시 새로 렌더링되므로 새 Teaser가 표시됩니다.

Dispatcher는 리소스가 변경될 때 이 리소스를 사용한 모든 페이지를 렌더링하고 플러싱하는 동안 터치 하는 모든 리소스를 추적한다고 생각할 수 있습니다. 하지만 Dispatcher는 페이지를 렌더링하지 않습니다. 렌더링은 게시 시스템에서 수행됩니다. Dispatcher는 렌더링된 .html 파일에 들어가는 리소스를 모릅니다.

아직도 확신하지 못합니까? *&quot;종속성 추적&quot;*&#x200B;을 구현하는 방법이 있어야 한다고 생각할 수 있습니다. 글쎄요, 또는 보다 정확하게 *이 있습니다*. AEM의 대 증조부인 Cookie 3에는 페이지를 렌더링하는 데 사용된 _session_&#x200B;에 종속성 추적기가 구현되었습니다.

요청 중에, 이 세션을 통해 획득한 각 리소스는 현재 렌더링되고 있는 URL의 종속성으로 추적되었습니다.

그러나, 종속성은 계속 추적하는 것이 매우 비용이 많이 드는 것으로 밝혀졌습니다. 사람들은 곧 한 html 페이지가 변경된 모든 html 페이지를 다시 렌더링하는 데 의존하며 종속성 추적 기능을 모두 해제하면 웹 사이트가 더 빨라진다는 것을 알게 되었습니다. 게다가, 그 계획은 완벽하지도 않았다 - 도중에 많은 함정과 예외가 있었다. 경우에 따라 요청을 기본 세션에 사용하여 리소스를 가져오는 것이 아니라 요청을 렌더링할 도우미 리소스를 가져오는 관리자 세션을 사용했습니다. 이러한 종속성은 일반적으로 추적되지 않으며 수동으로 캐시를 플러시하도록 요청하는 ops-team에 대한 전화와 두통을 유발했습니다. 그들이 그것을 하는 표준 절차를 가졌다면 당신은 운이 좋았다. 그 동안 더 많은 일들이 있었지만... 이것은 2005년으로 되돌아 갑니다. 결국 이 기능은 기본적으로 Cookie 4에서 비활성화되었으며, 후속 CQ5로 다시 설정되지 않아 AEM이 되었습니다.

### 자동 무효화

#### 전체 플러싱이 종속성 추적보다 저렴한 경우

CQ5 이후 Adobe에서는 페이지 중 하나만 변경되는 경우 전체 사이트를 무효화하기 위해 전적으로 의지합니다. 이 기능을 &quot;자동 무효화&quot;라고 합니다.

그러나 다시 한 번, 수백 개의 페이지를 버리고 다시 렌더링하는 것이 적절한 종속성 추적 및 부분 다시 렌더링을 수행하는 것보다 비용이 저렴하다는 것이 어떻게 가능합니까?

다음과 같은 두 가지 주요 이유가 있습니다.

1. 평균 웹 사이트에서는 페이지의 작은 하위 집합만 자주 요청됩니다. 따라서 렌더링된 모든 컨텐츠를 버리더라도 실제로는 수십 개만 즉시 요청됩니다. 실제로 페이지가 요청될 때 롱테일 렌더링을 시간 경과에 따라 배포할 수 있습니다. 따라서 실제로 렌더링 페이지의 로드가 예상보다 높지 않습니다. 물론 항상 예외가 있습니다. 나중에 빈 Dispatcher 캐시를 사용하여 대규모 웹 사이트에서 균등하게 분산된 로드를 처리하는 방법에 대해 알아보겠습니다.

2. 모든 페이지는 주 탐색에 의해 연결됩니다. 따라서 궁극적으로 거의 모든 페이지가 서로 종속되어 있습니다. 이것은 가장 똑똑한 종속성 추적기라도 우리가 이미 알고 있는 것을 알아낼 것이라는 것을 의미합니다.페이지 중 하나가 변경되면 다른 모든 페이지를 무효화해야 합니다.

안 믿나요? 마지막 요점을 설명하겠습니다.

마지막 예와 동일한 인수를 사용하여 원격 페이지의 콘텐츠를 참조하는 Teaser를 사용합니다. 현재는 더 극단적인 예를 사용하고 있습니다.자동으로 렌더링되는 기본 탐색입니다. Teaser와 마찬가지로, 탐색 제목은 연결된 페이지 또는 &quot;원격&quot; 페이지에서 콘텐츠 참조로 그려집니다. 원격 탐색 제목은 현재 렌더링된 페이지에 저장되지 않습니다. 탐색이 웹 사이트의 각 페이지와 모든 페이지에 렌더링됩니다. 따라서 하나의 페이지의 제목은 기본 탐색이 있는 모든 페이지에서 반복해서 사용됩니다. 탐색 제목을 변경하려면 해당 페이지를 참조하는 모든 페이지가 아니라, 원격 페이지에서 한 번만 변경하려고 합니다.

따라서 이 예제에서 탐색은 대상 페이지의 &quot;NavTitle&quot;을 사용하여 탐색에서 이름을 렌더링하여 모든 페이지를 함께 표시합니다. &quot;Iceland&quot;의 탐색 제목은 &quot;Iceland&quot; 페이지에서 시작해 주 탐색 영역이 있는 모든 페이지로 렌더링됩니다.

![주 탐색에서는 &quot;NavTitles&quot;를 가져와서 모든 페이지의 컨텐츠를 함께 표시할 수 없습니다](assets/chapter-1/nav-titles.png)

*주 탐색에서는 &quot;NavTitles&quot;를 가져와서 모든 페이지의 컨텐츠를 함께 표시할 수 없습니다*

<br> 

아이슬란드 페이지의 NavTitle을 &quot;아이슬란드&quot;에서 &quot;Beautiful Iceland&quot;로 변경하면 다른 모든 페이지 기본 메뉴에서 해당 제목이 즉시 변경됩니다. 따라서 해당 변경 전에 렌더링되고 캐시된 페이지는 모두 오래된 상태가 되어 무효화되어야 합니다.

#### 자동 무효화 구현 방법:.stat 파일

수천 개의 페이지가 있는 큰 사이트가 있는 경우 모든 페이지를 순환하고 물리적으로 삭제하는 데 시간이 꽤 걸릴 수 있습니다. 이 기간 동안 Dispatcher는 실수로 부실 컨텐츠를 제공할 수 있습니다. 또한 캐시 파일에 액세스하는 동안 일부 충돌이 발생할 수 있으며, 페이지가 삭제되는 동안 요청되거나, 즉시 이후 활성화 후에 발생한 두 번째 무효화로 페이지가 다시 삭제될 수도 있습니다. 뭐가 엉망인지 생각해 봐. 다행히 이런 일은 일어나지 않는다. Dispatcher는 이러한 문제를 방지하기 위해 영리한 방법을 사용합니다.수백, 수천 개의 파일을 삭제하는 대신 파일을 게시하면 파일 시스템의 루트에 빈 간단한 파일을 삽입하므로 모든 종속 파일이 잘못된 것으로 간주됩니다. 이 파일을 &quot;statfile&quot;이라고 합니다. 상태 파일은 빈 파일입니다. 상태 파일에 대한 중요한 사항은 작성 날짜입니다.

만든 날짜가 상태 파일보다 오래된 디스패처의 모든 파일이 마지막 활성화(및 무효화) 전에 렌더링되어 &quot;잘못된&quot; 것으로 간주됩니다. 이러한 파일은 여전히 파일 시스템에 실제로 있지만 Dispatcher는 이를 무시합니다. 그것들은 &quot;부실하다&quot;. 오래된 리소스에 대한 요청이 수행될 때마다 Dispatcher는 AEM 시스템에 페이지를 다시 렌더링하도록 요청합니다. 새로 렌더링된 페이지는 파일 시스템에 저장됩니다. 이제 새로 만든 날짜가 새로 추가되어 새로 고칩니다.

![.stat 파일의 작성 날짜는 오래된 컨텐츠와 새로 고친 컨텐츠를 정의합니다](assets/chapter-1/creation-date.png)

*.stat 파일의 작성 날짜는 오래된 컨텐츠와 새로 고친 컨텐츠를 정의합니다*

<br> 

이것이 &quot;.stat&quot;라고 불리는 이유를 물어볼 수 있습니다. 그리고 아마 &quot;.epired&quot; 라고 할 수 없나요? 파일 시스템에 해당 파일이 있으면 Dispatcher가 정적 웹 서버에서 제공하는 것과 같이 *정적으로*&#x200B;제공할 수 있는 리소스를 결정하는 데 도움이 됩니다. 이러한 파일을 더 이상 동적으로 렌더링할 필요가 없습니다.

하지만 이 이름의 진정한 본성은 은유적이지 않다. 이 값은 Unix 시스템 호출 `stat()`에서 파생되며, 이 호출은 파일의 수정 시간(다른 속성 중)을 반환합니다.

#### 단순 및 자동 유효성 검사 혼합

하지만 잠깐.. 우리가 아까 말했던 것처럼, 하나의 리소스는 물리적으로 삭제됩니다. 이제 보다 최근의 상태 파일이 Dispatcher의 눈에 사실상 유효하지 않게 렌더링될 것이라고 합니다. 왜 먼저 물리적 삭제를 해야 합니까?

답은 간단하다. 일반적으로 두 전략을 동시에 사용하지만 다양한 리소스에 사용됩니다. 이미지와 같은 이진 자산은 자체 포함되어 있습니다. 따라서 정보를 렌더링해야 한다는 의미에서 다른 리소스와 연결되지 않습니다.

반면 HTML 페이지는 상호 종속적입니다. 따라서 자동 무효화를 적용합니다. Dispatcher의 기본 설정입니다. 무효화된 리소스에 속하는 모든 파일은 물리적으로 삭제됩니다. 또한 &quot;.html&quot;로 끝나는 파일은 자동으로 무효화됩니다.

Dispatcher는 자동 무효화 스키마를 적용할지 여부를 파일 확장자를 결정합니다.

자동 무효화에 대한 파일 끝을 구성할 수 있습니다. 이론에서 자동 무효화에 대한 모든 확장을 포함할 수 있습니다. 그러나 이것은 매우 높은 가격이라는 것을 명심하십시오. 제대로 전달되지 않은 리소스가 제공되지는 않지만, 게재 성능이 오버무효화되므로 크게 저하됩니다.

예를 들어, PNG와 JPG를 동적으로 렌더링하고 다른 리소스에 따라 렌더링하는 체계를 구현한다고 가정해 보겠습니다. 고해상도 이미지를 더 작은 웹 호환 해상도로 다시 확장하려는 경우도 있습니다. 현재 상태에서는 압축률도 변경됩니다. 이 예제의 해상도 및 압축률은 고정된 상수가 아니지만 이미지를 사용하는 구성 요소에서 구성 가능한 매개 변수입니다. 이제 이 매개 변수가 변경되면 이미지를 무효화해야 합니다.

문제 없습니다. 우리는 방금 자동 무효화에 이미지를 추가할 수 있고 어떤 것이 바뀔 때마다 항상 새로 렌더링된 이미지를 가질 수 있다는 것을 알았습니다.

#### 목욕물과 함께 아기 버리고

맞아, 그리고 그건 큰 문제야. 마지막 단락을 다시 읽습니다. &quot;...모든 변경 사항이 있을 때마다 새로 렌더링된 이미지&quot; 아시다시피 좋은 웹 사이트가 지속적으로 변경됩니다.여기에 새 컨텐츠를 추가하고, 거기에서 오타를 수정하고, 다른 곳에서 티저를 수정합니다. 즉, 모든 이미지가 지속적으로 무효화되므로 다시 렌더링해야 합니다. 그것을 과소평가하지 마라. 이미지 데이터를 동적으로 렌더링하고 전송하는 작업은 로컬 개발 시스템에서 밀리초 단위로 작동합니다. 프로덕션 환경에서도 초당 100배 더 자주 수행해야 합니다.

그리고 여기에서 명확히 설명하겠습니다. html 페이지가 변경될 때 페이지를 다시 렌더링해야 합니다. 자동 무효화할 파일의 &quot;버킷&quot;은 하나만 있습니다. 온몸이 다 빨개진다. 더 자세한 구조물들로 분해할 어떠한 수단도 없이.

자동 무효화가 기본적으로 &quot;.html&quot;(으)로 유지되는 좋은 이유가 있습니다. 목표는 그 양동이를 가능한 작게 유지하는 것이다. 목욕물로 아기를 버리지 마세요. 모든 것을 다 무효화해서 안전한 곳에 있기 위해서.

자체 포함된 리소스는 해당 리소스의 경로에 제공해야 합니다. 그것은 무효화에 많은 도움이 된다. 단순하게 유지하십시오. &quot;resource /a/b/c&quot;가 &quot;/x/y/z&quot;에서 제공되는 것과 같은 매핑 체계를 만들지 마십시오. 구성 요소가 기본 Dispatcher의 자동 무효화 설정으로 작동하도록 합니다. Dispatcher에서 오버무효화를 사용하여 잘못 디자인된 구성 요소를 복구하려고 하지 마십시오.

##### 자동 무효화에 대한 예외:리소스 전용 무효화

일반적으로 Dispatcher에 대한 무효화 요청은 복제 에이전트가 게시 시스템에서 실행됩니다.

종속성에 대해 매우 확신하는 경우 무효화된 복제 에이전트를 직접 구축하려고 할 수 있습니다.

세부 사항을 살펴보려면 이 안내서를 조금 벗어나야 하지만 몇 가지 힌트를 제공하고자 합니다.

1. 네가 뭘 하는지 정말 알아 무효화 권리를 얻는 것은 정말 어렵습니다. 그것이 자동 무효화가 그토록 엄격한 한 가지 이유이다.오래된 콘텐츠를 전달하지 않도록 합니다.

2. 에이전트가 HTTP-header `CQ-Action-Scope: ResourceOnly`를 보내는 경우 이 단일 무효화 요청이 자동 무효화를 트리거하지 않음을 의미합니다. 이( [https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle](https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle)) 코드 조각은 고유한 복제 에이전트의 시작 지점일 수 있습니다.

3. `ResourceOnly`는 자동 무효화만 방지합니다. 무효화를 해결하기 위한 필요한 종속성을 실제로 수행하려면 직접 무효화 요청을 트리거해야 합니다. 실제로 이러한 상황이 발생할 수 있는 방법에 대한 영감이 필요하면 패키지 Dispatcher 플러시 규칙([https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html](https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html))을 확인할 수 있습니다.

종속성 해결 체계를 구축하지 않는 것이 좋습니다. 노력도 많고 얻는 것도 별로 없고, 전에도 말했듯이, 여러분이 틀릴 수 있는 것은 너무 많습니다.

오히려, 다른 리소스에 대한 종속성이 없고 자동 무효화 없이 무효화할 수 있는 리소스를 찾아야 합니다. 하지만 이 문제에 대해 사용자 지정 복제 에이전트를 사용할 필요는 없습니다. 자동 무효화에서 이러한 리소스를 제외하는 사용자 지정 규칙을 Dispatcher 구성에서 만들면 됩니다.

기본 탐색 또는 티저가 종속성의 소스라고 했습니다. 음 - 탐색 및 티저를 비동기식으로 로드하거나 Apache에서 SSI 스크립트로 포함하는 경우 추적할 종속성이 없습니다. Sling Dynamic Includes에 대해 알려면 이 문서의 후반부에 구성 요소를 비동기식으로 로드하는 방법에 대해 자세히 설명하겠습니다.

팝업 창이나 Lightbox에 로드된 내용에 대해서도 마찬가지입니다. 이러한 조각은 탐색(즉, &quot;종속성&quot;)도 거의 없으며 단일 리소스로 무효화할 수 있습니다.

## Dispatcher를 염두에 두고 구성 요소 작성

### 실제 사례에서 Dispatcher 기법 적용

마지막 장에서는 Dispatcher의 기본 역학이 어떻게 작동되는지, 일반적으로 어떻게 작동되는지, 그리고 제한 사항이 무엇인지 설명했습니다.

이제 이러한 역학을 프로젝트의 요구 사항에서 찾을 수 있는 구성 요소에 적용하려고 합니다. 조만간 발생할 문제를 보여주기 위해 의도적으로 구성 요소를 선택합니다. 공포는 아니다 - 모든 구성요소들이 우리가 제시할 정도의 고려를 필요로 하는 것은 아니다. 그러나 그러한 구성 요소를 만들어야 하는 필요가 있다면, 여러분은 그 결과를 잘 알고 그것들을 처리하는 방법을 알고 있습니다.

### 스풀링 구성 요소(안티) 패턴

#### 응답형 이미지 구성 요소

연결된 바이너리가 있는 구성 요소의 공통 패턴(또는 패턴 방지)을 보여 줍니다. 응답형 이미지용 구성 요소 &quot;응답&quot;을 만듭니다. 이 구성 요소는 표시된 이미지를 표시된 장치에 조정할 수 있어야 합니다. 데스크톱 및 태블릿에서는 이미지의 전체 해상도를 표시하는 반면, 작은 크기의 휴대폰에서는 자르기가 약간 가능하거나, 심지어 완전히 다른 모티브(반응형 세상에서는 &quot;예술 방향&quot;이라고 함)를 제공합니다.

자산은 AEM의 DAM 영역에 업로드되며 응답형 이미지 구성 요소에서 _참조된_&#x200B;만 업로드합니다.

응답 구성 요소는 마크업의 렌더링과 이진 이미지 데이터 제공을 모두 처리합니다.

여기서 구현하는 방법은 많은 프로젝트에서 본 일반적인 패턴이며, AEM 핵심 구성 요소 중 하나까지도 해당 패턴을 기반으로 합니다. 따라서 개발자로서 여러분이 그 패턴을 조정할 가능성이 높습니다. 캡슐화에는 좋은 점이 있지만 Dispatcher를 지원하는 데 많은 노력이 필요합니다. 우리는 나중에 그 문제를 완화시킬 수 있는 몇 가지 방법에 대해 논의할 것이다.

문제가 Cookie 3의 초기부터 다시 시작되면서 이 패턴을 &quot;스풀 패턴&quot;이라고 합니다. 이 경우 리소스를 통해 2진 원시 데이터를 응답으로 스트리밍할 수 있는 &quot;스풀&quot; 메서드가 있었습니다.

원래 &quot;스풀링&quot;이라는 용어는 프린터와 같은 느린 오프라인 주변 장치를 공유하므로 여기에 제대로 적용되지 않습니다. 그러나 우리는 이 용어가 온라인 세계에서는 드물기 때문에 구별이 가능하기 때문에 좋아한다. 그리고 각 패턴에는 식별이 가능한 이름이 있어야 합니다. 그렇죠? 이것이 패턴인지 아니면 반패턴인지 결정하는 것은 여러분에게 달려 있습니다.

#### 구현

다음은 응답형 이미지 구성 요소를 구현하는 방법입니다.

그 구성 요소는 두 부분으로 구성되어 있다.첫 번째 부분은 이미지의 HTML 마크업을 렌더링하며 두 번째 부분은 참조된 이미지의 이진 데이터를 &quot;스풀&quot;합니다. 반응형 디자인을 갖는 최신 웹 사이트이므로 간단한 `<img src"…">` 태그를 렌더링하는 것이 아니라 `<picture/>` 태그에 있는 이미지 세트를 렌더링하고 있습니다. 각 장치에 대해 두 개의 서로 다른 이미지를 DAM에 업로드하고 이미지 구성 요소에서 참조합니다.

구성 요소에는 각각 전용 선택기로 지정된 세 개의 렌더링 스크립트(JSP, HTL 또는 서블릿으로 구현됨)가 있습니다.

1. `/respi.jsp` - HTML 태그를 렌더링할 선택기가 없음
2. `/respi.img.java` 데스크탑 버전을 렌더링하려면
3. `/respi.img.mobile.java` 모바일 버전을 렌더링합니다.


구성 요소는 홈 페이지의 parsys에 배치됩니다. CRX의 결과 구조가 아래에 나와 있습니다.

![CRX에서 응답형 이미지의 리소스 구조](assets/chapter-1/responsive-image-crx.png)

*CRX에서 응답형 이미지의 리소스 구조*

<br> 

구성 요소 마크업이 다음과 같이 렌더링됩니다.

```plain
  #GET /content/home.html

  <html>

  …

  <div class="responsive-image>

  <picture>
    <source src="/content/home/jcr:content/par/respi.img.mobile.jpg" …/>
    <source src="/content/home/jcr:content/par/respi.img.jpg …/>

    …

  </picture>
  </div>
  …
```

그리고... 우리는 잘 캡슐화된 구성 요소를 완성했습니다

#### 반응형 이미지 구성 요소 작동

이제 사용자가 Dispatcher를 통해 페이지 및 자산을 요청합니다. 이렇게 하면 다음과 같이 Dispatcher 파일 시스템에 파일이 생성됩니다.

![캡슐화된 응답형 이미지 구성 요소의 캐시된 구조](assets/chapter-1/cached-structure-encapsulated-image-comonent.png)

*캡슐화된 응답형 이미지 구성 요소의 캐시된 구조*

<br> 

사용자가 두 꽃 이미지의 새 버전을 DAM에 업로드하고 활성화하는 것을 고려해 보십시오. AEM은 다음에 대한 무효화 요청에 따라 을 보냅니다.

`/content/dam/flower.jpg`

및

`/content/dam/flower-mobile.jpg`

참조하십시오. 그러나 이런 요구들은 허영심이 있다. 컨텐츠가 구성 요소의 하위 구조 아래에 파일로 캐시되었습니다. 이러한 파일은 이제 사용되지 않지만 요청 시 계속 제공됩니다.

![구조 불일치로 인해 오래된 컨텐츠가 발생합니다](assets/chapter-1/structure-mismatch.png)

*구조 불일치로 인해 오래된 컨텐츠가 발생합니다*

<br> 

이 접근법에 또 다른 주의해야 할 사항이 있다. 여러 페이지에서 동일한 flower.jpg를 사용하는 것이 좋습니다. 그런 다음 여러 URL 또는 파일에 동일한 자산을 캐시합니다.

```
/content/home/products/jcr:content/par/respi.img.jpg

/content/home/offers/jcr:content/par/respi.img.jpg

/content/home/specials/jcr:content/par/respi.img.jpg

…
```

새로운 페이지와 캐시되지 않은 페이지를 요청할 때마다 자산을 다른 URL의 AEM에서 가져옵니다. 디스패처 캐싱이 없고 브라우저 캐싱이 배달 속도를 높일 수 없습니다.

#### 스풀러 패턴이 빛나는 위치

이 패턴은 간단한 형태로도 유용할 수 있는 한 가지 자연 예외가 있습니다.바이너리가 DAM이 아닌 구성 요소 자체에 저장되는 경우. 그러나 이 기능은 웹 사이트에서 한 번 사용되는 이미지에만 유용하며 DAM에 자산을 저장하지 않으므로 자산을 관리하는 데 어려움을 겪게 됩니다. 특정 자산에 대한 사용 라이선스가 초과되었다고 가정해 보십시오. 자산을 사용한 구성 요소를 어떻게 확인할 수 있습니까?

보여? DAM의 &quot;M&quot;은 디지털 자산 관리에서와 같이 &quot;관리&quot;를 의미합니다. 해당 기능을 배포하고 싶지 않습니다.

#### 결론

AEM 개발자의 관점에서 보면 그 패턴은 매우 우아해 보였다. 그러나 Dispatcher가 방정식을 취함에 따라 순진하게 대처하는 것으로는 충분하지 않을 수 있다는 것에 동의할지도 모릅니다.

우리는 이것이 지금으로서는 패턴인지 아니면 반패턴인지 결정하는 것을 당신에게 맡기겠습니다. 그리고 아마도 여러분은 이미 위에서 설명한 문제들을 어떻게 완화시킬 수 있는지 염두에 두고 좋은 생각들을 가지고 있을 지도 모릅니다. 좋아 그럼 다른 프로젝트들이 이 문제를 어떻게 해결했는지 보고 싶어하실 겁니다.

### 일반적인 Dispatcher 문제 해결

#### 개요

이것이 어떻게 좀 더 캐시 친화적으로 구현될 수 있었는지에 대해 이야기해 보겠습니다. 몇 가지 옵션이 있습니다. 때로는 가장 좋은 해결책을 선택할 수 없다. 이미 실행 중인 프로젝트에 참여하여 &quot;캐시 문제&quot;를 바로 수정할 수 있는 예산이 제한되어 있고 완전한 리팩터링을 수행할 수 없을 수도 있습니다. 문제가 발생할 수도 있습니다. 이는 예제 이미지 구성 요소보다 더 복잡합니다.

원칙 및 주의 사항에 대해서는 다음 섹션에서 설명합니다.

다시 말하면, 이것은 실제 경험을 기반으로 합니다. 우리는 이미 야생에서 그런 모든 패턴을 보았고 그것은 학문적인 운동이 아닙니다. 이것이 우리가 여러분에게 반패턴을 보여주고 있는 이유입니다. 그래서 여러분은 이미 다른 사람들이 저지른 실수로부터 배울 기회를 가지게 됩니다.

#### 캐시 킬러

>[!WARNING]
>
>이것은 반패턴이다. 사용하지 마십시오. 절대

`?ck=398547283745`과 같은 쿼리 매개 변수를 본 적이 있습니까? 이를 캐시 킬러(&quot;ck&quot;)라고 합니다. 즉, 쿼리 매개 변수를 추가하면 리소스가 캐시되지 않습니다. 또한 매개 변수의 값으로 난수를 추가하는 경우(&quot;398547283745&quot;처럼) URL이 고유해지고 AEM 시스템과 화면 사이에 다른 캐시가 없는지 확인합니다. 일반적으로 중간 용의자들은 Dispatcher, CDN 또는 브라우저 캐시 앞의 &quot;Varnish&quot; 캐시가 됩니다. 다시 한 번:그러지 마 리소스를 가능한 한 많이 캐시해야 합니다. 캐시는 친구입니다. 친구 죽이지 마

#### 자동 무효화

>[!WARNING]
>
>이것은 반패턴이다. 디지털 자산에 사용하지 마십시오. Dispatcher의 기본 구성을 유지하려고 합니다. 이 구성은 &quot;.html&quot; 파일의 자동 무효화입니다.

단기적으로 Dispatcher의 자동 무효화 구성에 &quot;.jpg&quot; 및 &quot;.png&quot;를 추가할 수 있습니다. 즉, 무효화가 발생할 때마다 모든 &quot;.jpg&quot;, &quot;.png&quot; 및 &quot;.html&quot;을 다시 렌더링해야 합니다.

이러한 패턴은 비즈니스 소유자가 라이브 사이트에서 변경 사항이 구현되지 않는 것을 충분히 빠르게 불평하는 경우 매우 쉽게 구현됩니다. 그러나 이것은 단지 더 복잡한 해결책을 생각해낼 시간을 줄 수 있습니다.

성능에 미치는 영향을 이해하십시오. 이렇게 하면 웹 사이트의 속도가 크게 느려지고 안정성에도 영향을 줄 수 있습니다. 뉴스 포털과 같이 빈번한 변경 사항이 있는 로드가 높은 웹 사이트인 경우.

#### URL 지문

URL 지문은 캐시 킬러처럼 보입니다. 하지만 그렇지 않아요 난수가 아니라 리소스의 내용을 설명하는 값입니다. 리소스 컨텐츠의 해시이거나 리소스를 업로드, 편집 또는 업데이트할 때의 타임스탬프일 수 있습니다.

Unix 타임스탬프는 실제 구현에 충분합니다. 가독성을 높이기 위해 이 자습서에서 보다 읽기 쉬운 형식을 사용하고 있습니다.`2018 31.12 23:59 or fp-2018-31-12-23-59`

지문을 쿼리 매개 변수와 함께 사용하는 URL로 사용하면 안 됩니다   캐시할 수 없습니다. 지문에 선택기 또는 접미사를 사용할 수 있습니다.

파일 `/content/dam/flower.jpg`에 2018년 12월 31일의 `jcr:lastModified` 날짜가 23:59라고 가정해 보겠습니다. 지문이 있는 URL은 `/content/home/jcr:content/par/respi.fp-2018-31-12-23-59.jpg`입니다.

참조된 리소스(`flower.jpg`) 파일이 변경되지 않는 한 이 URL은 안정적으로 유지됩니다. 그래서 그것은 무기한 캐싱될 수 있고 그것은 캐시 킬러가 아닙니다.

이 URL은 응답형 이미지 구성 요소에서 만들고 제공해야 합니다. 최신 AEM 기능은 아닙니다.

그것이 기본 개념입니다. 그러나 쉽게 간과될 수 있는 몇 가지 세부 사항이 있다.

이 예에서는 구성 요소가 23:59에 렌더링되고 캐시되었습니다. 이제 이미지가 변경되었다고 가정해 보겠습니다.  구성 요소 _은(는) 해당 마크업에 새로운 지문 URL을 생성합니다._

_에_&#x200B;이 있어야 한다고 생각하겠지만 그렇지 않습니다.이미지의 바이너리만 변경되고 포함 페이지가 터치되지 않았으므로 HTML 마크업을 다시 렌더링할 필요가 없습니다. 따라서 Dispatcher는 이전 지문 및 이전 버전의 이미지를 사용하여 페이지를 제공합니다.

![이미지 구성 요소가 참조된 이미지보다 최신 상태이며 새로운 지문 문서가 렌더링되지 않습니다.](assets/chapter-1/recent-image-component.png)

*이미지 구성 요소가 참조된 이미지보다 최신 상태이며 새로운 지문 문서가 렌더링되지 않습니다.*

<br> 

이제 홈 페이지(또는 해당 사이트의 다른 페이지)를 다시 활성화하면 상태 파일이 업데이트되며, Dispatcher는 home.html이 오래된 것으로 간주하여 이미지 구성 요소에 새 지문 파일을 사용하여 다시 렌더링합니다.

하지만 홈페이지는 활성화하지 않았죠? 그리고 왜 터치하지 않은 페이지를 활성화해야 합니까? 또한 페이지를 활성화할 수 있는 충분한 권한이 없거나 승인 작업 과정이 너무 길고 시간이 많이 소요되므로 예고 없이 이를 수행할 수 없습니다. 그럼 어떻게 하죠?

#### 레이지 관리자의 도구 - 상태 파일 수준 감소

>[!WARNING]
>
>이것은 반패턴이다. 단기간으로만 사용하면 시간을 내어 보다 정교한 솔루션을 만들 수 있습니다.

지연 관리자는 일반적으로 자동 무효화를 jpg로 설정하고 statfile-level을 0으로 설정하여 모든 종류의 캐싱 문제에 항상 도움이 됩니다&#x200B;_._ 기술 포럼에서 해당 조언을 확인할 수 있으며 무효화 문제에 도움이 됩니다.

지금까지 상태 파일 수준에 대해 논의하지 않았습니다. 기본적으로 자동 무효화는 동일한 하위 트리의 파일에 대해서만 작동합니다. 그러나 일반적으로 페이지와 자산이 동일한 하위 트리에 존재하지 않는다는 문제가 있습니다. 페이지는 `/content/mysite` 아래에 있지만 자산은 `/content/dam` 아래에 있습니다.

&quot;statfile level&quot;은 하위 트리의 깊이 루트 노드 위치를 정의합니다. 수준 위의 예에서 는 &quot;2&quot;(1=/content, 2=/mysite,dam)입니다.

상태 파일 수준을 0으로 &quot;감소&quot;하는 개념은 기본적으로 전체 /content 트리를 하나의 하위 트리로 정의하고 페이지와 자산을 동일한 자동 무효화 도메인에서 라이브로 만드는 것입니다. 따라서 수준(docroot &quot;/&quot;)에 있는 큰 트리만 가질 수 있습니다. 하지만 이렇게 하면 전혀 관련 없는 사이트에서도 게시될 때마다 서버의 모든 사이트가 자동으로 무효화됩니다. Adobe를 신뢰합니다.전반적인 캐시 적중률이 심각하게 낮아지기 때문에 장기적으로 보면 좋지 않은 생각입니다. AEM 서버가 캐시 없이 실행할 수 있는 충분한 화력이 있기를 바랍니다.

보다 나중에 보다 심층적인 상태 파일 수준의 전체 이점을 이해할 수 있습니다.

#### 사용자 지정 무효화 에이전트 구현

어쨌든, 새 URL로 다시 렌더링할 수 있도록 &quot;.jpg&quot; 또는 &quot;.png&quot;가 변경된 경우 Dispatcher에 명시적으로 알려야 합니다.

프로젝트에서 본 것은 예를 들어, 해당 사이트의 이미지가 게시될 때마다 사이트에 대한 무효화 요청을 보내는 게시 시스템의 특수 복제 에이전트입니다.

여기에서 명명 규칙으로 자산의 경로에서 사이트의 경로를 파생시킬 수 있는 경우 많은 도움이 됩니다.

일반적으로 다음과 같은 사이트 및 자산 경로를 일치시키는 것이 좋습니다.

**예**

```
/content/dam/site-a
/content/dam/site-b

/content/site-a
/content/site-b
```

이렇게 하면 사용자 지정 Dispatcher 플러시 에이전트가 `/content/dam/site-a`에 변경 사항이 발생하면 /content/site-a에 요청을 쉽게 보내고 무효화할 수 있습니다.

실제로 Dispatcher에 무효화하도록 하는 경로는 동일한 &quot;하위 트리&quot;에 있는 한 중요하지 않습니다. 실제 리소스 경로를 사용하지 않아도 됩니다. &quot;가상&quot;일 수도 있습니다.

`GET /dispatcher-invalidate
Invalidate-path /content/mysite/dummy`

![](assets/chapter-1/resource-path.png)

1. DAM의 파일이 변경되면 게시 시스템의 수신기가 트리거됩니다

2. 수신기가 Dispatcher에 무효화 요청을 보냅니다. 자동 무효화 때문에 사이트의 홈 페이지에 있거나 사이트 상태 파일 수준에서 더 정밀하지 않은 한 자동 무효화 시 보내는 경로는 문제가 되지 않습니다.

3. 상태 파일이 업데이트됩니다.

4. 다음에 홈 페이지가 요청되면 다시 렌더링됩니다. 새 지문/날짜를 이미지의 lastModified 속성에서 추가 선택기로 가져옵니다

5. 이렇게 하면 암시적으로 새 이미지에 대한 참조가 만들어집니다

6. 이미지가 실제로 요청되면 Dispatcher에 새 표현물이 만들어지고 저장됩니다


#### 청소의 필요성

휴. 완료됨. 만세!

음.. 아직..

경로,

`/content/mysite/home/jcr:content/par/respi.img.fp-2018-31-12-23-59.jpg`

은 무효화된 리소스와 관련이 없습니다. 기억? &quot;더미&quot; 리소스만 무효화하고 &quot;홈&quot;이 유효하지 않다고 간주하기 위해 자동 무효화에 의존합니다. 이미지 자체는 _물리적으로_&#x200B;삭제되지 않을 수 있습니다. 따라서 캐시는 확장되고 확장되며 확장됩니다. 이미지를 변경하고 활성화하면 Dispatcher의 파일 시스템에서 새 파일 이름이 제공됩니다.

캐시된 파일을 물리적으로 삭제하지 않고 무기한으로 유지하는 데에는 세 가지 문제가 있습니다.

1. 스토리지 용량을 낭비하고 있습니다. 허가됨 - 지난 몇 년 동안 저장 공간이 더 저렴해지고 저렴해졌다. 그러나 이미지 해상도와 파일 크기는 지난 몇 년 동안 커져왔다. 수정처럼 선명한 이미지를 많이 필요로 하는 망막과 같은 디스플레이가 출현했다.

2. 하드 드라이브가 가격이 낮아졌음에도 불구하고, &quot;저장&quot;이 더 싸지는 않을 것이다. BMR(Bare Metal HDD) 스토리지가 없는 반면, 데이터 센터 제공업체는 NAS에서 가상 스토리지를 대여하는 추세입니다. 이러한 종류의 스토리지는 안정적이고 확장 가능하지만 더욱 비용이 많이 듭니다. 오래된 쓰레기를 보관해서 낭비하고 싶지 않을 것이다. 이 기능은 운영 스토리지 뿐만 아니라 백업도 고려해야 합니다. 기본 제공 백업 솔루션이 있는 경우 캐시 디렉토리를 제외하지 못할 수 있습니다. 결국 가비지 데이터도 백업하게 됩니다.

3. 더 나쁜 것은특정 이미지에 필요한 기간 동안에만 해당 이미지에 대한 사용 라이선스를 구매했을 수 있습니다. 이제 라이센스가 만료된 후 이미지를 계속 저장하는 경우 저작권 침해로 보일 수 있습니다. 웹 페이지에서 이 이미지를 더 이상 사용하지 않을 수 있지만 Google에서는 여전히 이 이미지를 찾습니다.

마지막으로, 당신은 이 쓰레기 같은 것을 통제하기 위해 1주일을 말하는 것보다 오래된 모든 파일을 청소하는 약간의 관리업무를 떠올립니다.

#### URL 지문을 이용한 서비스 거부 공격

그러나 이 해결에는 또 다른 결함이 있습니다.

다음과 같이 선택기를 매개 변수로 사용합니다.fp-2018-31-12-23-59은 일종의 &quot;cache-killer&quot;로서 동적으로 생성됩니다. 그러나 지루했던 아이(또는 야생화된 검색 엔진 크롤러)가 페이지를 요청하기 시작할 수 있습니다.

```
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-00.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-01.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-02.jpg

…
```

각 요청은 Dispatcher를 무시하여 게시 인스턴스에 로드됩니다. 또한 - 더욱 심각한 것은 Dispatcher에 따라 파일을 만드는 것입니다.

따라서... 지문을 단순한 캐시 킬러로 사용하는 대신, jcr:lastModified 이미지 날짜를 확인하고 예상된 날짜가 아닌 경우 404를 반환해야 합니다. 게시 시스템에서 시간과 CPU 사이클이 소요되는데, 이는 처음부터 방지하려는 것입니다.

#### 빈도가 높은 릴리스의 URL 지문 경고

DAM에서 가져온 자산뿐만 아니라 JS 및 CSS 파일 및 관련 리소스에 대해서도 지문 스키마를 사용할 수 있습니다.

[버전이 ](https://adobe-consulting-services.github.io/acs-aem-commons/features/versioned-clientlibs/index.html) 지정된 Clientlibis는 이 방법을 사용하는 모듈입니다.

그러나 여기에서 URL 지문이 있는 또 다른 주의해야 할 사항이 있습니다.URL을 콘텐츠에 연결합니다. URL을 변경하지 않으면 컨텐츠를 변경할 수 없습니다(즉, 수정 날짜를 업데이트). 이것이 바로 그 지문이 애초에 고안되었던 것입니다. 그러나 새로운 CSS 및 JS 파일과 새로운 URL을 사용하여 새로운 릴리스를 준비하고 있다는 점을 고려해 보십시오. 모든 HTML 페이지에는 여전히 이전 지문 URL에 대한 참조가 있습니다. 따라서 새 릴리스가 일관되게 작동하려면 모든 HTML 페이지를 한 번에 무효화해야 새로 지문에 인쇄된 파일에 대한 참조로 다시 렌더링할 수 있습니다. 동일한 라이브러리에 의존하는 여러 사이트가 있는 경우, 이는 상당한 재렌더링이 될 수 있으며, 여기서 `statfiles`을(를) 활용할 수 없습니다. 따라서 롤아웃 후 게시 시스템에서 로드 최고점을 볼 수 있도록 준비하십시오. 캐시 온난화가 포함된 녹색 배포를 고려하거나 Dispatcher 앞에 있는 TTL 기반 캐시를 고려할 수 있습니다. 가능성은 무한합니다.

#### 짧은 휴식

와 - 그건 꽤 많은 세부사항들이 고려되어야 할 것 같은데, 그렇지? 그리고 그것은 이해되고, 테스트되고, 쉽게 디버깅하기를 거부합니다. 그리고 겉보기에 우아한 해결책 이것은 우아하지만 AEM 전용 관점에서만 가능하다. 디스패처와 함께 이 디스패처는 불쾌하게 됩니다.

그리고 여전히 - 하나의 기본 문제를 해결하지 않습니다. 이미지가 다른 페이지에서 여러 번 사용되는 경우 해당 페이지 아래에 캐시됩니다. 그곳에는 많은 캐싱 시너지 효과가 없습니다.

일반적으로 URL 지문은 툴킷에 사용할 수 있는 좋은 도구이지만 몇 가지 기존 문제를 해결하는 동시에 새로운 문제를 일으킬 수 있으므로 신중하게 적용해야 합니다.

그래서... 그건 긴 장. 하지만 우리는 이 패턴을 아주 자주 보았고, 그래서 우리는 당신에게 모든 장단점을 가지고 전체적인 그림을 주는 것이 필요하다고 느꼈다. URL 지문을 사용하면 스풀러 패턴에서 몇 가지 문제를 해결할 수 있지만 구현하려는 노력이 매우 높으므로 다른 해결 방법도 고려해야 합니다. 제공된 리소스 경로에 따라 URL을 기반으로 할 수 있고 중간 구성 요소가 없는지 항상 확인하는 것이 좋습니다. 우리는 다음 장에서 이것을 할 것이다.

##### 런타임 종속성 해결

런타임 종속성 해결은 하나의 프로젝트에서 고려해왔던 개념입니다. 하지만 그것을 통해 생각하는 것은 꽤 복잡했고, 우리는 그것을 시행하지 않기로 결정했다.

다음은 기본 생각이다.

Dispatcher는 리소스의 종속성에 대해 알지 못합니다. 그것은 단지 약간의 의미 체계를 가진 한 묶음의 파일들입니다.

AEM은 종속성에 대해서도 거의 알지 못합니다. 적절한 의미 체계 또는 &quot;종속성 추적기&quot;가 없습니다.

AEM은 일부 참조를 인식합니다. 이 지식을 사용하여 참조된 페이지나 자산을 삭제하거나 이동하려고 할 때 경고합니다. 자산을 삭제할 때 내부 검색을 쿼리하여 이렇게 합니다. 컨텐츠 참조에는 매우 특별한 양식이 있습니다. &quot;/content&quot;로 시작하는 경로 표현식입니다. 따라서 전체 텍스트 색인화를 쉽게 수행할 수 있으며 필요한 경우 쿼리할 수 있습니다.

이 경우 게시 시스템에 해당 경로가 변경될 때 특정 경로에 대한 검색을 트리거하는 사용자 지정 복제 에이전트가 필요합니다.

예,

`/content/dam/flower.jpg`

게시 시 변경되었습니다. 에이전트가 &quot;/content/dam/flower.jpg&quot;에 대한 검색을 실행하고 해당 이미지를 참조하는 모든 페이지를 찾습니다.

그런 다음 Dispatcher에 많은 무효화 요청을 발행할 수 있습니다. 자산이 들어 있는 각 페이지에 대해 하나.

이론적으로, 그것은 작동해야 한다. 첫 번째 수준의 종속성에 대해서만 예를 들어 페이지에서 사용되는 경험 조각에서 이미지를 사용하는 경우 다중 수준 종속성에 이 체계를 적용하지 않을 수 있습니다. 사실, 우리는 접근 방식이 너무 복잡하다고 믿고 있습니다. 런타임 문제가 있을 수 있습니다. 그리고 일반적으로 가장 좋은 조언은 이벤트 핸들러에서 값비싼 컴퓨팅을 하지 않는 것입니다. 그리고 특히 수색하는 것은 꽤 비용이 많이 들 수 있습니다.

##### 결론

구현에서 스풀러 패턴을 사용하고 사용하지 않을 시기를 결정할 수 있을 만큼 스풀러 패턴에 대해 충분히 논의했으면 합니다.

## Dispatcher 문제 방지

### 리소스 기반 URL

의존성 문제를 해결하는 보다 우아한 방법은 종속성이 전혀 없는 것입니다. 마지막 예에서처럼 한 리소스를 사용하여 다른 리소스를 단순히 프록시할 때 발생하는 인공 종속성을 방지합니다. 리소스를 가능한 한 자주 &quot;독방&quot; 개체로 보도록 하세요.

이 예는 쉽게 해결됩니다.

![구성 요소가 아니라 이미지에 바인딩된 서블릿으로 이미지를 스풀링합니다.](assets/chapter-1/spooling-image.png)

*구성 요소가 아니라 이미지에 바인딩된 서블릿으로 이미지를 스풀링합니다.*

<br> 

데이터를 렌더링하기 위해 자산 원래 리소스 경로를 사용합니다. 원본 이미지를 그대로 렌더링해야 하는 경우에는 자산에 AEM 기본 렌더러를 사용할 수 있습니다.

특정 구성 요소에 대해 특수 처리를 수행해야 하는 경우 해당 경로에 전용 서블릿을 등록하고 구성 요소를 대신하여 변환을 수행할 선택기를 등록합니다. 우리는 여기서 &quot;.responsive&quot;를 사용하여 그것을 모범적으로 했습니다. 선택기. 글로벌 URL 공간(예: `/content/dam`)에서 사용되는 선택기 이름을 추적하고 이름 충돌을 방지하기 위해 올바른 이름 지정 규칙을 사용하는 것이 좋습니다.

그런데, 코드 일관성에 문제가 있는 것은 없습니다. 서블릿은 구성 요소 sling 모델과 동일한 Java 패키지에서 정의할 수 있습니다.

글로벌 공간에서 다음과 같은 추가 선택기를 사용할 수도 있습니다.

`/content/dam/flower.respi.thumbnail.jpg`

진정해, 그렇지? 그러면 왜 스풀러와 같은 복잡한 패턴들을 생각해내죠?

외부 컴포넌트가 내부 리소스의 렌더링에 대한 값이나 정보를 거의 추가하지 않아, 단일 리소스의 표현을 제어하는 정적 선택기 집합에서 쉽게 인코딩될 수 있기 때문에 내부 컨텐츠 참조를 피하는 문제를 해결할 수 있었습니다.

그러나 리소스 기반 URL로 쉽게 해결할 수 없는 사례 클래스가 있습니다. 이러한 유형의 경우 &quot;Parameter Inserting Components&quot;라고 하며 다음 장에서 설명합니다.

### 매개변수 구성 요소 삽입

#### 개요

마지막 장의 스풀러는 리소스 주위의 얇은 래퍼였습니다. 그것은 그 문제를 해결하는 데 도움을 주는 것보다 더 많은 문제를 일으켰다.

간단한 선택기를 사용하여 해당 래핑을 쉽게 대체하고 그에 따라 서블릿을 추가하여 이러한 요청을 제공할 수 있습니다.

하지만 &quot;응답&quot; 구성 요소가 단순히 프록시 이상이라면 어떻게 할까요? 구성 요소가 구성 요소의 렌더링에 진정으로 기여하는 경우 어떻게 합니까?

우리의 &quot;응답&quot; 구성 요소의 작은 확장을 소개하겠습니다. 그것은 약간 게임 체인저입니다. 다시 한번, 우리는 새로운 도전들을 해결하고 그들이 어디에서 떨어져 있는지를 보여줄 수 있는 몇 가지 솔직한 해결책을 먼저 도입할 것입니다.

#### Response2 구성 요소

responsive2 구성 요소는 응답형 이미지를 표시하는 구성 요소입니다. 이 응답 구성 요소 와 같습니다. 하지만 약간의 추가 기능이 있습니다

![CRX 구조:게재에 품질 속성을 추가하는 response2 구성 요소](assets/chapter-1/respi2.png)

*CRX 구조:게재에 품질 속성을 추가하는 response2 구성 요소*

<br> 

이미지는 jpeg이고 jpeg를 압축할 수 있습니다. jpeg 이미지를 압축하면 파일 크기에 대한 품질을 교환합니다. 압축은 &quot;1&quot;에서 &quot;100&quot; 사이의 숫자 &quot;품질&quot; 매개 변수로 정의됩니다. &#39;1&#39;은 작지만 품질이 떨어지는 &#39;100&#39;이란 뜻이고, &#39;100&#39;은 &#39;우수하지만 대용량 파일&#39;을 뜻한다. 그렇다면 어떤 것이 완벽한 가치일까요?

모든 IT와 마찬가지로, 대답은 다음과 같습니다.&quot;상황에 따라 다릅니다.&quot;

모티브에 따라 다릅니다 텍스트, 건물의 사진, 일러스트레이션, 스케치, 제품 상자의 사진 등 모티브가 있는 모티브는 일반적으로 해당 범주에 속합니다(윤곽선이 날카롭고 텍스트가 적혀 있음). 더 부드러운 색상 및 대조 전환이 있는 모티브는 가시적인 품질 손실 없이 조금 더 압축될 수 있습니다. 자연사진은 보통 그 범주에 속한다.

또한 - 이미지가 사용되는 위치에 따라 다른 매개 변수를 사용할 수도 있습니다. Teaser의 작은 축소판은 화면 전체 히어로 배너에 사용된 것과 동일한 이미지보다 더 나은 압축을 견딜 수 있습니다. 즉, 품질 매개 변수는 이미지가 아니라 이미지와 컨텍스트에 따라 달라집니다. 그리고 저자의 취향에

간단히 말해:모든 사진에 완벽한 설정이 없습니다. 딱 맞는 사이즈는 없습니다. 저자가 결정하는 것이 최선이다. 품질에 만족할 때까지 &quot;quality&quot; 매개 변수를 구성 요소에서 속성으로 조정하며 대역폭을 희생하지 않습니다.

이제 DAM과 구성 요소에 품질 속성을 제공하는 이진 파일이 있습니다. URL은 어떻게 표시되어야 합니까? 스풀링을 담당하는 구성 요소는 무엇입니까?

#### 순진하게 접근 방법 1:속성을 쿼리 매개 변수로 전달

>[!WARNING]
>
>이것은 반패턴이다. 사용하지 마십시오.

마지막 장에서는 구성 요소가 렌더링한 이미지 URL은 다음과 같이 표시되었습니다.

`/content/dam/flower.respi.jpg`

없는 것은 품질에 대한 값뿐이다. 구성 요소는 작성자가 입력한 속성을 알고 있습니다.. `flower.respi2.jpg?quality=60` 과 같이 마크업을 렌더링할 때 이미지 렌더링 서블릿에 쿼리 매개 변수로 쉽게 전달할 수 있습니다.

```plain
  <div class="respi2">
  <picture>
    <source src="/content/dam/flower.respi2.jpg?quality=60" …/>
    …
  </picture>
  </div>
  …
```

이건 나쁜 생각이다. 기억? 쿼리 매개 변수를 사용하는 요청은 캐시할 수 없습니다.

#### Naive 접근 방법 2:추가 정보를 선택기로 전달

>[!WARNING]
>
>이것이 반패턴이 될 수도 있다. 잘 쓰세요.

![구성 요소 속성을 선택기로 전달](assets/chapter-1/passing-component-properties.png)

*구성 요소 속성을 선택기로 전달*

<br> 

마지막 URL의 약간 변형입니다. 현재는 선택기를 사용하여 결과가 캐시될 수 있도록 속성을 서블릿에 전달합니다.

`/content/dam/flower.respi.q-60.jpg`

이게 훨씬 낫긴 한데, 이런 패턴을 잘 아는 마지막 장의 악독한 대본배우는 기억나? 그는 값에 대한 반복으로 얼마나 멀리 갈 수 있는지를 볼 것입니다.

```plain
  /content/dam/flower.respi.q-60.jpg
  /content/dam/flower.respi.q-61.jpg
  /content/dam/flower.respi.q-62.jpg
  /content/dam/flower.respi.q-63.jpg
  …
```

캐시를 무시하고 게시 시스템에 로드를 만듭니다. 그래서, 그것은 나쁜 생각일지도 모릅니다. 작은 매개 변수만 필터링하여 이를 줄일 수 있습니다. `q-20, q-40, q-60, q-80, q-100`만 허용하려는 경우

#### 선택기를 사용할 때 잘못된 요청 필터링

선택기를 줄이는 것이 좋은 시작이었다. 경험상 항상 유효한 매개 변수의 수를 절대 최소로 제한해야 합니다. 이러한 경우 기본 AEM 시스템에 대한 깊은 지식이 없는 정적 필터 세트를 사용하여 AEM 외부의 웹 애플리케이션 방화벽을 활용하여 시스템을 보호할 수 있습니다.

`Allow: /content/dam/(-\_/a-z0-9)+/(-\_a-z0-9)+
\.respi\.q-(20|40|60|80|100)\.jpg`

웹 애플리케이션 방화벽이 없는 경우 Dispatcher 또는 AEM 자체에서 필터링해야 합니다. AEM에서 하는 경우 다음을 확인하십시오

1. 필터는 CRX에 너무 많이 액세스하고 메모리와 시간을 낭비하지 않고 매우 효율적으로 구현됩니다.

2. 필터가 &quot;404 - 찾을 수 없음&quot; 오류 메시지에 응답합니다

마지막 점을 다시 강조합시다. HTTP 대화는 다음과 같습니다.

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 404 – Not found
  << empty response body >>
```

잘못된 매개 변수를 필터링했지만 잘못된 매개 변수를 사용할 때 유효한 대체 렌더링을 반환한 구현도 보았습니다. 20~100의 매개 변수만 허용한다고 가정해 보겠습니다. 사이의 값이 유효한 값에 매핑됩니다. 그래서

`q-41, q-42, q-43, …`

은 q-40과 동일한 이미지에 항상 응답합니다.

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 200 – OK
  << flower.jpg with quality = 40 >>
```

그 접근법은 전혀 도움이 되지 않는다. 이러한 요청은 실제로 유효한 요청입니다.  처리 능력을 사용하고 Dispatcher의 캐시 디렉토리에서 공간을 사용합니다.

`301 – Moved permanently`을 반환하는 것이 좋습니다.

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 301 – Moved permanently
  Location: /content/dam/flower.respi.q-40.jpg
```

여기서 AEM은 브라우저에 알려줍니다. &quot;`q-41`이 없습니다. 하지만, `q-40`&quot;에 대해 물어보세요.

이렇게 하면 대화에 추가 요청 응답 루프가 추가되는데, 이는 약간 오버헤드지만 `q-41`에서 전체 처리를 수행하는 것보다 비용이 저렴합니다. 또한 `q-40` 아래에 이미 캐시된 파일을 활용할 수 있습니다. Dispatcher에서 302 응답이 캐시되지 않는다는 것을 이해해야 합니다. 우리는 AEM에서 실행되는 논리에 대해 이야기하고 있습니다. 계속 반복해 그래서 슬림하고 빨리 만드는 게 좋을 거야.

우리는 개인적으로 404가 가장 응답하는 것을 좋아한다. 그것은 무슨 일이 일어나고 있는지 아주 분명하게 만듭니다. 또한 로그 파일을 분석할 때 웹 사이트에서 오류를 감지하는 데 도움이 됩니다. 301은 404가 항상 분석 및 제거되어야 하는 의도일 수 있습니다.

## 보안 - 출시

### 요청 필터링

#### 필터를 가장 잘 필터링할 위치

마지막 장의 끝에서 우리는 알려진 선택기에 대해 들어오는 트래픽을 필터링해야 한다고 지적했다. 그렇다면 의문이 생긴다.요청을 실제로 필터링하려면 어디에서 해야 합니까?

상황에 따라 다릅니다 빠를수록 좋다.

#### 웹 응용 프로그램 방화벽

웹 보안을 위해 설계된 웹 응용 프로그램 방화벽 기기 또는 &quot;WAF&quot;가 있는 경우 이러한 기능을 반드시 활용해야 합니다. 그러나 WAF는 컨텐츠 애플리케이션에 대해 제한된 지식만 있는 사람이 운영하고 있으며 유효한 요청을 필터링하거나 너무 많은 유해 요청을 전달한다는 사실을 알게 될 수도 있습니다. 아마 WAF를 운영하는 사람들이 서로 다른 근무조와 릴리스 일정이 있는 다른 부서에 할당되어 있다는 사실을 알게 될 것입니다. 즉, 직접 팀원들과 커뮤니케이션이 그리 긴밀하지 않을 수도 있고, 시간에 따른 변화가 항상 일어나는 것은 아니라는 사실을 알게 될 것입니다. 즉, 사용자의 개발 및 컨텐츠 속도가 문제가 된다는 의미입니다.

어떤 일반적인 규칙이나 심지어 여러분의 직감에서 말하는 차단 목록에 추가하다, 여러분의 확신 또한 강화될 수 있는 것으로 끝날 것입니다.

#### 디스패처 및 게시 필터링

다음 단계는 Apache 코어 및/또는 Dispatcher에서 URL 필터링 규칙을 추가하는 것입니다.

여기서는 URL에만 액세스할 수 있습니다. 패턴 기반 필터로 제한됩니다. 컨텐츠 기반 필터링을 더 설정해야 하거나(올바른 타임스탬프만 있는 파일 허용 등) 필터링을 제어하려는 경우 사용자 지정 서블릿 필터와 같은 필터링을 만들어야 합니다.

#### 모니터링 및 디버깅

실제로 각 수준에 몇 가지 보안이 있습니다. 그러나 요청이 필터링된 수준을 확인할 수 있는 방법이 있는지 확인하십시오. 게시 시스템, Dispatcher 및 WAF의 로그 파일에 직접 액세스하여 체인에서 요청을 차단하는 필터를 찾을 수 있는지 확인합니다.

### 선택기 및 선택기 증식

마지막 장에서 &quot;selector-parameters&quot;를 사용하는 접근 방식은 빠르고 간단하며 새 구성 요소의 개발 시간을 단축할 수 있지만, 제한은 있습니다.

&quot;quality&quot; 속성을 설정하는 것은 간단한 예일 뿐입니다. 하지만 예를 들어 서블릿은 &quot;width&quot;에 대한 매개 변수도 보다 다용성이 있기를 바랍니다.

가능한 선택기 값 수를 줄여서 유효한 URL의 수를 줄일 수 있습니다. 너비로 동일한 작업을 수행할 수도 있습니다.

quality = q-20, q-40, q-60, q-80, q-100

width = w-100, w-200, w-400, w-800, w-1000, w-1200

그러나 이제 모든 조합이 유효한 URL입니다.

```
/content/dam/flower.respi.q-40.w-200.jpg
/content/dam/flower.respi.q-60.w-400.jpg
…
```

이제 한 리소스에 대해 유효한 5x6=30개의 URL이 이미 있습니다. 각 추가 속성은 복잡성에 추가됩니다. 또한 적절한 양의 값으로 줄일 수 없는 특성이 있을 수 있습니다.

그래서 이 접근법은 한계가 있습니다.

#### 실수로 API를 노출함

여기서 무슨 일이 일어나고 있습니까? 자세히 살펴보면, 우리는 정적으로 렌더링된 웹 사이트에서 점차 역동적인 웹 사이트로 이동하고 있습니다. 또한 작성자만 사용하도록 실제로 만들어진 이미지 렌더링 API를 고객의 브라우저에 의도하지 않게 표시했습니다.

이미지의 품질 및 크기 설정은 작성자가 페이지를 편집해야 합니다. 서블릿에 의해 노출된 동일한 기능이 있으면 서비스 거부 공격에 대한 기능 또는 벡터로 볼 수 있습니다. 사실 그것은 상황에 따라 다릅니다. 웹 사이트는 비즈니스 측면에서 얼마나 중요합니까? 서버에 로드 양이 얼마나 됩니까? 헤드룸은 얼마나 남았나요? 구현을 위한 예산은 얼마나 됩니까? 당신은 이 요인들을 균형을 맞추어야 한다. 당신은 장단점을 알아야 한다.

## 스풀러 패턴 - 재방문 및 재활

### 스풀러가 API를 노출하지 않는 방법

마지막 장에서 스풀러 패턴을 약간 의심했어요 그것을 회복시킬 시간이다.

![](assets/chapter-1/spooler-pattern.png)

스풀러 패턴은 마지막 장에서 설명한 API를 노출할 때 문제가 발생하지 않습니다. 속성은 구성 요소에 저장되고 캡슐화됩니다. 이러한 속성에 액세스하면 구성 요소의 경로가 됩니다. 마크업과 이진 렌더링 간에 매개 변수를 전송하기 위해 URL을 수단으로 사용할 필요는 없습니다.

1. 클라이언트는 구성 요소가 기본 요청 루프 내에서 요청되면 HTML 마크업을 렌더링합니다

2. 구성 요소 경로는 구성 요소에 대한 마크업에서 역참조 역할을 합니다

3. 브라우저는 이 역참조를 사용하여 바이너리를 요청합니다

4. 요청이 구성 요소에 도달하면 이진 데이터의 크기 조정, 압축 및 스풀링을 위한 모든 특성이 손에 있습니다

5. 이미지는 구성 요소를 통해 클라이언트 브라우저로 전송됩니다

스풀러 패턴이 나쁘진 않아 그래서 인기가 많아요 캐시 무효화와 관련하여 그렇게 번거롭지 않은 경우에만

### 반전된 스풀러 - 두 세계 중 최고야?

그것은 우리에게 질문을 불러옵니다. 왜 우리는 양쪽 세계 중에서 최고만 얻을 수 없을까요? 스풀러 패턴을 캡슐화하고 리소스 기반 URL의 올바른 캐싱 속성을 캡슐화하시겠습니까?

우리는 우리가 실제 실제 실물 프로젝트에서 그것을 보지 않았다는 것을 인정해야만 합니다. 그러나 우리는 어쨌든, 여러분 자신의 해결책을 위한 시작점으로 여기에서의 작은 사고 실험을 해보도록 합시다.

이 패턴을 _반전된 스풀러_&#x200B;라고 합니다. 반전된 스풀러는 모든 멋진 캐시 무효화 속성을 갖도록 이미지 리소스를 기반으로 해야 합니다.

그러나 매개 변수를 노출해서는 안 됩니다. 모든 속성은 구성 요소에 캡슐화되어야 합니다. 그러나 구성 요소 경로를 속성에 대해 불투명한 참조로 표시할 수 있습니다.

그러면 양식의 URL이 됩니다.

`/content/dam/flower.respi3.content-mysite-home-jcrcontent-par-respi.jpg`

`/content/dam/flower` 은 이미지 리소스의 경로입니다

`.respi3` 은 이미지를 전달할 올바른 서블릿을 선택하는 선택기입니다

`.content-mysite-home-jcrcontent-par-respi` 는 추가 선택기입니다. 이미지 변환에 필요한 속성을 저장하는 구성 요소에 대한 경로를 인코딩합니다. 선택기는 경로보다 작은 문자 범위로 제한됩니다. 여기에 나오는 부호화 방식은 단지 예시적인 것이다. &quot;/&quot;를 &quot;-&quot;로 대체합니다. 경로 자체에도 &quot;-&quot;가 포함될 수 있다는 점을 고려하지 않습니다. 좀 더 정교한 부호화 방식이 있으면 실제의 예에서 볼 수 있다. Base64는 괜찮을 것입니다. 하지만 디버깅을 좀 더 어렵게 만듭니다.

`.jpg` 파일 접미사입니다.

### 결론

와스풀러 얘기가 생각보다 더 길고 복잡해졌어요 우리는 너에게 변명을 해야 한다. 그러나 우리는 디스패처 랜드에서는 무엇이 잘 작동하고 무엇이 잘 되지 않는지에 대해 어떤 직관력을 얻을 수 있도록 좋은 것과 나쁜 것의 복합적인 면을 당신에게 보여주는 것이 필요하다고 생각했습니다.

## 상태 파일 및 상태 파일 수준

### 기본 사항

#### 소개

전에 _statfile_&#x200B;에 대해 간단히 언급했습니다. 자동 무효화와 관련되어 있습니다.

자동 무효화되도록 구성된 Dispatcher 파일 시스템의 모든 캐시 파일은 마지막 수정 날짜가 `statfile's` 마지막 수정 날짜보다 오래된 경우 잘못된 것으로 간주됩니다.

>[!NOTE]
>
>마지막으로 수정한 날짜는 캐싱된 파일이 클라이언트의 브라우저에서 파일을 요청하여 파일 시스템에서 최종적으로 생성된 날짜입니다. 리소스의 `jcr:lastModified` 날짜가 아닙니다.

상태 파일(`.stat`)의 마지막 수정 날짜는 AEM에서 Dispatcher에 무효화 요청을 받은 날짜입니다.

Dispatcher가 두 개 이상 있는 경우 이상한 효과가 발생할 수 있습니다. 브라우저에 Dispatcher 최신 버전이 있을 수 있습니다(Dispatcher가 두 개 이상 있는 경우). 또는 Dispatcher는 다른 Dispatcher에서 발급한 브라우저 버전이 오래된 버전이며 새 복사본을 불필요하게 전송한다고 생각할 수 있습니다. 이러한 효과는 성능 또는 기능 요구 사항에 큰 영향을 주지 않습니다. 그리고 시간이 지남에 따라 브라우저에서 최신 버전이 있을 때 표시됩니다. 그러나 브라우저 캐싱 동작을 최적화하고 디버깅하는 경우 약간 혼동될 수 있습니다. 그러니 주의하세요.

#### /statfileslevel을 사용하여 무효화 도메인 설정

자동 무효화 및 우리가 말한 상태 파일을 도입했을 때, *모든* 파일은 변경이 있을 때 유효하지 않은 것으로 간주되며 모든 파일은 어쨌든 상호 종속되어 있습니다.

그건 정확하지 않아요 일반적으로 일반적인 기본 탐색 루트를 공유하는 모든 파일은 상호 종속적입니다. 그러나 하나의 AEM 인스턴스는 다양한 웹 사이트(*독립* 웹 사이트)를 호스팅할 수 있습니다. 공통 탐색을 공유하지 않음 - 실제로 공유하지 않음.

사이트 A에 변화가 있기 때문에 사이트 B를 무효화하는 것은 낭비되지 않을까요? 네, 그렇습니다. 그리고 그렇게 될 필요는 없습니다.

Dispatcher는 사이트를 서로 구분하는 간단한 방법을 제공합니다.`statfiles-level`

파일 시스템의 수준을 정의하는 숫자로서 두 개의 하위 트리가 &quot;독립적&quot;으로 간주됩니다.

상태 파일 수준이 0인 기본 사례를 살펴보겠습니다.

![/statfileslevel &quot;0&quot;:docroot에서  __.stat_ _가 만들어집니다. 무효화 도메인은 모든 사이트](assets/chapter-1/statfile-level-0.png)을 포함하는 전체 설치에 걸쳐 있습니다

`/statfileslevel "0":` 파일 `.stat` 이 docroot에 만들어집니다. 무효화 도메인은 모든 사이트를 포함한 전체 설치를 포괄합니다.

무효화된 파일 중 어느 것이든 디스패처 docroot의 맨 위에 있는 `.stat` 파일이 항상 업데이트됩니다. 따라서 `/content/site-b/home`을 무효화하면 이제 docroot의 `.stat` 파일보다 오래되므로 `/content/site-a`의 모든 파일도 무효화됩니다. `site-b`을 무효화할 때 필요한 것이 명확히 아닙니다.

이 예제에서는 `statfileslevel`을 `1`(으)로 설정하는 것이 좋습니다.

이제 게시 - 따라서 `/content/site-b/home` 또는 `/content/site-b` 아래의 다른 리소스를 무효화하는 경우 `.stat` 파일이 `/content/site-b/`에 만들어집니다.

`/content/site-a/` 아래의 콘텐츠는 영향을 받지 않습니다. 이 콘텐츠는 `/content/site-a/`에 있는 `.stat` 파일과 비교됩니다. 두 개의 별도의 무효화 도메인을 만들었습니다.

![상태 파일 수준 &quot;1&quot;은 서로 다른 무효화 도메인을 만듭니다](assets/chapter-1/statfiles-level-1.png)

*상태 파일 수준 &quot;1&quot;은 서로 다른 무효화 도메인을 만듭니다*

<br> 

대규모 설치는 일반적으로 좀 더 복잡하고 더 깊이 구성되어 있습니다. 일반적인 체계는 브랜드, 국가 및 언어별로 사이트를 구성하는 것입니다. 이 경우 상태 파일 수준을 더 높게 설정할 수 있습니다. _1_ 은 브랜드당 무효화 도메인,  _국가별_ 2 _및 언어당_ 3을 만듭니다.

### 균질부위의 필요성

상태 파일 수준은 설정의 모든 사이트에 동일하게 적용됩니다. 따라서 동일한 구조를 따르는 모든 사이트가 있고 동일한 수준에서 시작해야 합니다.

포트폴리오에 몇몇 브랜드만 판매하는 반면 다른 브랜드들은 전 세계적으로 판매되고 있다는 점을 고려해 보십시오. 작은 시장들은 세계 시장에서 하나의 지역 언어만을 가지고 있는 반면, 둘 이상의 언어가 사용되는 나라들은 있습니다.

```plain
  /content/tiny-local-brand/finland/home
  /content/tiny-local-brand/finland/products
  /content/tiny-local-brand/finland/about
                              ^
                          /statfileslevel "2"
  …

  /content/tiny-local-brand/norway
  …

  /content/shiny-global-brand/canada/en
  /content/shiny-global-brand/canada/fr
  /content/shiny-global-brand/switzerland/fr
  /content/shiny-global-brand/switzerland/de
  /content/shiny-global-brand/switzerland/it
                                          ^
                                /statfileslevel "3"
  ..
```

전자는 _2_&#x200B;의 `statfileslevel`이 필요하지만, 후자는 _3_&#x200B;가 필요합니다.

이상적 상황이 아닙니다 _3_&#x200B;로 설정한 경우 자동 무효화는 하위 분기 `/home`, `/products` 및 `/about` 사이의 작은 사이트 내에서 작동하지 않습니다.

_2_&#x200B;로 설정하면 더 큰 사이트에서 `/canada/en` 및 `/canada/fr` 종속 항목을 선언할 수 있으며, 그렇지 않을 수도 있습니다. 따라서 `/en`의 각 무효화는 `/fr`도 무효화됩니다. 이로 인해 캐시 적중률이 약간 낮아지지만, 오래된 캐시된 컨텐츠를 제공하는 것보다 더 좋습니다.

가장 좋은 방법은 모든 사이트의 뿌리를 균등하게 깊게 하는 것입니다.

```
/content/tiny-local-brand/finland/fi/home
/content/tiny-local-brand/finland/fi/products
/content/tiny-local-brand/finland/fi/about
…
/content/tiny-local-brand/norway/no/home
                                 ^
                        /statfileslevel "3"
```

### 사이트 간 연결

지금 어느 정도가 맞는 가요? 사이트 간에 있는 종속성 수에 따라 다릅니다. 페이지 렌더링을 위해 확인하는 포함 은 &quot;하드 종속성&quot;으로 간주됩니다. 이 안내서의 시작 부분에 _Teaser_ 구성 요소를 도입했을 때 이러한 _포함_&#x200B;을 시연했습니다.

__ Hyperlinks는 더 부드러운 형태의 종속입니다. 하나의 웹 사이트 내에서 하이퍼링크가 발생할 가능성이 높고 웹 사이트 간에 링크가 있을 가능성은 낮습니다. 단순 하이퍼링크는 일반적으로 웹 사이트 간에 종속성을 만들지 않습니다. 사이트에서 facebook으로 설정한 외부 링크를 생각해 보십시오.facebook에서 변경된 사항이 있거나 그 반대의 경우 페이지를 렌더링하지 않아도 됩니다.

연결된 리소스의 컨텐츠(예: 탐색 제목)를 읽을 때 종속성이 발생합니다. 로컬에서 입력한 탐색 제목을 사용하고 대상 페이지에서 가져오지 않는 경우(외부 링크에서처럼) 이러한 종속성을 방지할 수 있습니다.

#### 예기치 않은 종속성

그러나 설정 중 일부가 있을 수 있으며, 여기에서 - 독립된 - 사이트가 함께 제공됩니다. 우리가 우리의 프로젝트 중 하나에서 우연히 발견한 실세계의 시나리오를 봅시다.

고객은 마지막 장에서 스케치한 사이트와 같은 사이트 구조를 가졌습니다.

```
/content/brand/country/language
```

예,

```
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de

/content/shiny-brand/france/fr

/content/shiny-brand/germany/de
```

각 나라마다 고유의 도메인이 있고

```
www.shiny-brand.ch

www.shiny-brand.fr

www.shiny-brand.de
```

언어 사이트 간에 탐색 가능한 링크와 표시 가능한 포함이 없으므로 상태 파일 수준을 3으로 설정합니다.

모든 사이트는 기본적으로 동일한 콘텐츠를 제공합니다. 가장 큰 차이점은 언어였습니다.

Google과 같은 검색 엔진은 다른 URL에서 동일한 컨텐츠를 &quot;기만적&quot;으로 간주합니다. 사용자는 동일한 컨텐츠를 제공하는 팜을 만들어 순위가 더 높거나 더 자주 나열되도록 할 수 있습니다. 검색 엔진은 이러한 시도를 인식하고 단순히 컨텐츠를 재활용하는 페이지를 낮은 수준으로 분류합니다.

하위 등급을 지정하지 않고, 실제로 동일한 콘텐츠가 있는 페이지가 두 개 이상 있고, 각 페이지의 헤더 섹션에서 `<link rel="alternate">` 태그를 각 관련 페이지에 설정하여 시스템에서 &quot;게임&quot;을 시도하지 않도록 할 수 있습니다([&quot;페이지의 현지화된 버전에 대해 Google에 알림&quot;](https://support.google.com/webmasters/answer/189077?hl=en) 참조).

```
# URL: www.shiny-brand.fr/fr/home/produits.html

<head>

  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch" 
        href="http://www.shiny-brand.ch/de/home/produkte.html">
  <link rel="alternate" 
        hreflang="de-de" 
        href="http://www.shiny-brand.de/de/home/produkte.html">

</head>

----

# URL www.shiny-brand.de/de/home/produkte.html

<head>

  <link rel="alternate" 
        hreflang="fr-fr" 
        href="http://www.shiny-brand.fr/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch"
         href="http://www.shiny-brand.ch/de/home/produits.html">

</head>
```

![모든 연결 간](assets/chapter-1/inter-linking-all.png)

*모든 연결 간*

<br> 

일부 SEO 전문가들은 심지어 이것이 유명 사이트에서 한 언어로 &quot;링크-주스&quot;라는 평판을 다른 언어로 해당 웹 사이트로 옮길 수 있다고 주장한다.

이 구성표는 많은 링크뿐만 아니라 일부 문제를 만들었습니다. _n_ 언어의 _p_&#x200B;에 필요한 링크의 수는 _p x (n<sup>2</sup>-n)_&#x200B;입니다.각 페이지는 (_n x_)를 제외하고 서로 다른 페이지(_-n_)에 연결됩니다. 이 구성표는 각 페이지에 적용됩니다. 4개 언어로 된 소규모 사이트가 20페이지인 경우 각각 _240_ 링크입니다.

먼저 편집기에서 이러한 링크를 수동으로 유지 관리해야 하지 않도록 하려면 시스템에서 링크를 자동으로 생성해야 합니다.

둘째, 정확해야 한다. 시스템에서 새로운 &quot;상대&quot;를 감지할 때마다 동일한 컨텐츠(하지만 다른 언어)를 사용하는 다른 모든 페이지에서 연결할 수 있습니다.

프로젝트에서 새로운 상대 페이지가 자주 나타납니다. 하지만 그들은 &quot;대체&quot; 링크로 구현되지 않았다. 예를 들어 `de-de/produkte` 페이지가 독일 웹 사이트에 게시되었을 때 다른 사이트에 즉시 표시되지 않았습니다.

그 이유는, 우리가 설치한 곳에서 그 사이트들이 독립적이어야 했기 때문입니다. 따라서 독일 웹 사이트의 변경 사항이 프랑스 웹 사이트에서 의 무효화를 트리거하지 않았습니다.

당신은 이미 그 문제를 해결하는 방법을 알고 있습니다. 무효화 도메인을 늘리려면 상태 파일 수준을 2로 줄이십시오. 물론 이는 캐시 적중 비율( 특히 게시가 있는 경우)도 감소하여 무효화가 더 자주 발생합니다.

이 경우 더 복잡했습니다.

비록 우리가 같은 콘텐츠를 가지고 있었음에도 불구하고, 실제 상표명이 아닌 이름들은 각 나라에서 다릅니다.

`shiny-brand` 이 `marque-brillant` 는 프랑스와 독일 `blitzmarke` 에서 호출되었습니다.

```
/content/marque-brillant/france/fr
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de
/content/blitzmarke/germany/de
…
```

이 값은 `statfiles` 수준을 1로 설정하려고 했습니다. 이 경우 무효화 도메인이 너무 많습니다.

사이트 구조 조정으로 이 문제가 해결되었을 것입니다. 하나의 공통 루트에 모든 브랜드를 함께 병합합니다. 그러나 우리는 그 때 능력을 가지고 있지 않았고, 그것은 우리에게 단지 2단계만 주어졌을 것입니다.

우리는 레벨 3를 고수하기로 결정하고 최신 &quot;대체&quot; 링크를 항상 가지고 있지 않은 가격을 지불했다. 이를 완화하기 위해 Dispatcher에서 &quot;reaper&quot; 크론 작업이 실행되어 어쨌든 1주 이상 오래된 파일을 정리했습니다. 결국 모든 페이지가 어떤 시점에서 다시 렌더링되었습니다. 그러나 그것은 각 프로젝트에서 개별적으로 결정되어야 하는 절충입니다.

## 결론

Adobe에서는 Dispatcher가 일반적으로 작동하는 방식에 대한 몇 가지 기본 원칙을 다룹니다. 제품을 올바로 이해하고 거래를 수행할 수 있는 데 보다 많은 구현 노력을 기울여야 할 몇 가지 예가 있습니다.

Dispatcher에 가 구성되는 방법에 대해 자세히 설명하지 않았습니다. 우리는 사용자가 너무 일찍 콘솔로 손실되지 않고 먼저 기본 개념과 문제를 이해하기를 바랍니다. 그리고 - 실제 구성 작업은 문서화되어 있습니다. 기본 개념을 이해하면 다양한 스위치가 어떤 용도로 사용되는지 알아야 합니다.

## Dispatcher 팁과 트릭

우리는 이 책의 첫 부분을 한 상황이나 다른 경우에 유용할 수 있는 힌트와 요리의 무작위 수집으로 끝맺겠습니다. 우리가 전에 그랬던 것처럼, 우리는 해결책을 제시하고 있지 않습니다. 그래서 당신이 아이디어와 개념을 이해하고 실제의 구성을 더 자세히 설명하는 문서에 연결할 기회를 얻을 수 있도록 하는 것입니다.

### 정확한 무효화 시간

AEM 작성자 및 게시 를 즉시 설치하는 경우 토폴로지가 약간 이상합니다. 작성자가 게시 시스템에 컨텐츠를 보내고 무효화 요청이 동시에 Dispatcher에 전송됩니다. 게시 시스템과 Dispatcher는 모두 타이밍을 대기열로 작성자에서 분리될 수 있으므로 약간 불행할 수 있습니다. Dispatcher는 Publish 시스템에서 컨텐츠가 업데이트되기 전에 작성자로부터 무효화 요청을 받을 수 있습니다.

클라이언트가 그 동안 해당 컨텐츠를 요청하는 경우 Dispatcher는 부실 컨텐츠를 요청하고 저장합니다.

더 읽기 쉬운 설정이 _이후에 게시 시스템_&#x200B;에서 콘텐츠를 받은 무효화 요청을 보냅니다. 게시 인스턴스에서 Dispatcher 캐시를 무효화하는 문서 &quot;[게시 인스턴스](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)&quot;는 세부 정보를 설명합니다.

**참조**

[helpx.adobe.com - 게시 인스턴스에서 Dispatcher 캐시 무효화](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)

### HTTP 헤더 및 헤더 캐싱

옛날에는 Dispatcher가 일반 파일을 파일 시스템에 저장하고 있었습니다. 고객에게 HTTP 헤더를 전달해야 하는 경우 파일 또는 위치에서 얻은 작은 정보를 기반으로 Apache를 구성하여 구현했습니다. AEM에서 HTTP 헤더에 많이 의존하는 웹 애플리케이션을 구현할 때 특히 성가신 일입니다. AEM 전용 인스턴스에서 모든 것이 제대로 작동했지만 Dispatcher를 사용하면 작동하지 않습니다.

일반적으로 리소스 경로 및 접미사에 의해 파생될 수 있는 정보를 사용하여 `mod_headers`을(를) 사용하여 Apache 서버의 리소스에 누락된 헤더를 다시 적용하기 시작했습니다. 그러나 이것이 항상 충분하지 않았다.

특히 Dispatcher가 브라우저에 대해 첫 번째 _캐시되지 않은_ 응답을 제공하더라도 전체 범위의 헤더를 포함하는 게시 시스템에서 후속 응답이 제한된 헤더 세트를 사용하여 Dispatcher에 의해 생성되었습니다.

Dispatcher 4.1.11 이상에서 Dispatcher는 게시 시스템에서 생성된 헤더를 저장할 수 있습니다.

이를 통해 Dispatcher에서 헤더 로직을 복제하지 않고 HTTP 및 AEM의 풍부한 기능을 활용할 수 있습니다.

**참조**

* [helpx.adobe.com - 응답 헤더 캐싱](https://helpx.adobe.com/experience-manager/kb/dispatcher-cache-response-headers.html)

### 개별 캐싱 예외

일반적으로 모든 페이지 및 이미지를 캐시할 수 있지만, 일부 경우에는 예외로 합니다. 예를 들어, PNG 이미지를 캐시하려고 하지만, 각 요청에서 변경될 것으로 보이는 캡차를 표시하는 PNG 이미지는 캐시하지 않으려고 합니다. Dispatcher가 captcha를 captcha로 인식하지 못할 수 있지만 AEM은 확실히 인식합니다. 이것은 Dispatcher에게 응답과 함께 적절한 헤더를 보내 한 요청을 캐시하지 않도록 요청할 수 있습니다.

```plain
  response.setHeader("Dispatcher", "no-cache");

  response.setHeader("Cache-Control: no-cache");

  response.setHeader("Cache-Control: private");

  response.setHeader("Pragma: no-cache");
```

Cache-Control 및 Pragma는 CDN과 같은 상위 캐싱 레이어에 전파되고 해석되는 공식 HTTP 헤더입니다. `Dispatcher` 헤더는 Dispatcher가 캐시하지 않도록 하는 힌트일 뿐입니다. 이 도구를 사용하여 Dispatcher에 캐시하지 않도록 하면서도 상위 캐싱 레이어가 그렇게 하도록 하는 데 사용할 수 있습니다. 사실, 그것이 유용할 수 있는 사례를 찾기는 어렵습니다. 그러나 우리는 어딘가에 몇 가지가 있다는 것을 확신합니다.

**참조**

* [Dispatcher - 캐시 없음](https://helpx.adobe.com/experience-manager/kb/DispatcherNoCache.html)

### 브라우저 캐싱

가장 빠른 http-응답은 브라우저 자체가 제공하는 응답입니다. 요청과 응답이 높은 로드 상태에서 네트워크를 통해 웹 서버로 이동할 필요가 없는 경우.

브라우저에서 리소스에 대한 만료 날짜를 설정하여 서버에 새 파일 버전을 요청할 시기를 결정하는 데 도움이 될 수 있습니다.

일반적으로, Apache의 `mod_expires`를 사용하거나, 더 개별 제어가 필요한 경우 AEM에서 제공하는 Cache-Control 및 Expires Header를 저장하여 정적으로 이 작업을 수행합니다.

브라우저에 캐싱된 문서는 세 가지 수준의 최신 문서를 가질 수 있습니다.

1. _새로 고침_  보장 - 브라우저가 캐시된 문서를 사용할 수 있습니다.

2. _부실_  가능성이 있음 - 브라우저가 캐시된 문서가 최신 상태인지 서버에게 먼저 확인해야 합니다.

3. _부실_  - 브라우저가 서버에 새 버전을 요청해야 합니다.

첫 번째 옵션은 서버에서 설정한 만료 날짜까지 보장됩니다. 리소스가 만료되지 않은 경우 서버에 다시 요청할 필요가 없습니다.

문서가 만료 날짜가 되면 새로 고칠 수 있습니다. 문서가 배달될 때 만료 날짜가 설정됩니다. 그러나 종종 새로운 컨텐츠가 사용 가능한 시기를 미리 알지 못하는 경우가 있으므로 이것은 단지 보수적인 예측입니다.

브라우저 캐시의 문서가 새 요청에 배달될 문서와 동일한지 확인하려면 브라우저에서 문서의 `Last-Modified` 날짜를 사용할 수 있습니다. 브라우저가 서버에 다음 사항을 묻습니다.

&quot;_6월 10일의 버전이 있습니다.. 업데이트가 필요합니까?_&quot; 서버가

&quot;_304 - 리소스를 다시 전송하지 않고 버전이 여전히 최신_&quot;이거나, 서버가

&quot;_200 - HTTP 헤더에 있는 최신 버전_&quot;과 HTTP 본문에 있는 실제 최신 컨텐츠입니다.

두 번째 부품이 작동하려면 `Last-Modified` 날짜를 브라우저에 전송하여 업데이트를 요청할 수 있는 참조 지점이 있는지 확인하십시오.

앞서 설명했듯이 `Last-Modified` 날짜가 Dispatcher에 의해 생성되면 브라우저에 의해 파일이 요청될 때 캐시된 파일과 해당 날짜가 생성되므로 다른 요청 간에 다를 수 있습니다. 대체 방법은 &quot;e-tags&quot;를 사용하는 것입니다. 이 숫자는 날짜 대신 실제 컨텐츠(예: 해시 코드 생성)를 식별하는 숫자입니다.

_ACS Commons Package_&#x200B;의 [Tag Support](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)&quot;은 이 방법을 사용합니다. 그러나 가격은 다음과 같습니다.E-Tag를 헤더로 전송해야 하지만, 해시 코드의 계산에서 응답을 완전히 읽어야 하므로 응답을 배달하려면 먼저 기본 메모리에서 완전히 버퍼링해야 합니다. 이 경우 웹 사이트가 캐시되지 않은 리소스를 많이 가질 가능성이 높고 AEM 시스템에서 사용하는 메모리를 추적해야 하는 경우 지연에 부정적인 영향을 줄 수 있습니다.

URL 지문을 사용하는 경우 매우 긴 만료 날짜를 설정할 수 있습니다. 브라우저에서 지문 리소스를 영구적으로 캐시할 수 있습니다. 새 버전이 새 URL로 표시되어 있으므로 이전 버전을 업데이트할 필요가 없습니다.

스풀러 패턴을 도입했을 때 URL 지문을 사용했습니다. `/etc/design`(CSS, JS)에서 오는 정적 파일은 거의 변경되지 않으므로 지문을 사용하기에 적합한 후보이기도 합니다.

일반 파일의 경우 30분마다 HTML을 다시 확인하고 4시간마다 이미지 등과 같은 고정된 구성표를 설정합니다.

브라우저 캐싱은 작성 시스템에서 매우 유용합니다. 브라우저에서 가능한 한 많이 캐시하여 편집 환경을 개선하려고 합니다. 안타깝게도 가장 비싼 자산인 html 페이지는 캐시할 수 없습니다. 작성자는 자주 변경해야 합니다.

AEM UI를 구성하는 granite 라이브러리는 상당한 시간 동안 캐시할 수 있습니다. 브라우저에서 사이트 정적 파일(글꼴, CSS 및 JavaScript)을 캐시할 수도 있습니다. 일반적으로 `/content/dam`의 이미지도 페이지의 복사 텍스트와 같이 자주 변경되지 않으므로 약 15분 동안 캐시될 수 있습니다. 이미지는 AEM에서 대화식으로 편집되지 않습니다. 이러한 수정 사항은 AEM에 업로드되기 전에 먼저 편집하고 승인됩니다. 따라서 텍스트 만큼 자주 변경되지 않는다고 가정할 수 있습니다.

UI 파일을 캐시하면 사이트 라이브러리 파일 및 이미지가 편집 모드에 있을 때 페이지 재로드 속도가 크게 빨라질 수 있습니다.



**참조**

*[developer.mozilla.org - 캐싱](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)

* [apache.org - Mod 만료](https://httpd.apache.org/docs/current/mod/mod_expires.html)

* [ACS Commons - Etag 지원](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)

### URL 자르기

리소스는

`/content/brand/country/language/…`

그러나 고객에게 표시하려는 URL은 아닙니다. 보조, 가독성 및 SEO 이유로 도메인 이름에 이미 표시된 부분을 자를 수 있습니다.

도메인이 있는 경우

`www.shiny-brand.fi`

보통 브랜드와 국가를 걸어야 할 필요가 없다. 대신,

`www.shiny-brand.fi/content/shiny-brand/finland/fi/home.html`

당신이 원하는 건

`www.shiny-brand.fi/home.html`

AEM에서는 잘린 형식에 따라 링크를 렌더링하는 방법을 알아야 하므로 AEM에서 해당 매핑을 구현해야 합니다.

그러나 AEM에만 의존하지 마십시오. 그럴 경우 캐시의 루트 디렉터리에 `/home.html` 과 같은 경로가 있습니다. 지금, 그것은 결승점이나 독일어의 &quot;홈&quot;입니까 아니면 캐나다 웹사이트의 것입니까? 그리고 Dispatcher에 `/home.html` 파일이 있는 경우 Dispatcher는 `/content/brand/fi/fi/home`에 대한 무효화 요청이 들어올 때 이 파일을 무효화해야 한다는 것을 어떻게 알 수 있습니까?

각 도메인에 대해 별도의 docroot가 있는 프로젝트를 보았습니다. 디버그 및 유지 관리하는 것은 악몽이었고 실제로 완벽한 실행은 전혀 보지 못했습니다.

캐시를 다시 구조화하면 문제를 해결할 수 있을 거예요 모든 도메인에 대한 단일 docroot가 있고, 무효화 요청은 서버의 모든 파일이 `/content`으로 시작되므로 1:1로 처리할 수 있습니다.

자르는 것도 매우 쉬웠습니다.  AEM에서 `/etc/map`의 구성에 따라 잘린 링크를 생성했습니다.

이제 요청 `/home.html`이 Dispatcher에 도달하면 발생하는 첫 번째 작업은 경로를 내부적으로 확장하는 다시 작성 규칙을 적용하는 것입니다.

이 규칙은 각 호스트 구성에서 정적으로 설정되었습니다. 간단히 말해서, 규칙은 이렇게 생겼는데

```plain
  # vhost www.shiny-brand.fi

  RewriteRule "^(.\*\.html)" "/content/shiny-brand/finland/fi/$1"
```

이제 파일 시스템에 일반 `/content` 기반 경로가 있습니다. 이 경로는 작성 및 게시에서도 찾을 수 있으며 이는 많은 디버깅 작업에 도움이 됩니다. 올바른 무효화는 말할 것도 없고 더 이상 문제가 되지 않습니다.

이 작업은 브라우저의 URL 슬롯에 표시되는 &quot;표시되는&quot; URL에만 수행되었습니다. 예를 들어, 이미지의 URL은 여전히 순수 &quot;/content&quot; URL입니다. Adobe는 검색 엔진 최적화 측면에서 &quot;기본&quot; URL을 미화해도 충분하다고 믿습니다.

또 하나의 일반적인 docroot를 가지는 것도 좋은 특징이었습니다. Dispatcher에서 문제가 발생하면 를 실행하여 전체 캐시를 정리할 수 있습니다.

`rm -rf /cache/dispatcher/*`

(높은 로드 최고점에서 수행하지 않을 수 있습니다.)

**참조**

* [apache.org - Mod 재작성](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)

* [helpx.adobe.com - 리소스 매핑](https://helpx.adobe.com/experience-manager/6-4/sites/deploying/using/resource-mapping.html)

### 오류 처리

AEM 클래스에서는 Sling에서 오류 핸들러를 프로그래밍하는 방법을 알아봅니다. 일반적인 템플릿을 작성하는 것과 다르지 않습니다. 단순히 JSP 또는 HTL로 템플릿을 작성하기만 하면 됩니다.

네, 하지만 이것은 AEM 부분이에요. 기억 - Dispatcher가 `404 – not found` 또는 `500 – internal server error` 응답을 캐시하지 않습니다.

각(실패한) 요청에서 이러한 페이지를 동적으로 렌더링하는 경우 게시 시스템에서 불필요한 높은 로드가 발생합니다.

오류가 발생할 때 전체 오류 페이지를 렌더링하지 않고 매우 간단하고 작은 버전의 정적 페이지만 장식이나 논리 없이 렌더링하는 것이 유용하다고 판단했습니다.

물론 이것은 고객이 본 것이 아니다. Dispatcher에서 다음과 같이 `ErrorDocuments`을 등록했습니다.

```
ErrorDocument 404 "/content/shiny-brand/fi/fi/edocs/error-404.html"
ErrorDocument 500 "/content/shiny-brand/fi/fi/edocs/error-500.html"
```

이제 AEM 시스템은 Dispatcher에 뭔가가 잘못되었다는 사실을 알릴 수 있으며 Dispatcher는 오류 문서의 번들하고 아름다운 버전을 제공할 수 있습니다.

여기서 두 가지 사항을 명시해야 합니다.

먼저 `error-404.html`은 항상 동일한 페이지입니다. 따라서 &quot;_producten_&quot;에 대한 검색이 결과를 내놓지 않았다는 것과 같은 개별 메시지는 없습니다.&quot; 우리는 그것을 가지고 쉽게 살 수 있었다.

두 번째로... 내부 서버 오류가 표시되거나 AEM 시스템의 중단이 발생하는 경우 AEM에 오류 페이지를 렌더링하도록 요청할 방법이 없습니다. `ErrorDocument` 지시문에 정의된 대로 필요한 후속 요청도 실패합니다. Adobe는 `wget` 을 통해 정의된 위치에서 오류 페이지를 주기적으로 끌어와 `ErrorDocuments` 지시문에 정의된 정적 파일 위치에 저장하는 cron-job을 실행하여 해당 문제를 해결했습니다.

**참조**

* [apache.org - 사용자 지정 오류 문서](https://httpd.apache.org/docs/2.4/custom-error.html)

### 보호된 콘텐츠 캐싱

Dispatcher는 기본적으로 리소스를 제공할 때 권한을 확인하지 않습니다. Labs는 일부러 이와 같이 구현되어 공개 웹 사이트의 속도를 높입니다. 로그인하여 일부 리소스를 보호하려면 기본적으로 다음 세 가지 옵션이 있습니다.

1. 요청이 캐시에 도달하기 전에 리소스를 Protect에 추가합니다. 즉, Dispatcher 전면의 SSO(Single Sign On) 게이트웨이 또는 Apache 서버의 모듈로

2. 중요 리소스를 캐시하지 않도록 하여 항상 게시 시스템에서 실시간으로 제공합니다.

3. Dispatcher에서 권한 구분 캐싱 사용

그리고 물론, 세 가지 접근 방식을 모두 혼합하여 적용할 수 있습니다.

**옵션 1**. 어쨌든 &quot;SSO&quot; 게이트웨이는 조직에 의해 적용될 수 있습니다. 액세스 체계가 매우 거칠면 리소스에 대한 액세스 권한을 부여할지 또는 거부할지를 결정하기 위해 AEM의 정보가 필요하지 않을 수 있습니다.

>[!NOTE]
>
>이 패턴에는 _게이트웨이_&#x200B;가 필요합니다. 이&#x200B;_은 각 요청을 가로채고 실제_&#x200B;인증&#x200B;_을 수행하여 Dispatcher에 요청을 부여하거나 거절합니다._ SSO 시스템이 _인증자_&#x200B;인 경우 옵션 3을 구현해야 하는 사용자의 ID만 설정합니다. SSO 시스템의 안내서에서 &quot;SAML&quot; 또는 &quot;OAauth&quot;와 같은 용어를 읽으면 옵션 3을 구현해야 하는 강력한 지표입니다.


**옵션 2**. &quot;캐싱하지 않음&quot;은 일반적으로 나쁜 생각이다. 그렇게 하는 경우 트래픽 양과 제외된 중요한 리소스 수가 적은지 확인하십시오. 또는 게시 시스템에 일부 메모리 내 캐시가 설치되어 있어야 하며 게시 시스템이 이 시리즈의 3부 중 결과를 처리할 수 있어야 합니다.

**옵션 3**. 권한 구분 캐싱은 흥미로운 접근 방식입니다. Dispatcher가 리소스를 캐시하고 있지만 제공하기 전에 AEM 시스템에 리소스를 캐시할 수 있는지 확인합니다. 이렇게 하면 Dispatcher에서 게시로 추가 요청이 만들어지지만, 페이지가 이미 캐시된 경우 게시 시스템을 다시 렌더링하지 않습니다. 그러나 이 방법에서는 몇 가지 사용자 지정 구현이 필요합니다. 자세한 내용은 문서 [권한 구분 캐싱](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)에서 확인하십시오.

**참조**

* [helpx.adobe.com - 권한 구분 캐싱](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)

### 유예 기간 설정

짧은 연속으로 자주 무효화되는 경우(예: 트리 활성화 또는 최신 상태로 유지하기 위한 간단한 필요) 캐시를 항상 플러싱하고 방문자가 거의 항상 빈 캐시를 히트하고 있다는 문제가 발생할 수 있습니다.

아래 다이어그램은 단일 페이지에 액세스할 때의 가능한 타이밍을 보여줍니다.  요청한 다른 페이지의 수가 증가하면 물론 문제가 더 심각해집니다.

![잦은 활성화로 인해 대부분의 시간 동안 캐시가 잘못되었습니다.](assets/chapter-1/frequent-activations.png)

*잦은 활성화로 인해 대부분의 시간 동안 캐시가 잘못되었습니다.*

<br> 

경우에 따라 이 &quot;캐시 무효화 폭풍&quot;의 문제를 완화하려면 `statfile` 해석에 대해 보다 엄격할 수 있습니다.

자동 무효화에 `grace period`을 사용하도록 Dispatcher를 설정할 수 있습니다. 이렇게 하면 내부적으로 `statfiles` 수정 날짜에 약간의 시간이 더 추가됩니다.

예를 들어 `statfile`에 오늘 12:00의 수정 시간이 있고 `gracePeriod`이 2분으로 설정되어 있습니다. 그러면 모든 자동 무효화된 파일은 12:01과 12:02에 유효한 것으로 간주됩니다. 12시 2분 후에 다시 렌더링됩니다.

참조 구성에서는 정당한 이유로 2분의 `gracePeriod`을 제안합니다. &quot;2분? 거의 아무것도 아냐 컨텐츠가 표시될 때까지 10분을 쉽게 기다릴 수 있습니다...&quot;  따라서 컨텐츠가 10분 이상 후에 적어도 나타난다고 가정할 때 더 긴 기간을 설정하고 싶은 생각이 있을 수 있습니다. 예를 들어 10분.

>[!WARNING]
>
>이는 `gracePeriod` 이 작동하는 방식이 아닙니다. 유예 기간은 문서가 무효화되는 것이 보장되는 시간이 아닌 _이지만 무효화가 발생하지 않는 시간입니다._ 이 프레임 _에 속하는 각 후속 무효화는 기간_&#x200B;을 늘립니다. 이 값은 무한정 길어질 수 있습니다.

`gracePeriod`이 실제로 예제를 사용하여 작동하는 방식을 보여 줍니다.

미디어 사이트를 운영하고 있으며 편집 직원이 5분마다 정기적으로 컨텐츠 업데이트를 제공합니다. gracePeriod를 5분으로 설정해 보십시오.

12시에 간단한 예를 들어보겠습니다.

12:00 - 상태 파일이 12:00으로 설정됩니다. 캐시된 모든 파일은 12:05까지 유효한 것으로 간주됩니다.

12:01 - 무효화가 발생합니다. 이렇게 하면 시간 범위가 12:06으로 늘어납니다

12:05 - 다른 편집기가 자신의 문서를 게시합니다. 즉, 다른 유예 기간을 12:10으로 연장합니다.

그리고.. 컨텐츠가 무효화되지 않습니다. *내에서 각 무효화*&#x200B;은(는) 유예 시간을 효과적으로 늘립니다. `gracePeriod`은 무효화 폭풍을 견뎌낼 수 있도록 설계되었지만, 결국 비를 맞으러 나가야 합니다... 따라서 `gracePeriod`을 상당히 짧게 유지하여 보호소에 영원히 숨지 않도록 하십시오.

#### 결정론적 유예 기간

우리는 당신이 어떻게 무효화 폭풍을 일으킬 수 있는지에 대해 또 다른 아이디어를 소개하고 싶습니다. 그것은 단지 아이디어일 뿐이다. 우리는 그것을 생산하는데 시도하지는 않았지만, 우리는 그 개념을 당신에게 공유할 만큼 흥미로운 것을 발견했습니다.

일반 복제 간격이 `gracePeriod`보다 짧은 경우 `gracePeriod`이(가) 예기치 않게 길어질 수 있습니다.

대체 아이디어는 다음과 같습니다.고정된 시간 간격에서만 무효화됩니다. 사이의 시간은 항상 오래된 컨텐츠를 제공하는 것을 의미합니다. 무효화는 결국 발생하지만 많은 무효화가 하나의 &quot;일괄&quot; 무효화에 수집되므로 Dispatcher가 그 동안 캐시된 컨텐츠를 제공하고 게시 시스템에 숨을 쉴 수 있는 공기를 제공할 수 있습니다.

구현은 다음과 같습니다.

무효화가 발생한 후 실행되는 &quot;사용자 지정 무효화 스크립트&quot;(참조 참조)를 사용합니다. 이 스크립트는 `statfile's` 마지막 수정 날짜를 읽고 다음 간격 중지로 반올림합니다. Unix 셸 명령 `touch --time` 시간을 지정하겠습니다.

예를 들어 유예 기간을 30초로 설정하면 Dispatcher는 상태 파일의 마지막 수정 날짜를 다음 30초로 반올림합니다. 사이에 발생하는 무효화 요청은 다음 전체 30초를 동일하게 설정합니다.

![무효화를 다음 전체 30초로 연기하면 적중률이 증가합니다.](assets/chapter-1/postponing-the-invalidation.png)

*무효화를 다음 전체 30초로 연기하면 적중률이 증가합니다.*

<br> 

무효화 요청과 다음 30초 슬롯 사이에 발생하는 캐시 히트는 오래된 것으로 간주됩니다.게시에 대한 업데이트가 있지만 Dispatcher가 여전히 이전 콘텐츠를 제공합니다.

이 접근 방식을 사용하면 후속 요청이 결정적으로 기간을 연장하지 않을까 염려하지 않고도 더 긴 유예 기간을 정의할 수 있습니다. 우리가 전에 말했듯이, 그것은 단지 아이디어이고 우리는 그것을 시험할 기회를 갖지 못했습니다.

**참조**

[helpx.adobe.com - Dispatcher 구성](https://helpx.adobe.com/kr/experience-manager/dispatcher/using/dispatcher-configuration.html을 참조하십시오.)

### 자동 다시 가져오기

사이트에는 매우 특별한 액세스 패턴이 있습니다. 들어오는 트래픽이 많이 발생하고 대부분의 트래픽이 페이지의 작은 부분에 집중됩니다. 홈 페이지, 캠페인 랜딩 페이지 및 가장 중요한 제품 세부 사항 페이지에는 트래픽의 90%가 수신됩니다. 또는 새 사이트를 운영하는 경우 최근 문서에 비해 이전 문서에 비해 트래픽이 더 많습니다.

이제 이러한 페이지는 매우 자주 요청되므로 Dispatcher에서 캐시될 가능성이 높습니다.

임의 무효화 요청이 Dispatcher에 전송되어 가장 인기 있는 페이지를 포함하여 모든 페이지가 무효화됩니다.

따라서 이러한 페이지가 매우 유명하므로 다른 브라우저에서 새로운 수신 요청이 있습니다. 예를 들어 홈 페이지를 살펴보겠습니다.

이제 캐시가 유효하지 않으므로 동시에 들어오는 홈 페이지에 대한 모든 요청은 높은 로드를 생성하는 게시 시스템으로 전달됩니다.

![빈 캐시의 동일한 리소스에 대한 병렬 요청:요청이 게시로 전달됩니다](assets/chapter-1/parallel-requests.png)

*빈 캐시의 동일한 리소스에 대한 병렬 요청:요청이 게시로 전달됩니다*

자동 다시 가져오기 기능을 사용하면 해당 기능을 어느 정도 줄일 수 있습니다. 대부분의 무효화된 페이지는 자동 무효화 후에도 여전히 Dispatcher에 물리적으로 저장됩니다. _은(는) 단지_&#x200B;부실 것으로 간주됩니다. _자동_ 새로 고침은 오래된 컨텐츠를 다시 가져오기 위해  _한 번_ 의 요청을 게시 시스템에 시작하는 동안 여전히 몇 초 동안 이러한 오래된 페이지를 제공함을 의미합니다.

![백그라운드에서 다시 가져오는 동안 오래된 컨텐츠 제공](assets/chapter-1/fetching-background.png)

*백그라운드에서 다시 가져오는 동안 오래된 컨텐츠 제공*

<br> 

다시 가져오기를 사용하려면 자동 무효화 후 다시 가져올 리소스를 Dispatcher에 알려주어야 합니다. 활성화한 모든 페이지는 자주 사용하는 페이지를 포함하여 다른 모든 페이지도 자동으로 무효화됩니다.

다시 가져오기는 실제로 각(!)에 Dispatcher에 알리는 것을 의미합니다. 가장 인기 있는 항목 및 가장 인기 있는 항목을 다시 가져오려는 무효화 요청입니다.

이는 무효화 요청 본문에 리소스 URL(경로뿐만 아니라 실제 URL) 목록을 넣어 달성합니다.

```
POST /dispatcher/invalidate.cache HTTP/1.1

CQ-Action: Activate
CQ-Handle: /content/my-brand/home/path/to/some/resource
Content-Type: Text/Plain
Content-Length: 207

/content/my-brand/home.html
/content/my-brand/campaigns/landing-page-1.html
/content/my-brand/campaigns/landing-page-2.html
/content/my-brand/products/product-1.html
/content/my-brand/products/product-2.html
```

Dispatcher는 이러한 요청을 볼 때 평소대로 자동 무효화를 트리거하며 게시 시스템에서 새 컨텐츠를 다시 가져오도록 요청을 즉시 큐에 추가합니다.

이제 요청 본문을 사용하고 있으며 HTTP 표준에 따라 컨텐츠 유형과 컨텐츠 길이를 설정해야 합니다.

또한 Dispatcher는 자동 무효화에 의해 유효하지 않은 것으로 간주되더라도 이러한 리소스를 직접 제공할 수 있음을 알 수 있도록 내부적으로 URL에 따라 를 표시합니다.

나열된 모든 URL은 하나씩 요청됩니다. 따라서 게시 시스템에서 너무 높은 로드를 만드는 것을 걱정할 필요가 없습니다. 그러나 해당 목록에 너무 많은 URL을 포함시키는 것도 원하지 않습니다. 마지막으로, 너무 오랫동안 오래된 컨텐츠를 제공하지 않기 위해서는 결과적으로 큐를 처리해야 합니다. 가장 자주 액세스하는 페이지 10개를 포함하십시오.

Dispatcher의 캐시 디렉토리를 살펴보면 타임스탬프가 있는 임시 파일이 표시됩니다. 이들은 현재 백그라운드에서 로드되고 있는 파일입니다.

**참조**

[helpx.adobe.com - AEM에서 캐시된 페이지 무효화](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

### 게시 시스템 보호

Dispatcher는 유지 관리 목적으로만 의도된 요청에서 게시 시스템을 차폐하여 약간의 추가 보안을 제공합니다. 예를 들어 `/crx/de` 또는 `/system/console` URL을 공개하지는 않을 것입니다.

시스템에 웹 응용 프로그램 방화벽(WAF)이 설치되어 있어도 아무런 문제가 없습니다. 그러나 그것은 당신의 예산에 상당한 수를 더하며, 모든 프로젝트가 그들이 여유가 있고, -잊지 말아야 할- WAF를 운영하고 유지하는 상황에 있는 것은 아니다.

우리가 자주 보는 것은 보다 취약한 리소스에 대한 액세스를 방지하는 Dispatcher 구성에 있는 Apache 재작성 규칙 세트입니다.

그러나 다른 방법을 고려할 수도 있습니다.

Dispatcher 구성에 따라 Dispatcher 모듈이 특정 디렉토리에 바인딩됩니다.

```
<Directory />
  SetHandler dispatcher-handler
  …
</Directory>
```

하지만 나중에 필터링해야 할 때 처리기를 전체 docroot에 바인딩하는 이유는 무엇입니까?

핸들러의 바인딩 범위를 먼저 좁힐 수 있습니다. `SetHandler` 핸들러를 디렉토리에 바인딩하기만 하면 URL 또는 URL 패턴에 핸들러를 바인딩할 수 있습니다.

```
<LocationMatch "^(/content|/etc/design|/dispatcher/invalidate.cache)/.\*">
  SetHandler dispatcher-handler
</LocationMatch>

<LocationMatch "^/dispatcher/invalidate.cache">
  SetHandler dispatcher-handler
</LocationMatch>

…
```

이렇게 하면 디스패처의 무효화 URL에 항상 디스패처 핸들러를 바인딩하는 것을 잊지 마십시오. 그렇지 않으면 AEM에서 Dispatcher에 무효화 요청을 보낼 수 없습니다.

Dispatcher를 필터로 사용하는 또 다른 방법은 `dispatcher.any`에서 필터 지시어를 설정하는 것입니다

```
/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }
```

우리는 한 지시문의 사용을 다른 지시문에 비해 강제하지 않으며, 오히려 모든 지시문의 적절한 조합을 권장합니다.

그러나 URL 공간을 가능한 한 빨리 좁히고, 가능한 가장 간단한 방법으로 가능한 한 그렇게 하는 것을 고려해 보는 것이 좋습니다. 이러한 기법은 민감한 웹 사이트에서 WAF를 대체하는 것이 아니라는 점에 주의하십시오. 어떤 사람들은 이러한 기술을 &quot;가난한 사람의 방화벽&quot; 이라고 부르는 이유가 있다.

**참조**

[apache.org-sethandler 지시문](https://httpd.apache.org/docs/2.4/mod/core.html#sethandler)

[helpx.adobe.com - 컨텐츠 필터에 대한 액세스 구성](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#ConfiguringAccesstoContentfilter)

### 정규 표현식 및 글로브를 사용한 필터링

초기에는 &quot;전역&quot; - 간단한 자리 표시자만 사용하여 Dispatcher 구성에서 필터를 정의할 수 있습니다.

다행히 최신 버전의 Dispatcher에서 변경되었습니다. 이제 POSIX 정규 표현식도 사용할 수 있으며, 요청의 다양한 부분에 액세스하여 필터를 정의할 수 있습니다. Dispatcher로 시작하는 데 활용할 수 있습니다. 하지만 여러분이 글로브만 가지고 있다면, 이것은 놀라움과 쉽게 간과될 수 있습니다. globs와 regexes의 구문 외에도 너무 유사합니다. 동일한 두 버전을 비교하겠습니다.

```
# Version A

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }

# Version B

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url '/content.\*'  }
```

차이점 보이세요?

버전 B는 작은 따옴표 `'`를 사용하여 _정규 표현식 패턴_&#x200B;을 표시합니다. &quot;모든 문자&quot;는 `.*`을 사용하여 표시됩니다.

_글로빙 패턴_ 반면에 큰따옴표 `"` 를 사용하고  `*`과 같은 간단한 자리 표시자만 사용할 수 있습니다.

이 차이점을 알고 있다면 사소한 것입니다. 하지만 그렇지 않다면 쉽게 따옴표를 혼합하고 화창한 오후 동안 구성을 디버깅할 수 있습니다. 이제 경고를 받았군요

&quot;구성에서 `'/url'`을 인식합니다...하지만 질문할 수 있는 필터에 있는 `'/glob'`은 무엇입니까?

이 지시문은 메서드 및 경로를 포함하여 전체 요청 문자열을 나타냅니다. 그건

`"GET /content/foo/bar.html HTTP/1.1"`

패턴과 비교할 문자열입니다. 초심자는 첫 번째 부분인 `method`(GET, POST, ...)을 잊어버리는 경향이 있습니다. 그러니까, 패턴은

`/0002  { /glob "/content/\*" /type "allow" }`

&quot;/content&quot;가 &quot;GET ..&quot;과 일치하지 않으므로 항상 실패합니다. Null 포인터 예외가 발생합니다.

글로브도 사용하고 싶으면

`/0002  { /glob "GET /content/\*" /type "allow" }`

맞겠죠

초기 거부 규칙(예: )

`/0001  { /glob "\*" /type "deny" }`

괜찮습니다. 그러나 후속 허용에서는 요청의 개별 부분을 사용하는 것이 보다 효과적이고 더 명확하며 훨씬 안전합니다.

```
/method
/url
/path
/selector
/extension
/suffix
```

비슷함:

```
/005  {

  /type "allow"
  /method "GET"
  /extension '(css|gif|ico|js|png|swf|jpe?g)' }
```

규칙에서 regex 및 glob 표현식을 혼합할 수 있습니다.

각 정의 앞에 있는 `/005`과 같은 &quot;줄 번호&quot;에 대한 마지막 단어 하나,

그들은 전혀 의미가 없어요! 규칙에 대한 임의의 분모를 선택할 수 있습니다. 숫자를 사용하는 것은 어떤 계획에 대해 생각하는데 많은 노력을 필요로 하지 않지만, 그 순서가 중요하다는 것을 명심하세요.

다음과 같은 수백 개의 규칙이 있는 경우:

```
/001
/002
/003
…
/100
…
```

/001과 /002 사이에 하나를 삽입하고 그 다음 숫자에 어떤 일이 생기는지 알고 싶습니다. 그들의 수를 늘리고 있습니까? 중간번호를 넣으십니까?

```
/001
/001a
/002
/003
…
/100
…
```

또는 /003과 /001을 다시 주문하려면 이름과 ID를 바꾸거나 본인이 아니면 본인이 되십니까

```
/003
/002
/001
…
/100
…
```

첫 번째 부분에서 간단한 선택이 긴 기간의 한계에 도달하는 것처럼 보이는 번호 지정. 식별자를 사용하여 숫자를 선택하는 것은 어쨌든 잘못된 프로그래밍 방식입니다.

다음과 같은 다른 방법을 제안하고자 합니다.따라서 각 개별 필터 규칙에 의미 있는 식별자를 적용하지 않을 수 있습니다. 하지만 그들은 아마도 더 큰 목적을 위해 일하므로, 그들은 그 목적에 따라 어떤 방법으로 그룹화할 수 있습니다. 예를 들어 &quot;기본 설정&quot;, &quot;응용 프로그램 특정 예외&quot;, &quot;전역 예외&quot; 및 &quot;보안&quot;이 있습니다.

그런 다음 규칙에 이름을 지정하고 그룹화하고 해당 구성의 리더기(친애하는 동료)를 파일에 제공할 수 있습니다.

```plain
  # basic setup:

  /filter {

    # basic setup

    /basic_01  { /glob "\*"             /type "deny"  }
    /basic_02  { /glob "/content/\*"    /type "allow" }
    /basic_03  { /glob "/etc/design/\*" /type "allow" }

    /basic_04  { /extension '(json|xml)'  /type "deny"  }
    …


    # login

    /login_01 { /glob "/api/myapp/login/\*" /type "allow" }
    /login_02 { … }

    # global exceptions

    /global_01 { /method "POST" /url '.\*contact-form.html' }
```


새 규칙을 그룹 중 하나에 추가하거나 새 그룹을 만들 수도 있습니다. 이 경우 이름 바꾸기/번호 바꾸기를 수행할 항목 수는 해당 그룹으로 제한됩니다.

>[!WARNING]
>
>보다 정교한 설정은 필터링 규칙을 여러 파일로 분할하며 기본 `dispatcher.any` 구성 파일에 포함됩니다. 그러나 새 파일에는 새 네임스페이스가 도입되지 않습니다. 따라서 한 파일에 &quot;001&quot; 규칙이 있고 다른 파일에 &quot;001&quot; 규칙이 있으면 오류가 발생합니다. 의미상 강력한 이름을 내놓는 더 많은 이유가 있다.

**참조**

[helpx.adobe.com - glob 속성에 대한 패턴 디자인](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#DesigningPatternsforglobProperties)

### 프로토콜 사양

마지막 팁은 실제 팁은 아니지만 그래도 저희가 이 정보를 공유해 드릴 가치가 있다고 생각했습니다.

대부분의 경우 AEM 및 Dispatcher가 기본적으로 작동합니다. 따라서 자체 애플리케이션을 맨 위에 빌드하기 위해 무효화 프로토콜에 대한 포괄적인 Dispatcher 프로토콜 사양을 찾지 못할 것입니다. 그 정보는 공개적이지만, 많은 자원들로 약간 흩어져 있다.

우리는 여기에서 어느 정도 간격을 메우려고 한다. 다음은 무효화 요청의 모습입니다.

```
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: <action>
CQ-Handle: <path-pattern>
[CQ-Action-Scope]
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]

<newline>

<refetch-url-1>
<refetch-url-2>

…

<refetch-url-n>
```

`POST /dispatcher/invalidate.cache HTTP/1.1` - 첫 번째 줄은 Dispatcher 제어 끝점의 URL이며 변경되지 않을 가능성이 있습니다.

`CQ-Action: <action>` 무슨 일이 벌어져야 할까 `<action>` 다음 중 하나입니다.

* `Activate:` 삭제  `/path-pattern.*`
* `Deactive:` 삭제  `/path-pattern.*`
및 삭제  `/path-pattern/*`
* `Delete:`   삭제  `/path-pattern.*`
및 삭제 
`/path-pattern/*`
* `Test:`   &quot;ok&quot;를 반환하되 아무 작업도 수행하지 마십시오

`CQ-Handle: <path-pattern>` - 무효화할 컨텐츠 리소스 경로입니다. 참고: `<path-pattern>`은 실제로 &quot;pattern&quot;이 아니라 &quot;path&quot;입니다.

`CQ-Action-Scope: ResourceOnly` - 선택 사항:이 헤더를 설정하면  `.stat` 파일이 터치되지 않습니다.

```
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]
```

자동 참조 URL 목록을 정의하는 경우 이러한 헤더를 설정합니다. `<bytes in request body>` 는 HTTP 본문에 있는 문자 수입니다

`<newline>` - 요청 본문이 있는 경우 헤더에서 빈 행으로 분리되어야 합니다.

```
<refetch-url-1>
<refetch-url-2>
…
<refetch-url-n>
```

무효화 후 즉시 다시 가져올 URL을 나열합니다.

## 추가 리소스

Dispatcher 캐싱에 대한 좋은 개요 및 소개입니다.[https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html)

팁과 트릭 최적화:[https://helpx.adobe.com/experience-manager/kb/optimizing-the-dispatcher-cache.html#use-ttls](https://helpx.adobe.com/experience-manager/kb/optimizing-the-dispatcher-cache.html#use-ttls)

모든 지시어가 포함된 Dispatcher 설명서 설명:[https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html)

FAQ:[https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html](https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html)

Dispatcher 최적화에 대한 웨비나 기록 - 적극 권장:[https://my.adobeconnect.com/p7th2gf8k43?proto=true](https://my.adobeconnect.com/p7th2gf8k43?proto=true)

프레젠테이션 &quot;컨텐츠 무효화의 저평가 기능&quot;, &quot;adaptTo()&quot; 컨퍼런스가 Postdam 2018년 [https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html](https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html)

AEM에서 캐시된 페이지 무효화:[https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

## 다음 단계

* [2 - 인프라 패턴](chapter-2.md)
