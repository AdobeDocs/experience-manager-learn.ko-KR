---
title: 자산 계산 작업자 개발
description: 자산 계산 작업자는 자산에서 새 변환을 만들기 위해 수행한 작업을 수행하거나 조정하는 사용자 정의 기능을 제공하는 자산 계산 프로젝트의 핵심입니다.
feature: asset-compute
topics: renditions, development
version: cloud-service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
translation-type: tm+mt
source-git-commit: 6f5df098e2e68a78efc908c054f9d07fcf22a372
workflow-type: tm+mt
source-wordcount: '1418'
ht-degree: 0%

---


# 자산 계산 작업자 개발

자산 계산 작업자는 자산에서 새 변환을 만들기 위해 수행한 작업을 수행하거나 조정하는 사용자 정의 기능을 제공하는 자산 계산 프로젝트의 핵심입니다.

자산 계산 프로젝트는 간단한 작업자를 자동으로 생성하여 자산의 원래 바이너리를 명명된 변환으로 복사하고 변형하지 않습니다. 이 튜토리얼에서는 Asset Compute Workers의 강력한 기능을 설명하기 위해 이 작업자를 수정하여 보다 흥미로운 표현물을 만들게 됩니다.

자산 계산 작업자를 만들어 새로운 가로 이미지 변환을 생성하며, 자산 변환의 왼쪽과 오른쪽에 빈 공간을 포함하고 흐릿한 버전의 에셋을 사용할 수 있습니다. 최종 표현물의 폭, 높이 및 흐림 효과는 매개 변수화됩니다.

## 자산 계산 작업자 호출의 논리 흐름

자산 계산 작업자는 개념적으로, `renditionCallback(...)` 함수에서 자산 계산 SDK 작업자 API 계약을 구현합니다.

+ __입력:__ AEM 자산의 원래 이진 및 처리 프로필 매개 변수
+ __출력:__ AEM 자산에 추가할 하나 이상의 변환

![자산 계산 작업자 논리 흐름](./assets/worker/logical-flow.png)

1. AEM 작성자 서비스는 자산의 __(1a)__ 원래 이진(매개 변수)`source` 및 __(1b)__ 처리 프로필(`rendition.instructions` 매개 변수)에 정의된 모든 매개 변수를 제공하여 자산 계산 작업자를호출합니다.
1. Asset Compute SDK는 사용자 지정 Asset Compute 메타데이터 작업자 `renditionCallback(...)` 기능의 실행을 구성하며 자산의 원래 이진 __(1a)__ 및 모든 매개 변수 __(1b)__&#x200B;에 따라 새 이진 변환을 생성합니다.

   + 이 자습서에서는 변환이 &quot;진행 중&quot;으로 만들어집니다. 이는 작업자가 변환을 구성하지만 변환 생성을 위해 소스 바이너리를 다른 웹 서비스 API로 전송할 수 있음을 의미합니다.

1. 자산 계산 작업자는 새 변환의 이진 데이터를 저장합니다 `rendition.path`.
1. 에 기록된 이진 데이터 `rendition.path` 는 자산 계산 SDK를 통해 AEM 작성자 서비스로 전송되고 __(4a)__ 텍스트 변환 및 __(4b)__ 자산의 메타데이터 노드에 지속됩니다.

위의 다이어그램은 Asset Compute 개발자 대면 관련 문제와 Asset Compute 작업자 호출로의 논리 흐름을 기술합니다. 궁금한 사항을 위해 자산 계산 실행에 [대한](https://docs.adobe.com/content/help/en/asset-compute/using/extend/custom-application-internals.html) 내부 세부 사항은 사용할 수 있지만 공개 자산 계산 SDK API 계약만 의존할 수 있습니다.

## 근로자의 구조

모든 자산 계산 근로자는 동일한 기본 구조 및 입력/출력 계약을 따릅니다.

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## 작업자 index.js 열기

![자동으로 생성된 index.js](./assets/worker/autogenerated-index-js.png)

1. 자산 계산 프로젝트가 VS 코드로 열려 있는지 확인
1. 폴더로 `/actions/worker` 이동
1. Open the `index.js` file

이 튜토리얼에서 수정할 작업자 JavaScript 파일입니다.

## 지원 npm 모듈 설치 및 가져오기

Node.js 기반의 자산 컴퓨팅 프로젝트는 강력한 [npm 모듈 에코시스템의 이점을 활용합니다](https://npmjs.com). npm 모듈을 활용하려면 먼저 Asset Compute 프로젝트에 설치해야 합니다.

In this worker, we leverage the [jimp](https://www.npmjs.com/package/jimp) to create and manipate the rendition image directly in the Node.js code.

>[!WARNING]
>
>자산 조작에 대한 모든 npm 모듈이 자산 계산에서 지원되는 것은 아닙니다. ImageMagick 또는 OS 종속 라이브러리와 같은 다른 응용 프로그램의 기존 사용에 의존하는 npm 모듈입니다. JavaScript 전용 npm 모듈 사용을 제한하는 것이 가장 좋습니다.

1. 자산 계산 프로젝트의 루트에서 명령줄을 열고(터미널 > 새 터미널을 통해 VS 코드에서 수행할 수 있음 ____) 명령을 실행합니다.

   ```
   $ npm install jimp
   ```

1. JavaScript 개체를 통해 사용할 수 있도록 모듈을 작업자 코드로 `jimp` `Jimp` 가져옵니다.
작업자 `require` 상단의 지시문을 업데이트하여 `index.js` 모듈에서 `Jimp` `jimp` 객체를 가져옵니다.

   ```javascript
   'use strict';
   
   const { Jimp } = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## 매개 변수 읽기

자산 계산 작업자는 AEM에서 Cloud Service 작성자 서비스로 정의된 처리 프로필을 통해 전달할 수 있는 매개 변수로 읽을 수 있습니다. 매개 변수는 객체를 통해 작업자로 `rendition.instructions` 전달됩니다.

작업자 코드에서 액세스하여 읽을 수 `rendition.instructions.<parameterName>` 있습니다.

여기서 구성 가능한 변환 `SIZE`을 읽고 처리 프로필을 통해 제공되지 않은 경우 기본값 `BRIGHTNESS` `CONTRAST`을 제공합니다. AEM `renditions.instructions` 에서 Cloud Service 처리 프로필로 호출될 때 문자열로 전달되므로 작업자 코드에서 올바른 데이터 유형으로 변형됩니다.

```javascript
'use strict';

const { Jimp } = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## 오류 발생{#errors}

자산 계산 작업자는 오류를 유발하는 상황에 직면할 수 있습니다. Adobe 자산 계산 SDK는 이러한 상황 [이 발생할 때 발생할 수 있는 사전 정의된 오류](https://github.com/adobe/asset-compute-commons#asset-compute-errors) 세트를 제공합니다. 특정 오류 유형이 적용되지 않는 경우 해당 오류 유형을 사용하거나 특정 사용자 정의 `GenericError` 를 정의할 `ClientErrors` 수 있습니다.

변환 처리를 시작하기 전에 이 작업자의 컨텍스트에서 모든 매개 변수가 유효하고 지원되는지 확인하십시오.

+ 변환 명령 매개 변수 `SIZE`, `CONTRAST`및 `BRIGHTNESS` 의 유효성을 확인합니다. 그렇지 않으면 사용자 지정 오류를 던집니다 `RenditionInstructionsError`.
   + 확장되는 사용자 `RenditionInstructionsError` 지정 클래스 `ClientError` 는 이 파일의 하단에 정의됩니다. 특정 사용자 지정 오류를 사용하면 작업자에 대한 테스트를 [작성할](../test-debug/test.md) 때 유용합니다.

```javascript
'use strict';

const { Jimp } = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 변환 만들기

매개 변수를 읽고, 문서의 기밀 정보 가리기 및 확인하면 변환이 생성되도록 코드가 작성됩니다. 변환 생성을 위한 의사 코드는 다음과 같습니다.

1. 매개 변수를 통해 지정된 정사각형 크기로 새 `renditionImage` 캔버스를 `size` 만듭니다.
1. 소스 자산의 바이너리에서 `image` 개체 만들기
1. Jimp __라이브러리를__ 사용하여 이미지를 변형합니다.
   + 원본 이미지를 가운데 정사각형으로 자르기
   + &quot;제곱&quot; 이미지의 중심에서 원 자르기
   + 매개 변수 값으로 정의된 차원에 맞게 크기 `SIZE` 조정
   + 매개 변수 값에 따라 대비 `CONTRAST` 조정
   + 매개 변수 값에 따라 명도 `BRIGHTNESS` 조정
1. 변형된 이미지를 투명한 배경 `image` 이 있는 `renditionImage` 가운데
1. 작성된 문서를 작성하여 다시 AEM `renditionImage` 에 에셋 변환으로 저장할 수 `rendition.path` 있도록 합니다.

이 코드는 Jimp [API를 사용하여](https://github.com/oliver-moran/jimp#jimp) 이러한 이미지 변형을 수행합니다.

자산 계산 작업자는 작업을 동기적으로 마쳐야 하며, 작업자의 작업이 `rendition.path` `renditionCallback` 완료되기 전에 전체 내용을 다시 작성해야 합니다. 이를 위해서는 비동기 함수 호출이 연산자를 사용하여 동기식으로 `await` 수행되어야 합니다. JavaScript 비동기 함수 및 비동기 함수를 동기 방식으로 실행하는 방법에 익숙하지 않은 경우, [JavaScript의 대기 연산자에 익숙해지십시오](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await).

완성된 작업자는 다음과 `index.js` 같아야 합니다.

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 10,000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image of the target size with a transparent background (0x0)
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness using Jimp
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    renditionImage.write(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 작업자 실행

이제 작업자 코드가 완료되고, [manifest.yml](./manifest.md)에 이전에 등록 및 구성되었으므로 로컬 자산 계산 개발 도구를 사용하여 실행하여 결과를 볼 수 있습니다.

1. 자산 계산 프로젝트의 루트에서
1. 실행 `aio app run`
1. 자산 계산 개발 도구가 새 창에서 열릴 때까지 대기
1. 파일 __선택..__ 드롭다운에서 처리할 샘플 이미지를 선택합니다.
   + 소스 에셋 바이너리로 사용할 샘플 이미지 파일 선택
   + 아직 없는 경우 왼쪽에 있는 __(+)__ 를 누르고 [샘플 이미지](../assets/samples/sample-file.jpg) 파일을 업로드하고 개발 도구 브라우저 창을 새로 고칩니다.
1. 이 작업자 `"name": "rendition.png"` 로 업데이트하여 투명한 PNG를 생성합니다.
   + 이 &quot;name&quot; 매개 변수는 개발 도구에만 사용되며 의존해서는 안 됩니다.

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```
1. Run __을__ 누르고 변환이 생성될 때까지 기다립니다
1. 표현물 __섹션은__ 생성된 표현물을 미리 봅니다. 변환 미리 보기를 눌러 전체 변환 다운로드

   ![기본 PNG 변환](./assets/worker/default-rendition.png)

### 매개 변수를 사용하여 작업자 실행

처리 프로필 구성을 통해 전달된 매개 변수는 변환 매개 변수 JSON에 키/값 쌍으로 제공하여 에셋 계산 개발 도구에서 시뮬레이션할 수 있습니다.

>[!WARNING]
>
>로컬 개발 중에 다양한 데이터 유형을 사용하여 값을 전달할 수 있으며 AEM에서 Cloud Service 처리 프로필로 전달되면 문자열로 전달할 수 있으므로 필요한 경우 올바른 데이터 유형을 구문 분석해야 합니다.
> 예를 들어 Jimp의 `crop(width, height)` 함수에는 매개 변수가 `int`s여야 합니다.int `parseInt(rendition.instructions.size)` `jimp.crop(SIZE, SIZE)` 로 구문 분석되지 않으면 매개 변수가 &#39;String&#39; 형식과 호환되지 않으므로 호출은 실패합니다.

Adobe 코드에서는 다음에 대한 매개 변수를 허용합니다.

+ `size` 표현식의 크기(높이와 너비를 정수로 정의)
+ `contrast` 대조 조정을 정의하며 -1과 1 사이여야 합니다(부동).
+ `brightness`  부동 중에서 -1과 1 사이의 밝은 조정을 정의합니다.

이러한 내용은 다음 방법을 통해 작업자에게 `index.js` 표시됩니다.

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. 변환 매개 변수를 업데이트하여 크기, 대비 및 밝기를 사용자 정의합니다.

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 다시 __실행__ 탭
1. 변환 미리 보기를 눌러 생성된 변환을 다운로드하고 검토합니다. 기본 변환과 비교하여 크기와 대비 및 밝기가 어떻게 변경되었는지 확인하십시오.

   ![매개 변수화된 PNG 변환](./assets/worker/parameterized-rendition.png)

1. 다른 이미지를 __소스 파일__ 드롭다운에 업로드하고 다른 매개 변수를 사용하여 작업자를 실행해 보십시오.

## Github의 Worker index.js

결승전은 다음 위치의 Github에서 볼 수 있습니다. `index.js`

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## 문제 해결

+ [변환이 부분적으로 그림/손상된](../troubleshooting.md#rendition-returned-partially-drawn-or-corrupt)
